import { grpc } from '@improbable-eng/grpc-web';
import { BrowserHeaders } from 'browser-headers';
import _m0 from 'protobufjs';
import Long from 'long';
import { Registry } from '@cosmjs/proto-signing';
import { createDefaultAminoConverters, SigningStargateClient, AminoTypes } from '@cosmjs/stargate';
import { NodeHttpTransport } from '@improbable-eng/grpc-web-node-http-transport';

/* eslint-disable */
const protobufPackage$X = "cosmos.base.query.v1beta1";
function createBasePageRequest() {
    return { key: new Uint8Array(0), offset: 0, limit: 0, countTotal: false, reverse: false };
}
const PageRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key.length !== 0) {
            writer.uint32(10).bytes(message.key);
        }
        if (message.offset !== 0) {
            writer.uint32(16).uint64(message.offset);
        }
        if (message.limit !== 0) {
            writer.uint32(24).uint64(message.limit);
        }
        if (message.countTotal === true) {
            writer.uint32(32).bool(message.countTotal);
        }
        if (message.reverse === true) {
            writer.uint32(40).bool(message.reverse);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePageRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.bytes();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.offset = longToNumber$q(reader.uint64());
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.limit = longToNumber$q(reader.uint64());
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.countTotal = reader.bool();
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.reverse = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet$V(object.key) ? bytesFromBase64$9(object.key) : new Uint8Array(0),
            offset: isSet$V(object.offset) ? Number(object.offset) : 0,
            limit: isSet$V(object.limit) ? Number(object.limit) : 0,
            countTotal: isSet$V(object.countTotal) ? Boolean(object.countTotal) : false,
            reverse: isSet$V(object.reverse) ? Boolean(object.reverse) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key.length !== 0) {
            obj.key = base64FromBytes$9(message.key);
        }
        if (message.offset !== 0) {
            obj.offset = Math.round(message.offset);
        }
        if (message.limit !== 0) {
            obj.limit = Math.round(message.limit);
        }
        if (message.countTotal === true) {
            obj.countTotal = message.countTotal;
        }
        if (message.reverse === true) {
            obj.reverse = message.reverse;
        }
        return obj;
    },
    create(base) {
        return PageRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePageRequest();
        message.key = object.key ?? new Uint8Array(0);
        message.offset = object.offset ?? 0;
        message.limit = object.limit ?? 0;
        message.countTotal = object.countTotal ?? false;
        message.reverse = object.reverse ?? false;
        return message;
    },
};
function createBasePageResponse() {
    return { nextKey: new Uint8Array(0), total: 0 };
}
const PageResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.nextKey.length !== 0) {
            writer.uint32(10).bytes(message.nextKey);
        }
        if (message.total !== 0) {
            writer.uint32(16).uint64(message.total);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePageResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.nextKey = reader.bytes();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.total = longToNumber$q(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            nextKey: isSet$V(object.nextKey) ? bytesFromBase64$9(object.nextKey) : new Uint8Array(0),
            total: isSet$V(object.total) ? Number(object.total) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.nextKey.length !== 0) {
            obj.nextKey = base64FromBytes$9(message.nextKey);
        }
        if (message.total !== 0) {
            obj.total = Math.round(message.total);
        }
        return obj;
    },
    create(base) {
        return PageResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePageResponse();
        message.nextKey = object.nextKey ?? new Uint8Array(0);
        message.total = object.total ?? 0;
        return message;
    },
};
const tsProtoGlobalThis$G = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function bytesFromBase64$9(b64) {
    if (tsProtoGlobalThis$G.Buffer) {
        return Uint8Array.from(tsProtoGlobalThis$G.Buffer.from(b64, "base64"));
    }
    else {
        const bin = tsProtoGlobalThis$G.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes$9(arr) {
    if (tsProtoGlobalThis$G.Buffer) {
        return tsProtoGlobalThis$G.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(String.fromCharCode(byte));
        });
        return tsProtoGlobalThis$G.btoa(bin.join(""));
    }
}
function longToNumber$q(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new tsProtoGlobalThis$G.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isSet$V(value) {
    return value !== null && value !== undefined;
}

/* eslint-disable */
const protobufPackage$W = "canine_chain.filetree";
function createBaseFiles() {
    return { address: "", contents: "", owner: "", viewingAccess: "", editAccess: "", trackingNumber: "" };
}
const Files = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        if (message.contents !== "") {
            writer.uint32(18).string(message.contents);
        }
        if (message.owner !== "") {
            writer.uint32(26).string(message.owner);
        }
        if (message.viewingAccess !== "") {
            writer.uint32(34).string(message.viewingAccess);
        }
        if (message.editAccess !== "") {
            writer.uint32(42).string(message.editAccess);
        }
        if (message.trackingNumber !== "") {
            writer.uint32(50).string(message.trackingNumber);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFiles();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.contents = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.owner = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.viewingAccess = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.editAccess = reader.string();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.trackingNumber = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            address: isSet$U(object.address) ? String(object.address) : "",
            contents: isSet$U(object.contents) ? String(object.contents) : "",
            owner: isSet$U(object.owner) ? String(object.owner) : "",
            viewingAccess: isSet$U(object.viewingAccess) ? String(object.viewingAccess) : "",
            editAccess: isSet$U(object.editAccess) ? String(object.editAccess) : "",
            trackingNumber: isSet$U(object.trackingNumber) ? String(object.trackingNumber) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.address !== "") {
            obj.address = message.address;
        }
        if (message.contents !== "") {
            obj.contents = message.contents;
        }
        if (message.owner !== "") {
            obj.owner = message.owner;
        }
        if (message.viewingAccess !== "") {
            obj.viewingAccess = message.viewingAccess;
        }
        if (message.editAccess !== "") {
            obj.editAccess = message.editAccess;
        }
        if (message.trackingNumber !== "") {
            obj.trackingNumber = message.trackingNumber;
        }
        return obj;
    },
    create(base) {
        return Files.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFiles();
        message.address = object.address ?? "";
        message.contents = object.contents ?? "";
        message.owner = object.owner ?? "";
        message.viewingAccess = object.viewingAccess ?? "";
        message.editAccess = object.editAccess ?? "";
        message.trackingNumber = object.trackingNumber ?? "";
        return message;
    },
};
function isSet$U(value) {
    return value !== null && value !== undefined;
}

/* eslint-disable */
const protobufPackage$V = "canine_chain.filetree";
function createBaseParams$9() {
    return {};
}
const Params$9 = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParams$9();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return Params$9.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseParams$9();
        return message;
    },
};

/* eslint-disable */
const protobufPackage$U = "canine_chain.filetree";
function createBasePubkey() {
    return { address: "", key: "" };
}
const Pubkey = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        if (message.key !== "") {
            writer.uint32(18).string(message.key);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePubkey();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            address: isSet$T(object.address) ? String(object.address) : "",
            key: isSet$T(object.key) ? String(object.key) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.address !== "") {
            obj.address = message.address;
        }
        if (message.key !== "") {
            obj.key = message.key;
        }
        return obj;
    },
    create(base) {
        return Pubkey.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePubkey();
        message.address = object.address ?? "";
        message.key = object.key ?? "";
        return message;
    },
};
function isSet$T(value) {
    return value !== null && value !== undefined;
}

/* eslint-disable */
const protobufPackage$T = "canine_chain.filetree";
function createBaseQueryParamsRequest$a() {
    return {};
}
const QueryParamsRequest$a = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest$a();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return QueryParamsRequest$a.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseQueryParamsRequest$a();
        return message;
    },
};
function createBaseQueryParamsResponse$a() {
    return { params: undefined };
}
const QueryParamsResponse$a = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.params !== undefined) {
            Params$9.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse$a();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.params = Params$9.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { params: isSet$S(object.params) ? Params$9.fromJSON(object.params) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.params !== undefined) {
            obj.params = Params$9.toJSON(message.params);
        }
        return obj;
    },
    create(base) {
        return QueryParamsResponse$a.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryParamsResponse$a();
        message.params = (object.params !== undefined && object.params !== null)
            ? Params$9.fromPartial(object.params)
            : undefined;
        return message;
    },
};
function createBaseQueryEncryptRequest() {
    return { address: "", message: "" };
}
const QueryEncryptRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        if (message.message !== "") {
            writer.uint32(18).string(message.message);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryEncryptRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.message = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            address: isSet$S(object.address) ? String(object.address) : "",
            message: isSet$S(object.message) ? String(object.message) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.address !== "") {
            obj.address = message.address;
        }
        if (message.message !== "") {
            obj.message = message.message;
        }
        return obj;
    },
    create(base) {
        return QueryEncryptRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryEncryptRequest();
        message.address = object.address ?? "";
        message.message = object.message ?? "";
        return message;
    },
};
function createBaseQueryEncryptResponse() {
    return { encryptionData: "" };
}
const QueryEncryptResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.encryptionData !== "") {
            writer.uint32(10).string(message.encryptionData);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryEncryptResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.encryptionData = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { encryptionData: isSet$S(object.encryptionData) ? String(object.encryptionData) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.encryptionData !== "") {
            obj.encryptionData = message.encryptionData;
        }
        return obj;
    },
    create(base) {
        return QueryEncryptResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryEncryptResponse();
        message.encryptionData = object.encryptionData ?? "";
        return message;
    },
};
function createBaseQueryDecryptRequest() {
    return { message: "" };
}
const QueryDecryptRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.message !== "") {
            writer.uint32(10).string(message.message);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDecryptRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.message = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { message: isSet$S(object.message) ? String(object.message) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.message !== "") {
            obj.message = message.message;
        }
        return obj;
    },
    create(base) {
        return QueryDecryptRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryDecryptRequest();
        message.message = object.message ?? "";
        return message;
    },
};
function createBaseQueryDecryptResponse() {
    return { data: "" };
}
const QueryDecryptResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.data !== "") {
            writer.uint32(10).string(message.data);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDecryptResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.data = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { data: isSet$S(object.data) ? String(object.data) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.data !== "") {
            obj.data = message.data;
        }
        return obj;
    },
    create(base) {
        return QueryDecryptResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryDecryptResponse();
        message.data = object.data ?? "";
        return message;
    },
};
function createBaseQueryFileRequest() {
    return { address: "", ownerAddress: "" };
}
const QueryFileRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        if (message.ownerAddress !== "") {
            writer.uint32(18).string(message.ownerAddress);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryFileRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.ownerAddress = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            address: isSet$S(object.address) ? String(object.address) : "",
            ownerAddress: isSet$S(object.ownerAddress) ? String(object.ownerAddress) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.address !== "") {
            obj.address = message.address;
        }
        if (message.ownerAddress !== "") {
            obj.ownerAddress = message.ownerAddress;
        }
        return obj;
    },
    create(base) {
        return QueryFileRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryFileRequest();
        message.address = object.address ?? "";
        message.ownerAddress = object.ownerAddress ?? "";
        return message;
    },
};
function createBaseQueryFileResponse() {
    return { files: undefined };
}
const QueryFileResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.files !== undefined) {
            Files.encode(message.files, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryFileResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.files = Files.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { files: isSet$S(object.files) ? Files.fromJSON(object.files) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.files !== undefined) {
            obj.files = Files.toJSON(message.files);
        }
        return obj;
    },
    create(base) {
        return QueryFileResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryFileResponse();
        message.files = (object.files !== undefined && object.files !== null) ? Files.fromPartial(object.files) : undefined;
        return message;
    },
};
function createBaseQueryAllFilesRequest() {
    return { pagination: undefined };
}
const QueryAllFilesRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.pagination !== undefined) {
            PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllFilesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.pagination = PageRequest.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { pagination: isSet$S(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.pagination !== undefined) {
            obj.pagination = PageRequest.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryAllFilesRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryAllFilesRequest();
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageRequest.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryAllFilesResponse() {
    return { files: [], pagination: undefined };
}
const QueryAllFilesResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.files) {
            Files.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllFilesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.files.push(Files.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageResponse.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            files: Array.isArray(object?.files) ? object.files.map((e) => Files.fromJSON(e)) : [],
            pagination: isSet$S(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.files?.length) {
            obj.files = message.files.map((e) => Files.toJSON(e));
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageResponse.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryAllFilesResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryAllFilesResponse();
        message.files = object.files?.map((e) => Files.fromPartial(e)) || [];
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageResponse.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryPubkeyRequest() {
    return { address: "" };
}
const QueryPubkeyRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryPubkeyRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { address: isSet$S(object.address) ? String(object.address) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.address !== "") {
            obj.address = message.address;
        }
        return obj;
    },
    create(base) {
        return QueryPubkeyRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryPubkeyRequest();
        message.address = object.address ?? "";
        return message;
    },
};
function createBaseQueryPubkeyResponse() {
    return { pubkey: undefined };
}
const QueryPubkeyResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.pubkey !== undefined) {
            Pubkey.encode(message.pubkey, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryPubkeyResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.pubkey = Pubkey.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { pubkey: isSet$S(object.pubkey) ? Pubkey.fromJSON(object.pubkey) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.pubkey !== undefined) {
            obj.pubkey = Pubkey.toJSON(message.pubkey);
        }
        return obj;
    },
    create(base) {
        return QueryPubkeyResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryPubkeyResponse();
        message.pubkey = (object.pubkey !== undefined && object.pubkey !== null)
            ? Pubkey.fromPartial(object.pubkey)
            : undefined;
        return message;
    },
};
function createBaseQueryAllPubkeysRequest() {
    return { pagination: undefined };
}
const QueryAllPubkeysRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.pagination !== undefined) {
            PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllPubkeysRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.pagination = PageRequest.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { pagination: isSet$S(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.pagination !== undefined) {
            obj.pagination = PageRequest.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryAllPubkeysRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryAllPubkeysRequest();
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageRequest.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryAllPubkeysResponse() {
    return { pubkey: [], pagination: undefined };
}
const QueryAllPubkeysResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.pubkey) {
            Pubkey.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllPubkeysResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.pubkey.push(Pubkey.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageResponse.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            pubkey: Array.isArray(object?.pubkey) ? object.pubkey.map((e) => Pubkey.fromJSON(e)) : [],
            pagination: isSet$S(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.pubkey?.length) {
            obj.pubkey = message.pubkey.map((e) => Pubkey.toJSON(e));
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageResponse.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryAllPubkeysResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryAllPubkeysResponse();
        message.pubkey = object.pubkey?.map((e) => Pubkey.fromPartial(e)) || [];
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageResponse.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
let QueryClientImpl$a = class QueryClientImpl {
    rpc;
    constructor(rpc) {
        this.rpc = rpc;
        this.Params = this.Params.bind(this);
        this.Encrypt = this.Encrypt.bind(this);
        this.Decrypt = this.Decrypt.bind(this);
        this.Files = this.Files.bind(this);
        this.FilesAll = this.FilesAll.bind(this);
        this.Pubkey = this.Pubkey.bind(this);
        this.PubkeyAll = this.PubkeyAll.bind(this);
    }
    Params(request, metadata) {
        return this.rpc.unary(QueryParamsDesc$a, QueryParamsRequest$a.fromPartial(request), metadata);
    }
    Encrypt(request, metadata) {
        return this.rpc.unary(QueryEncryptDesc, QueryEncryptRequest.fromPartial(request), metadata);
    }
    Decrypt(request, metadata) {
        return this.rpc.unary(QueryDecryptDesc, QueryDecryptRequest.fromPartial(request), metadata);
    }
    Files(request, metadata) {
        return this.rpc.unary(QueryFilesDesc, QueryFileRequest.fromPartial(request), metadata);
    }
    FilesAll(request, metadata) {
        return this.rpc.unary(QueryFilesAllDesc, QueryAllFilesRequest.fromPartial(request), metadata);
    }
    Pubkey(request, metadata) {
        return this.rpc.unary(QueryPubkeyDesc, QueryPubkeyRequest.fromPartial(request), metadata);
    }
    PubkeyAll(request, metadata) {
        return this.rpc.unary(QueryPubkeyAllDesc, QueryAllPubkeysRequest.fromPartial(request), metadata);
    }
};
const QueryDesc$a = { serviceName: "canine_chain.filetree.Query" };
const QueryParamsDesc$a = {
    methodName: "Params",
    service: QueryDesc$a,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryParamsRequest$a.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryParamsResponse$a.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryEncryptDesc = {
    methodName: "Encrypt",
    service: QueryDesc$a,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryEncryptRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryEncryptResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryDecryptDesc = {
    methodName: "Decrypt",
    service: QueryDesc$a,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryDecryptRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryDecryptResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryFilesDesc = {
    methodName: "Files",
    service: QueryDesc$a,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryFileRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryFileResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryFilesAllDesc = {
    methodName: "FilesAll",
    service: QueryDesc$a,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryAllFilesRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryAllFilesResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryPubkeyDesc = {
    methodName: "Pubkey",
    service: QueryDesc$a,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryPubkeyRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryPubkeyResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryPubkeyAllDesc = {
    methodName: "PubkeyAll",
    service: QueryDesc$a,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryAllPubkeysRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryAllPubkeysResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
let GrpcWebImpl$l = class GrpcWebImpl {
    host;
    options;
    constructor(host, options) {
        this.host = host;
        this.options = options;
    }
    unary(methodDesc, _request, metadata) {
        const request = { ..._request, ...methodDesc.requestType };
        const maybeCombinedMetadata = metadata && this.options.metadata
            ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
            : metadata ?? this.options.metadata;
        return new Promise((resolve, reject) => {
            grpc.unary(methodDesc, {
                request,
                host: this.host,
                metadata: maybeCombinedMetadata ?? {},
                ...(this.options.transport !== undefined ? { transport: this.options.transport } : {}),
                debug: this.options.debug ?? false,
                onEnd: function (response) {
                    if (response.status === grpc.Code.OK) {
                        resolve(response.message.toObject());
                    }
                    else {
                        const err = new GrpcWebError$l(response.statusMessage, response.status, response.trailers);
                        reject(err);
                    }
                },
            });
        });
    }
};
const tsProtoGlobalThis$F = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function isSet$S(value) {
    return value !== null && value !== undefined;
}
let GrpcWebError$l = class GrpcWebError extends tsProtoGlobalThis$F.Error {
    code;
    metadata;
    constructor(message, code, metadata) {
        super(message);
        this.code = code;
        this.metadata = metadata;
    }
};

/* eslint-disable */
const protobufPackage$S = "canine_chain.jklmint";
function createBaseParams$8() {
    return { mintDenom: "" };
}
const Params$8 = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.mintDenom !== "") {
            writer.uint32(10).string(message.mintDenom);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParams$8();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.mintDenom = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { mintDenom: isSet$R(object.mintDenom) ? String(object.mintDenom) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.mintDenom !== "") {
            obj.mintDenom = message.mintDenom;
        }
        return obj;
    },
    create(base) {
        return Params$8.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseParams$8();
        message.mintDenom = object.mintDenom ?? "";
        return message;
    },
};
function isSet$R(value) {
    return value !== null && value !== undefined;
}

/* eslint-disable */
const protobufPackage$R = "canine_chain.jklmint";
function createBaseQueryParamsRequest$9() {
    return {};
}
const QueryParamsRequest$9 = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest$9();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return QueryParamsRequest$9.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseQueryParamsRequest$9();
        return message;
    },
};
function createBaseQueryParamsResponse$9() {
    return { params: undefined };
}
const QueryParamsResponse$9 = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.params !== undefined) {
            Params$8.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse$9();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.params = Params$8.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { params: isSet$Q(object.params) ? Params$8.fromJSON(object.params) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.params !== undefined) {
            obj.params = Params$8.toJSON(message.params);
        }
        return obj;
    },
    create(base) {
        return QueryParamsResponse$9.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryParamsResponse$9();
        message.params = (object.params !== undefined && object.params !== null)
            ? Params$8.fromPartial(object.params)
            : undefined;
        return message;
    },
};
function createBaseQueryInflationRequest() {
    return {};
}
const QueryInflationRequest = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryInflationRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return QueryInflationRequest.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseQueryInflationRequest();
        return message;
    },
};
function createBaseQueryInflationResponse() {
    return { inflation: new Uint8Array(0) };
}
const QueryInflationResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.inflation.length !== 0) {
            writer.uint32(10).bytes(message.inflation);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryInflationResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.inflation = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { inflation: isSet$Q(object.inflation) ? bytesFromBase64$8(object.inflation) : new Uint8Array(0) };
    },
    toJSON(message) {
        const obj = {};
        if (message.inflation.length !== 0) {
            obj.inflation = base64FromBytes$8(message.inflation);
        }
        return obj;
    },
    create(base) {
        return QueryInflationResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryInflationResponse();
        message.inflation = object.inflation ?? new Uint8Array(0);
        return message;
    },
};
let QueryClientImpl$9 = class QueryClientImpl {
    rpc;
    constructor(rpc) {
        this.rpc = rpc;
        this.Params = this.Params.bind(this);
        this.Inflation = this.Inflation.bind(this);
    }
    Params(request, metadata) {
        return this.rpc.unary(QueryParamsDesc$9, QueryParamsRequest$9.fromPartial(request), metadata);
    }
    Inflation(request, metadata) {
        return this.rpc.unary(QueryInflationDesc, QueryInflationRequest.fromPartial(request), metadata);
    }
};
const QueryDesc$9 = { serviceName: "canine_chain.jklmint.Query" };
const QueryParamsDesc$9 = {
    methodName: "Params",
    service: QueryDesc$9,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryParamsRequest$9.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryParamsResponse$9.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryInflationDesc = {
    methodName: "Inflation",
    service: QueryDesc$9,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryInflationRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryInflationResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
let GrpcWebImpl$k = class GrpcWebImpl {
    host;
    options;
    constructor(host, options) {
        this.host = host;
        this.options = options;
    }
    unary(methodDesc, _request, metadata) {
        const request = { ..._request, ...methodDesc.requestType };
        const maybeCombinedMetadata = metadata && this.options.metadata
            ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
            : metadata ?? this.options.metadata;
        return new Promise((resolve, reject) => {
            grpc.unary(methodDesc, {
                request,
                host: this.host,
                metadata: maybeCombinedMetadata ?? {},
                ...(this.options.transport !== undefined ? { transport: this.options.transport } : {}),
                debug: this.options.debug ?? false,
                onEnd: function (response) {
                    if (response.status === grpc.Code.OK) {
                        resolve(response.message.toObject());
                    }
                    else {
                        const err = new GrpcWebError$k(response.statusMessage, response.status, response.trailers);
                        reject(err);
                    }
                },
            });
        });
    }
};
const tsProtoGlobalThis$E = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function bytesFromBase64$8(b64) {
    if (tsProtoGlobalThis$E.Buffer) {
        return Uint8Array.from(tsProtoGlobalThis$E.Buffer.from(b64, "base64"));
    }
    else {
        const bin = tsProtoGlobalThis$E.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes$8(arr) {
    if (tsProtoGlobalThis$E.Buffer) {
        return tsProtoGlobalThis$E.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(String.fromCharCode(byte));
        });
        return tsProtoGlobalThis$E.btoa(bin.join(""));
    }
}
function isSet$Q(value) {
    return value !== null && value !== undefined;
}
let GrpcWebError$k = class GrpcWebError extends tsProtoGlobalThis$E.Error {
    code;
    metadata;
    constructor(message, code, metadata) {
        super(message);
        this.code = code;
        this.metadata = metadata;
    }
};

/* eslint-disable */
const protobufPackage$Q = "canine_chain.notifications";
function createBaseNotiCounter() {
    return { address: "", counter: 0, blockedSenders: "" };
}
const NotiCounter = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        if (message.counter !== 0) {
            writer.uint32(16).uint64(message.counter);
        }
        if (message.blockedSenders !== "") {
            writer.uint32(26).string(message.blockedSenders);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseNotiCounter();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.counter = longToNumber$p(reader.uint64());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.blockedSenders = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            address: isSet$P(object.address) ? String(object.address) : "",
            counter: isSet$P(object.counter) ? Number(object.counter) : 0,
            blockedSenders: isSet$P(object.blockedSenders) ? String(object.blockedSenders) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.address !== "") {
            obj.address = message.address;
        }
        if (message.counter !== 0) {
            obj.counter = Math.round(message.counter);
        }
        if (message.blockedSenders !== "") {
            obj.blockedSenders = message.blockedSenders;
        }
        return obj;
    },
    create(base) {
        return NotiCounter.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseNotiCounter();
        message.address = object.address ?? "";
        message.counter = object.counter ?? 0;
        message.blockedSenders = object.blockedSenders ?? "";
        return message;
    },
};
const tsProtoGlobalThis$D = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function longToNumber$p(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new tsProtoGlobalThis$D.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isSet$P(value) {
    return value !== null && value !== undefined;
}

/* eslint-disable */
const protobufPackage$P = "canine_chain.notifications";
function createBaseNotifications() {
    return { count: 0, notification: "", address: "", sender: "" };
}
const Notifications = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.count !== 0) {
            writer.uint32(8).uint64(message.count);
        }
        if (message.notification !== "") {
            writer.uint32(18).string(message.notification);
        }
        if (message.address !== "") {
            writer.uint32(26).string(message.address);
        }
        if (message.sender !== "") {
            writer.uint32(34).string(message.sender);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseNotifications();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.count = longToNumber$o(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.notification = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.sender = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            count: isSet$O(object.count) ? Number(object.count) : 0,
            notification: isSet$O(object.notification) ? String(object.notification) : "",
            address: isSet$O(object.address) ? String(object.address) : "",
            sender: isSet$O(object.sender) ? String(object.sender) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.count !== 0) {
            obj.count = Math.round(message.count);
        }
        if (message.notification !== "") {
            obj.notification = message.notification;
        }
        if (message.address !== "") {
            obj.address = message.address;
        }
        if (message.sender !== "") {
            obj.sender = message.sender;
        }
        return obj;
    },
    create(base) {
        return Notifications.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseNotifications();
        message.count = object.count ?? 0;
        message.notification = object.notification ?? "";
        message.address = object.address ?? "";
        message.sender = object.sender ?? "";
        return message;
    },
};
const tsProtoGlobalThis$C = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function longToNumber$o(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new tsProtoGlobalThis$C.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isSet$O(value) {
    return value !== null && value !== undefined;
}

/* eslint-disable */
const protobufPackage$O = "canine_chain.notifications";
function createBaseParams$7() {
    return {};
}
const Params$7 = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParams$7();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return Params$7.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseParams$7();
        return message;
    },
};

/* eslint-disable */
const protobufPackage$N = "canine_chain.notifications";
function createBaseQueryParamsRequest$8() {
    return {};
}
const QueryParamsRequest$8 = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest$8();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return QueryParamsRequest$8.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseQueryParamsRequest$8();
        return message;
    },
};
function createBaseQueryParamsResponse$8() {
    return { params: undefined };
}
const QueryParamsResponse$8 = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.params !== undefined) {
            Params$7.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse$8();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.params = Params$7.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { params: isSet$N(object.params) ? Params$7.fromJSON(object.params) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.params !== undefined) {
            obj.params = Params$7.toJSON(message.params);
        }
        return obj;
    },
    create(base) {
        return QueryParamsResponse$8.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryParamsResponse$8();
        message.params = (object.params !== undefined && object.params !== null)
            ? Params$7.fromPartial(object.params)
            : undefined;
        return message;
    },
};
function createBaseQueryGetNotificationsRequest() {
    return { count: 0, address: "" };
}
const QueryGetNotificationsRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.count !== 0) {
            writer.uint32(8).uint64(message.count);
        }
        if (message.address !== "") {
            writer.uint32(18).string(message.address);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryGetNotificationsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.count = longToNumber$n(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            count: isSet$N(object.count) ? Number(object.count) : 0,
            address: isSet$N(object.address) ? String(object.address) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.count !== 0) {
            obj.count = Math.round(message.count);
        }
        if (message.address !== "") {
            obj.address = message.address;
        }
        return obj;
    },
    create(base) {
        return QueryGetNotificationsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryGetNotificationsRequest();
        message.count = object.count ?? 0;
        message.address = object.address ?? "";
        return message;
    },
};
function createBaseQueryGetNotificationsResponse() {
    return { notifications: undefined };
}
const QueryGetNotificationsResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.notifications !== undefined) {
            Notifications.encode(message.notifications, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryGetNotificationsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.notifications = Notifications.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { notifications: isSet$N(object.notifications) ? Notifications.fromJSON(object.notifications) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.notifications !== undefined) {
            obj.notifications = Notifications.toJSON(message.notifications);
        }
        return obj;
    },
    create(base) {
        return QueryGetNotificationsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryGetNotificationsResponse();
        message.notifications = (object.notifications !== undefined && object.notifications !== null)
            ? Notifications.fromPartial(object.notifications)
            : undefined;
        return message;
    },
};
function createBaseQueryAllNotificationsRequest() {
    return { pagination: undefined };
}
const QueryAllNotificationsRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.pagination !== undefined) {
            PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllNotificationsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.pagination = PageRequest.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { pagination: isSet$N(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.pagination !== undefined) {
            obj.pagination = PageRequest.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryAllNotificationsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryAllNotificationsRequest();
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageRequest.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryAllNotificationsResponse() {
    return { notifications: [], pagination: undefined };
}
const QueryAllNotificationsResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.notifications) {
            Notifications.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllNotificationsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.notifications.push(Notifications.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageResponse.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            notifications: Array.isArray(object?.notifications)
                ? object.notifications.map((e) => Notifications.fromJSON(e))
                : [],
            pagination: isSet$N(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.notifications?.length) {
            obj.notifications = message.notifications.map((e) => Notifications.toJSON(e));
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageResponse.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryAllNotificationsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryAllNotificationsResponse();
        message.notifications = object.notifications?.map((e) => Notifications.fromPartial(e)) || [];
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageResponse.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryAllNotificationsByAddressRequest() {
    return { pagination: undefined, address: "" };
}
const QueryAllNotificationsByAddressRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.pagination !== undefined) {
            PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        if (message.address !== "") {
            writer.uint32(18).string(message.address);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllNotificationsByAddressRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.pagination = PageRequest.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            pagination: isSet$N(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
            address: isSet$N(object.address) ? String(object.address) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.pagination !== undefined) {
            obj.pagination = PageRequest.toJSON(message.pagination);
        }
        if (message.address !== "") {
            obj.address = message.address;
        }
        return obj;
    },
    create(base) {
        return QueryAllNotificationsByAddressRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryAllNotificationsByAddressRequest();
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageRequest.fromPartial(object.pagination)
            : undefined;
        message.address = object.address ?? "";
        return message;
    },
};
function createBaseQueryAllNotificationsByAddressResponse() {
    return { notifications: [], pagination: undefined };
}
const QueryAllNotificationsByAddressResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.notifications) {
            Notifications.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllNotificationsByAddressResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.notifications.push(Notifications.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageResponse.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            notifications: Array.isArray(object?.notifications)
                ? object.notifications.map((e) => Notifications.fromJSON(e))
                : [],
            pagination: isSet$N(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.notifications?.length) {
            obj.notifications = message.notifications.map((e) => Notifications.toJSON(e));
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageResponse.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryAllNotificationsByAddressResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryAllNotificationsByAddressResponse();
        message.notifications = object.notifications?.map((e) => Notifications.fromPartial(e)) || [];
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageResponse.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryGetNotiCounterRequest() {
    return { address: "" };
}
const QueryGetNotiCounterRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryGetNotiCounterRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { address: isSet$N(object.address) ? String(object.address) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.address !== "") {
            obj.address = message.address;
        }
        return obj;
    },
    create(base) {
        return QueryGetNotiCounterRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryGetNotiCounterRequest();
        message.address = object.address ?? "";
        return message;
    },
};
function createBaseQueryGetNotiCounterResponse() {
    return { notiCounter: undefined };
}
const QueryGetNotiCounterResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.notiCounter !== undefined) {
            NotiCounter.encode(message.notiCounter, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryGetNotiCounterResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.notiCounter = NotiCounter.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { notiCounter: isSet$N(object.notiCounter) ? NotiCounter.fromJSON(object.notiCounter) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.notiCounter !== undefined) {
            obj.notiCounter = NotiCounter.toJSON(message.notiCounter);
        }
        return obj;
    },
    create(base) {
        return QueryGetNotiCounterResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryGetNotiCounterResponse();
        message.notiCounter = (object.notiCounter !== undefined && object.notiCounter !== null)
            ? NotiCounter.fromPartial(object.notiCounter)
            : undefined;
        return message;
    },
};
function createBaseQueryAllNotiCounterRequest() {
    return { pagination: undefined };
}
const QueryAllNotiCounterRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.pagination !== undefined) {
            PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllNotiCounterRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.pagination = PageRequest.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { pagination: isSet$N(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.pagination !== undefined) {
            obj.pagination = PageRequest.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryAllNotiCounterRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryAllNotiCounterRequest();
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageRequest.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryAllNotiCounterResponse() {
    return { notiCounter: [], pagination: undefined };
}
const QueryAllNotiCounterResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.notiCounter) {
            NotiCounter.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllNotiCounterResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.notiCounter.push(NotiCounter.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageResponse.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            notiCounter: Array.isArray(object?.notiCounter)
                ? object.notiCounter.map((e) => NotiCounter.fromJSON(e))
                : [],
            pagination: isSet$N(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.notiCounter?.length) {
            obj.notiCounter = message.notiCounter.map((e) => NotiCounter.toJSON(e));
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageResponse.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryAllNotiCounterResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryAllNotiCounterResponse();
        message.notiCounter = object.notiCounter?.map((e) => NotiCounter.fromPartial(e)) || [];
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageResponse.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
let QueryClientImpl$8 = class QueryClientImpl {
    rpc;
    constructor(rpc) {
        this.rpc = rpc;
        this.Params = this.Params.bind(this);
        this.Notifications = this.Notifications.bind(this);
        this.NotificationsAll = this.NotificationsAll.bind(this);
        this.NotificationsByAddress = this.NotificationsByAddress.bind(this);
        this.NotiCounter = this.NotiCounter.bind(this);
        this.NotiCounterAll = this.NotiCounterAll.bind(this);
    }
    Params(request, metadata) {
        return this.rpc.unary(QueryParamsDesc$8, QueryParamsRequest$8.fromPartial(request), metadata);
    }
    Notifications(request, metadata) {
        return this.rpc.unary(QueryNotificationsDesc, QueryGetNotificationsRequest.fromPartial(request), metadata);
    }
    NotificationsAll(request, metadata) {
        return this.rpc.unary(QueryNotificationsAllDesc, QueryAllNotificationsRequest.fromPartial(request), metadata);
    }
    NotificationsByAddress(request, metadata) {
        return this.rpc.unary(QueryNotificationsByAddressDesc, QueryAllNotificationsByAddressRequest.fromPartial(request), metadata);
    }
    NotiCounter(request, metadata) {
        return this.rpc.unary(QueryNotiCounterDesc, QueryGetNotiCounterRequest.fromPartial(request), metadata);
    }
    NotiCounterAll(request, metadata) {
        return this.rpc.unary(QueryNotiCounterAllDesc, QueryAllNotiCounterRequest.fromPartial(request), metadata);
    }
};
const QueryDesc$8 = { serviceName: "canine_chain.notifications.Query" };
const QueryParamsDesc$8 = {
    methodName: "Params",
    service: QueryDesc$8,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryParamsRequest$8.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryParamsResponse$8.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryNotificationsDesc = {
    methodName: "Notifications",
    service: QueryDesc$8,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryGetNotificationsRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryGetNotificationsResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryNotificationsAllDesc = {
    methodName: "NotificationsAll",
    service: QueryDesc$8,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryAllNotificationsRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryAllNotificationsResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryNotificationsByAddressDesc = {
    methodName: "NotificationsByAddress",
    service: QueryDesc$8,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryAllNotificationsByAddressRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryAllNotificationsByAddressResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryNotiCounterDesc = {
    methodName: "NotiCounter",
    service: QueryDesc$8,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryGetNotiCounterRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryGetNotiCounterResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryNotiCounterAllDesc = {
    methodName: "NotiCounterAll",
    service: QueryDesc$8,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryAllNotiCounterRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryAllNotiCounterResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
let GrpcWebImpl$j = class GrpcWebImpl {
    host;
    options;
    constructor(host, options) {
        this.host = host;
        this.options = options;
    }
    unary(methodDesc, _request, metadata) {
        const request = { ..._request, ...methodDesc.requestType };
        const maybeCombinedMetadata = metadata && this.options.metadata
            ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
            : metadata ?? this.options.metadata;
        return new Promise((resolve, reject) => {
            grpc.unary(methodDesc, {
                request,
                host: this.host,
                metadata: maybeCombinedMetadata ?? {},
                ...(this.options.transport !== undefined ? { transport: this.options.transport } : {}),
                debug: this.options.debug ?? false,
                onEnd: function (response) {
                    if (response.status === grpc.Code.OK) {
                        resolve(response.message.toObject());
                    }
                    else {
                        const err = new GrpcWebError$j(response.statusMessage, response.status, response.trailers);
                        reject(err);
                    }
                },
            });
        });
    }
};
const tsProtoGlobalThis$B = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function longToNumber$n(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new tsProtoGlobalThis$B.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isSet$N(value) {
    return value !== null && value !== undefined;
}
let GrpcWebError$j = class GrpcWebError extends tsProtoGlobalThis$B.Error {
    code;
    metadata;
    constructor(message, code, metadata) {
        super(message);
        this.code = code;
        this.metadata = metadata;
    }
};

/* eslint-disable */
const protobufPackage$M = "google.protobuf";
function createBaseTimestamp() {
    return { seconds: 0, nanos: 0 };
}
const Timestamp = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.seconds !== 0) {
            writer.uint32(8).int64(message.seconds);
        }
        if (message.nanos !== 0) {
            writer.uint32(16).int32(message.nanos);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTimestamp();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.seconds = longToNumber$m(reader.int64());
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.nanos = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            seconds: isSet$M(object.seconds) ? Number(object.seconds) : 0,
            nanos: isSet$M(object.nanos) ? Number(object.nanos) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.seconds !== 0) {
            obj.seconds = Math.round(message.seconds);
        }
        if (message.nanos !== 0) {
            obj.nanos = Math.round(message.nanos);
        }
        return obj;
    },
    create(base) {
        return Timestamp.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTimestamp();
        message.seconds = object.seconds ?? 0;
        message.nanos = object.nanos ?? 0;
        return message;
    },
};
const tsProtoGlobalThis$A = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function longToNumber$m(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new tsProtoGlobalThis$A.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isSet$M(value) {
    return value !== null && value !== undefined;
}

/* eslint-disable */
const protobufPackage$L = "canine_chain.oracle";
function createBaseFeed() {
    return { owner: "", data: "", lastUpdate: undefined, name: "" };
}
const Feed = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.owner !== "") {
            writer.uint32(10).string(message.owner);
        }
        if (message.data !== "") {
            writer.uint32(18).string(message.data);
        }
        if (message.lastUpdate !== undefined) {
            Timestamp.encode(toTimestamp$7(message.lastUpdate), writer.uint32(26).fork()).ldelim();
        }
        if (message.name !== "") {
            writer.uint32(34).string(message.name);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFeed();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.owner = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.data = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.lastUpdate = fromTimestamp$7(Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            owner: isSet$L(object.owner) ? String(object.owner) : "",
            data: isSet$L(object.data) ? String(object.data) : "",
            lastUpdate: isSet$L(object.lastUpdate) ? fromJsonTimestamp$7(object.lastUpdate) : undefined,
            name: isSet$L(object.name) ? String(object.name) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.owner !== "") {
            obj.owner = message.owner;
        }
        if (message.data !== "") {
            obj.data = message.data;
        }
        if (message.lastUpdate !== undefined) {
            obj.lastUpdate = message.lastUpdate.toISOString();
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        return obj;
    },
    create(base) {
        return Feed.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFeed();
        message.owner = object.owner ?? "";
        message.data = object.data ?? "";
        message.lastUpdate = object.lastUpdate ?? undefined;
        message.name = object.name ?? "";
        return message;
    },
};
function toTimestamp$7(date) {
    const seconds = date.getTime() / 1_000;
    const nanos = (date.getTime() % 1_000) * 1_000_000;
    return { seconds, nanos };
}
function fromTimestamp$7(t) {
    let millis = (t.seconds || 0) * 1_000;
    millis += (t.nanos || 0) / 1_000_000;
    return new Date(millis);
}
function fromJsonTimestamp$7(o) {
    if (o instanceof Date) {
        return o;
    }
    else if (typeof o === "string") {
        return new Date(o);
    }
    else {
        return fromTimestamp$7(Timestamp.fromJSON(o));
    }
}
function isSet$L(value) {
    return value !== null && value !== undefined;
}

/* eslint-disable */
const protobufPackage$K = "canine_chain.oracle";
function createBaseParams$6() {
    return { deposit: "" };
}
const Params$6 = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.deposit !== "") {
            writer.uint32(10).string(message.deposit);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParams$6();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.deposit = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { deposit: isSet$K(object.deposit) ? String(object.deposit) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.deposit !== "") {
            obj.deposit = message.deposit;
        }
        return obj;
    },
    create(base) {
        return Params$6.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseParams$6();
        message.deposit = object.deposit ?? "";
        return message;
    },
};
function isSet$K(value) {
    return value !== null && value !== undefined;
}

/* eslint-disable */
const protobufPackage$J = "canine_chain.oracle";
function createBaseQueryParamsRequest$7() {
    return {};
}
const QueryParamsRequest$7 = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest$7();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return QueryParamsRequest$7.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseQueryParamsRequest$7();
        return message;
    },
};
function createBaseQueryParamsResponse$7() {
    return { params: undefined };
}
const QueryParamsResponse$7 = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.params !== undefined) {
            Params$6.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse$7();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.params = Params$6.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { params: isSet$J(object.params) ? Params$6.fromJSON(object.params) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.params !== undefined) {
            obj.params = Params$6.toJSON(message.params);
        }
        return obj;
    },
    create(base) {
        return QueryParamsResponse$7.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryParamsResponse$7();
        message.params = (object.params !== undefined && object.params !== null)
            ? Params$6.fromPartial(object.params)
            : undefined;
        return message;
    },
};
function createBaseQueryFeedRequest() {
    return { name: "" };
}
const QueryFeedRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryFeedRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { name: isSet$J(object.name) ? String(object.name) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        return obj;
    },
    create(base) {
        return QueryFeedRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryFeedRequest();
        message.name = object.name ?? "";
        return message;
    },
};
function createBaseQueryFeedResponse() {
    return { feed: undefined };
}
const QueryFeedResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.feed !== undefined) {
            Feed.encode(message.feed, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryFeedResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.feed = Feed.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { feed: isSet$J(object.feed) ? Feed.fromJSON(object.feed) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.feed !== undefined) {
            obj.feed = Feed.toJSON(message.feed);
        }
        return obj;
    },
    create(base) {
        return QueryFeedResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryFeedResponse();
        message.feed = (object.feed !== undefined && object.feed !== null) ? Feed.fromPartial(object.feed) : undefined;
        return message;
    },
};
function createBaseQueryAllFeedsRequest() {
    return {};
}
const QueryAllFeedsRequest = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllFeedsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return QueryAllFeedsRequest.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseQueryAllFeedsRequest();
        return message;
    },
};
function createBaseQueryAllFeedsResponse() {
    return { feed: [], pagination: undefined };
}
const QueryAllFeedsResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.feed) {
            Feed.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllFeedsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.feed.push(Feed.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageResponse.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            feed: Array.isArray(object?.feed) ? object.feed.map((e) => Feed.fromJSON(e)) : [],
            pagination: isSet$J(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.feed?.length) {
            obj.feed = message.feed.map((e) => Feed.toJSON(e));
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageResponse.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryAllFeedsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryAllFeedsResponse();
        message.feed = object.feed?.map((e) => Feed.fromPartial(e)) || [];
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageResponse.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
let QueryClientImpl$7 = class QueryClientImpl {
    rpc;
    constructor(rpc) {
        this.rpc = rpc;
        this.Params = this.Params.bind(this);
        this.Feed = this.Feed.bind(this);
        this.AllFeeds = this.AllFeeds.bind(this);
    }
    Params(request, metadata) {
        return this.rpc.unary(QueryParamsDesc$7, QueryParamsRequest$7.fromPartial(request), metadata);
    }
    Feed(request, metadata) {
        return this.rpc.unary(QueryFeedDesc, QueryFeedRequest.fromPartial(request), metadata);
    }
    AllFeeds(request, metadata) {
        return this.rpc.unary(QueryAllFeedsDesc, QueryAllFeedsRequest.fromPartial(request), metadata);
    }
};
const QueryDesc$7 = { serviceName: "canine_chain.oracle.Query" };
const QueryParamsDesc$7 = {
    methodName: "Params",
    service: QueryDesc$7,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryParamsRequest$7.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryParamsResponse$7.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryFeedDesc = {
    methodName: "Feed",
    service: QueryDesc$7,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryFeedRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryFeedResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryAllFeedsDesc = {
    methodName: "AllFeeds",
    service: QueryDesc$7,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryAllFeedsRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryAllFeedsResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
let GrpcWebImpl$i = class GrpcWebImpl {
    host;
    options;
    constructor(host, options) {
        this.host = host;
        this.options = options;
    }
    unary(methodDesc, _request, metadata) {
        const request = { ..._request, ...methodDesc.requestType };
        const maybeCombinedMetadata = metadata && this.options.metadata
            ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
            : metadata ?? this.options.metadata;
        return new Promise((resolve, reject) => {
            grpc.unary(methodDesc, {
                request,
                host: this.host,
                metadata: maybeCombinedMetadata ?? {},
                ...(this.options.transport !== undefined ? { transport: this.options.transport } : {}),
                debug: this.options.debug ?? false,
                onEnd: function (response) {
                    if (response.status === grpc.Code.OK) {
                        resolve(response.message.toObject());
                    }
                    else {
                        const err = new GrpcWebError$i(response.statusMessage, response.status, response.trailers);
                        reject(err);
                    }
                },
            });
        });
    }
};
const tsProtoGlobalThis$z = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function isSet$J(value) {
    return value !== null && value !== undefined;
}
let GrpcWebError$i = class GrpcWebError extends tsProtoGlobalThis$z.Error {
    code;
    metadata;
    constructor(message, code, metadata) {
        super(message);
        this.code = code;
        this.metadata = metadata;
    }
};

/* eslint-disable */
const protobufPackage$I = "canine_chain.rns";
function createBaseBids() {
    return { index: "", name: "", bidder: "", price: "" };
}
const Bids = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.index !== "") {
            writer.uint32(10).string(message.index);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        if (message.bidder !== "") {
            writer.uint32(26).string(message.bidder);
        }
        if (message.price !== "") {
            writer.uint32(34).string(message.price);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBids();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.index = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.bidder = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.price = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            index: isSet$I(object.index) ? String(object.index) : "",
            name: isSet$I(object.name) ? String(object.name) : "",
            bidder: isSet$I(object.bidder) ? String(object.bidder) : "",
            price: isSet$I(object.price) ? String(object.price) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.index !== "") {
            obj.index = message.index;
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.bidder !== "") {
            obj.bidder = message.bidder;
        }
        if (message.price !== "") {
            obj.price = message.price;
        }
        return obj;
    },
    create(base) {
        return Bids.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBids();
        message.index = object.index ?? "";
        message.name = object.name ?? "";
        message.bidder = object.bidder ?? "";
        message.price = object.price ?? "";
        return message;
    },
};
function isSet$I(value) {
    return value !== null && value !== undefined;
}

/* eslint-disable */
const protobufPackage$H = "canine_chain.rns";
function createBaseForsale() {
    return { name: "", price: "", owner: "" };
}
const Forsale = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.price !== "") {
            writer.uint32(18).string(message.price);
        }
        if (message.owner !== "") {
            writer.uint32(26).string(message.owner);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseForsale();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.price = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.owner = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet$H(object.name) ? String(object.name) : "",
            price: isSet$H(object.price) ? String(object.price) : "",
            owner: isSet$H(object.owner) ? String(object.owner) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.price !== "") {
            obj.price = message.price;
        }
        if (message.owner !== "") {
            obj.owner = message.owner;
        }
        return obj;
    },
    create(base) {
        return Forsale.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseForsale();
        message.name = object.name ?? "";
        message.price = object.price ?? "";
        message.owner = object.owner ?? "";
        return message;
    },
};
function isSet$H(value) {
    return value !== null && value !== undefined;
}

/* eslint-disable */
const protobufPackage$G = "canine_chain.rns";
function createBaseInit() {
    return { address: "", complete: false };
}
const Init = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        if (message.complete === true) {
            writer.uint32(16).bool(message.complete);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInit();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.complete = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            address: isSet$G(object.address) ? String(object.address) : "",
            complete: isSet$G(object.complete) ? Boolean(object.complete) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.address !== "") {
            obj.address = message.address;
        }
        if (message.complete === true) {
            obj.complete = message.complete;
        }
        return obj;
    },
    create(base) {
        return Init.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseInit();
        message.address = object.address ?? "";
        message.complete = object.complete ?? false;
        return message;
    },
};
function isSet$G(value) {
    return value !== null && value !== undefined;
}

/* eslint-disable */
const protobufPackage$F = "canine_chain.rns";
function createBaseNames() {
    return { name: "", expires: 0, value: "", data: "", subdomains: [], tld: "", locked: 0 };
}
const Names = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.expires !== 0) {
            writer.uint32(16).int64(message.expires);
        }
        if (message.value !== "") {
            writer.uint32(26).string(message.value);
        }
        if (message.data !== "") {
            writer.uint32(34).string(message.data);
        }
        for (const v of message.subdomains) {
            Names.encode(v, writer.uint32(42).fork()).ldelim();
        }
        if (message.tld !== "") {
            writer.uint32(50).string(message.tld);
        }
        if (message.locked !== 0) {
            writer.uint32(56).int64(message.locked);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseNames();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.expires = longToNumber$l(reader.int64());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.data = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.subdomains.push(Names.decode(reader, reader.uint32()));
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.tld = reader.string();
                    continue;
                case 7:
                    if (tag !== 56) {
                        break;
                    }
                    message.locked = longToNumber$l(reader.int64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet$F(object.name) ? String(object.name) : "",
            expires: isSet$F(object.expires) ? Number(object.expires) : 0,
            value: isSet$F(object.value) ? String(object.value) : "",
            data: isSet$F(object.data) ? String(object.data) : "",
            subdomains: Array.isArray(object?.subdomains) ? object.subdomains.map((e) => Names.fromJSON(e)) : [],
            tld: isSet$F(object.tld) ? String(object.tld) : "",
            locked: isSet$F(object.locked) ? Number(object.locked) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.expires !== 0) {
            obj.expires = Math.round(message.expires);
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        if (message.data !== "") {
            obj.data = message.data;
        }
        if (message.subdomains?.length) {
            obj.subdomains = message.subdomains.map((e) => Names.toJSON(e));
        }
        if (message.tld !== "") {
            obj.tld = message.tld;
        }
        if (message.locked !== 0) {
            obj.locked = Math.round(message.locked);
        }
        return obj;
    },
    create(base) {
        return Names.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseNames();
        message.name = object.name ?? "";
        message.expires = object.expires ?? 0;
        message.value = object.value ?? "";
        message.data = object.data ?? "";
        message.subdomains = object.subdomains?.map((e) => Names.fromPartial(e)) || [];
        message.tld = object.tld ?? "";
        message.locked = object.locked ?? 0;
        return message;
    },
};
const tsProtoGlobalThis$y = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function longToNumber$l(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new tsProtoGlobalThis$y.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isSet$F(value) {
    return value !== null && value !== undefined;
}

/* eslint-disable */
const protobufPackage$E = "canine_chain.rns";
function createBaseParams$5() {
    return { depositAccount: "" };
}
const Params$5 = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.depositAccount !== "") {
            writer.uint32(10).string(message.depositAccount);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParams$5();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.depositAccount = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { depositAccount: isSet$E(object.depositAccount) ? String(object.depositAccount) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.depositAccount !== "") {
            obj.depositAccount = message.depositAccount;
        }
        return obj;
    },
    create(base) {
        return Params$5.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseParams$5();
        message.depositAccount = object.depositAccount ?? "";
        return message;
    },
};
function isSet$E(value) {
    return value !== null && value !== undefined;
}

/* eslint-disable */
const protobufPackage$D = "canine_chain.rns";
function createBaseWhois() {
    return { index: "", name: "", value: "", data: "" };
}
const Whois = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.index !== "") {
            writer.uint32(10).string(message.index);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        if (message.value !== "") {
            writer.uint32(26).string(message.value);
        }
        if (message.data !== "") {
            writer.uint32(34).string(message.data);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWhois();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.index = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.data = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            index: isSet$D(object.index) ? String(object.index) : "",
            name: isSet$D(object.name) ? String(object.name) : "",
            value: isSet$D(object.value) ? String(object.value) : "",
            data: isSet$D(object.data) ? String(object.data) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.index !== "") {
            obj.index = message.index;
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        if (message.data !== "") {
            obj.data = message.data;
        }
        return obj;
    },
    create(base) {
        return Whois.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseWhois();
        message.index = object.index ?? "";
        message.name = object.name ?? "";
        message.value = object.value ?? "";
        message.data = object.data ?? "";
        return message;
    },
};
function isSet$D(value) {
    return value !== null && value !== undefined;
}

/* eslint-disable */
const protobufPackage$C = "canine_chain.rns";
function createBaseQueryParamsRequest$6() {
    return {};
}
const QueryParamsRequest$6 = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest$6();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return QueryParamsRequest$6.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseQueryParamsRequest$6();
        return message;
    },
};
function createBaseQueryParamsResponse$6() {
    return { params: undefined };
}
const QueryParamsResponse$6 = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.params !== undefined) {
            Params$5.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse$6();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.params = Params$5.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { params: isSet$C(object.params) ? Params$5.fromJSON(object.params) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.params !== undefined) {
            obj.params = Params$5.toJSON(message.params);
        }
        return obj;
    },
    create(base) {
        return QueryParamsResponse$6.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryParamsResponse$6();
        message.params = (object.params !== undefined && object.params !== null)
            ? Params$5.fromPartial(object.params)
            : undefined;
        return message;
    },
};
function createBaseQueryWhoisRequest() {
    return { index: "" };
}
const QueryWhoisRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.index !== "") {
            writer.uint32(10).string(message.index);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryWhoisRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.index = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { index: isSet$C(object.index) ? String(object.index) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.index !== "") {
            obj.index = message.index;
        }
        return obj;
    },
    create(base) {
        return QueryWhoisRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryWhoisRequest();
        message.index = object.index ?? "";
        return message;
    },
};
function createBaseQueryWhoisResponse() {
    return { whois: undefined };
}
const QueryWhoisResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.whois !== undefined) {
            Whois.encode(message.whois, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryWhoisResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.whois = Whois.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { whois: isSet$C(object.whois) ? Whois.fromJSON(object.whois) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.whois !== undefined) {
            obj.whois = Whois.toJSON(message.whois);
        }
        return obj;
    },
    create(base) {
        return QueryWhoisResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryWhoisResponse();
        message.whois = (object.whois !== undefined && object.whois !== null) ? Whois.fromPartial(object.whois) : undefined;
        return message;
    },
};
function createBaseQueryAllWhoisRequest() {
    return { pagination: undefined };
}
const QueryAllWhoisRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.pagination !== undefined) {
            PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllWhoisRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.pagination = PageRequest.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { pagination: isSet$C(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.pagination !== undefined) {
            obj.pagination = PageRequest.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryAllWhoisRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryAllWhoisRequest();
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageRequest.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryAllWhoisResponse() {
    return { whois: [], pagination: undefined };
}
const QueryAllWhoisResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.whois) {
            Whois.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllWhoisResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.whois.push(Whois.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageResponse.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            whois: Array.isArray(object?.whois) ? object.whois.map((e) => Whois.fromJSON(e)) : [],
            pagination: isSet$C(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.whois?.length) {
            obj.whois = message.whois.map((e) => Whois.toJSON(e));
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageResponse.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryAllWhoisResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryAllWhoisResponse();
        message.whois = object.whois?.map((e) => Whois.fromPartial(e)) || [];
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageResponse.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryNameRequest() {
    return { index: "" };
}
const QueryNameRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.index !== "") {
            writer.uint32(10).string(message.index);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryNameRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.index = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { index: isSet$C(object.index) ? String(object.index) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.index !== "") {
            obj.index = message.index;
        }
        return obj;
    },
    create(base) {
        return QueryNameRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryNameRequest();
        message.index = object.index ?? "";
        return message;
    },
};
function createBaseQueryNameResponse() {
    return { names: undefined };
}
const QueryNameResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.names !== undefined) {
            Names.encode(message.names, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryNameResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.names = Names.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { names: isSet$C(object.names) ? Names.fromJSON(object.names) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.names !== undefined) {
            obj.names = Names.toJSON(message.names);
        }
        return obj;
    },
    create(base) {
        return QueryNameResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryNameResponse();
        message.names = (object.names !== undefined && object.names !== null) ? Names.fromPartial(object.names) : undefined;
        return message;
    },
};
function createBaseQueryAllNamesRequest() {
    return { pagination: undefined };
}
const QueryAllNamesRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.pagination !== undefined) {
            PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllNamesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.pagination = PageRequest.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { pagination: isSet$C(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.pagination !== undefined) {
            obj.pagination = PageRequest.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryAllNamesRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryAllNamesRequest();
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageRequest.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryAllNamesResponse() {
    return { names: [], pagination: undefined };
}
const QueryAllNamesResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.names) {
            Names.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllNamesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.names.push(Names.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageResponse.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            names: Array.isArray(object?.names) ? object.names.map((e) => Names.fromJSON(e)) : [],
            pagination: isSet$C(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.names?.length) {
            obj.names = message.names.map((e) => Names.toJSON(e));
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageResponse.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryAllNamesResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryAllNamesResponse();
        message.names = object.names?.map((e) => Names.fromPartial(e)) || [];
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageResponse.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryBidRequest() {
    return { index: "" };
}
const QueryBidRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.index !== "") {
            writer.uint32(10).string(message.index);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryBidRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.index = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { index: isSet$C(object.index) ? String(object.index) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.index !== "") {
            obj.index = message.index;
        }
        return obj;
    },
    create(base) {
        return QueryBidRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryBidRequest();
        message.index = object.index ?? "";
        return message;
    },
};
function createBaseQueryBidResponse() {
    return { bids: undefined };
}
const QueryBidResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.bids !== undefined) {
            Bids.encode(message.bids, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryBidResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.bids = Bids.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { bids: isSet$C(object.bids) ? Bids.fromJSON(object.bids) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.bids !== undefined) {
            obj.bids = Bids.toJSON(message.bids);
        }
        return obj;
    },
    create(base) {
        return QueryBidResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryBidResponse();
        message.bids = (object.bids !== undefined && object.bids !== null) ? Bids.fromPartial(object.bids) : undefined;
        return message;
    },
};
function createBaseQueryAllBidsRequest() {
    return { pagination: undefined };
}
const QueryAllBidsRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.pagination !== undefined) {
            PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllBidsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.pagination = PageRequest.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { pagination: isSet$C(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.pagination !== undefined) {
            obj.pagination = PageRequest.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryAllBidsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryAllBidsRequest();
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageRequest.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryAllBidsResponse() {
    return { bids: [], pagination: undefined };
}
const QueryAllBidsResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.bids) {
            Bids.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllBidsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.bids.push(Bids.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageResponse.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            bids: Array.isArray(object?.bids) ? object.bids.map((e) => Bids.fromJSON(e)) : [],
            pagination: isSet$C(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.bids?.length) {
            obj.bids = message.bids.map((e) => Bids.toJSON(e));
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageResponse.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryAllBidsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryAllBidsResponse();
        message.bids = object.bids?.map((e) => Bids.fromPartial(e)) || [];
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageResponse.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryForsaleRequest() {
    return { name: "" };
}
const QueryForsaleRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryForsaleRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { name: isSet$C(object.name) ? String(object.name) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        return obj;
    },
    create(base) {
        return QueryForsaleRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryForsaleRequest();
        message.name = object.name ?? "";
        return message;
    },
};
function createBaseQueryForsaleResponse() {
    return { forsale: undefined };
}
const QueryForsaleResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.forsale !== undefined) {
            Forsale.encode(message.forsale, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryForsaleResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.forsale = Forsale.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { forsale: isSet$C(object.forsale) ? Forsale.fromJSON(object.forsale) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.forsale !== undefined) {
            obj.forsale = Forsale.toJSON(message.forsale);
        }
        return obj;
    },
    create(base) {
        return QueryForsaleResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryForsaleResponse();
        message.forsale = (object.forsale !== undefined && object.forsale !== null)
            ? Forsale.fromPartial(object.forsale)
            : undefined;
        return message;
    },
};
function createBaseQueryAllForsalesRequest() {
    return { pagination: undefined };
}
const QueryAllForsalesRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.pagination !== undefined) {
            PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllForsalesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.pagination = PageRequest.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { pagination: isSet$C(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.pagination !== undefined) {
            obj.pagination = PageRequest.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryAllForsalesRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryAllForsalesRequest();
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageRequest.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryAllForsalesResponse() {
    return { forsale: [], pagination: undefined };
}
const QueryAllForsalesResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.forsale) {
            Forsale.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllForsalesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.forsale.push(Forsale.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageResponse.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            forsale: Array.isArray(object?.forsale) ? object.forsale.map((e) => Forsale.fromJSON(e)) : [],
            pagination: isSet$C(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.forsale?.length) {
            obj.forsale = message.forsale.map((e) => Forsale.toJSON(e));
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageResponse.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryAllForsalesResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryAllForsalesResponse();
        message.forsale = object.forsale?.map((e) => Forsale.fromPartial(e)) || [];
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageResponse.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryInitRequest() {
    return { address: "" };
}
const QueryInitRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryInitRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { address: isSet$C(object.address) ? String(object.address) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.address !== "") {
            obj.address = message.address;
        }
        return obj;
    },
    create(base) {
        return QueryInitRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryInitRequest();
        message.address = object.address ?? "";
        return message;
    },
};
function createBaseQueryInitResponse() {
    return { init: false };
}
const QueryInitResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.init === true) {
            writer.uint32(8).bool(message.init);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryInitResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.init = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { init: isSet$C(object.init) ? Boolean(object.init) : false };
    },
    toJSON(message) {
        const obj = {};
        if (message.init === true) {
            obj.init = message.init;
        }
        return obj;
    },
    create(base) {
        return QueryInitResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryInitResponse();
        message.init = object.init ?? false;
        return message;
    },
};
function createBaseQueryAllInitsRequest() {
    return { pagination: undefined };
}
const QueryAllInitsRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.pagination !== undefined) {
            PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllInitsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.pagination = PageRequest.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { pagination: isSet$C(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.pagination !== undefined) {
            obj.pagination = PageRequest.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryAllInitsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryAllInitsRequest();
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageRequest.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryAllInitsResponse() {
    return { init: [], pagination: undefined };
}
const QueryAllInitsResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.init) {
            Init.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllInitsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.init.push(Init.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageResponse.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            init: Array.isArray(object?.init) ? object.init.map((e) => Init.fromJSON(e)) : [],
            pagination: isSet$C(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.init?.length) {
            obj.init = message.init.map((e) => Init.toJSON(e));
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageResponse.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryAllInitsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryAllInitsResponse();
        message.init = object.init?.map((e) => Init.fromPartial(e)) || [];
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageResponse.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryListOwnedNamesRequest() {
    return { address: "", pagination: undefined };
}
const QueryListOwnedNamesRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        if (message.pagination !== undefined) {
            PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryListOwnedNamesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageRequest.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            address: isSet$C(object.address) ? String(object.address) : "",
            pagination: isSet$C(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.address !== "") {
            obj.address = message.address;
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageRequest.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryListOwnedNamesRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryListOwnedNamesRequest();
        message.address = object.address ?? "";
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageRequest.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryListOwnedNamesResponse() {
    return { names: [], pagination: undefined };
}
const QueryListOwnedNamesResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.names) {
            Names.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryListOwnedNamesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.names.push(Names.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageResponse.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            names: Array.isArray(object?.names) ? object.names.map((e) => Names.fromJSON(e)) : [],
            pagination: isSet$C(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.names?.length) {
            obj.names = message.names.map((e) => Names.toJSON(e));
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageResponse.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryListOwnedNamesResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryListOwnedNamesResponse();
        message.names = object.names?.map((e) => Names.fromPartial(e)) || [];
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageResponse.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
let QueryClientImpl$6 = class QueryClientImpl {
    rpc;
    constructor(rpc) {
        this.rpc = rpc;
        this.Params = this.Params.bind(this);
        this.Names = this.Names.bind(this);
        this.NamesAll = this.NamesAll.bind(this);
        this.Bids = this.Bids.bind(this);
        this.BidsAll = this.BidsAll.bind(this);
        this.Forsale = this.Forsale.bind(this);
        this.ForsaleAll = this.ForsaleAll.bind(this);
        this.Init = this.Init.bind(this);
        this.InitAll = this.InitAll.bind(this);
        this.ListOwnedNames = this.ListOwnedNames.bind(this);
    }
    Params(request, metadata) {
        return this.rpc.unary(QueryParamsDesc$6, QueryParamsRequest$6.fromPartial(request), metadata);
    }
    Names(request, metadata) {
        return this.rpc.unary(QueryNamesDesc, QueryNameRequest.fromPartial(request), metadata);
    }
    NamesAll(request, metadata) {
        return this.rpc.unary(QueryNamesAllDesc, QueryAllNamesRequest.fromPartial(request), metadata);
    }
    Bids(request, metadata) {
        return this.rpc.unary(QueryBidsDesc, QueryBidRequest.fromPartial(request), metadata);
    }
    BidsAll(request, metadata) {
        return this.rpc.unary(QueryBidsAllDesc, QueryAllBidsRequest.fromPartial(request), metadata);
    }
    Forsale(request, metadata) {
        return this.rpc.unary(QueryForsaleDesc, QueryForsaleRequest.fromPartial(request), metadata);
    }
    ForsaleAll(request, metadata) {
        return this.rpc.unary(QueryForsaleAllDesc, QueryAllForsalesRequest.fromPartial(request), metadata);
    }
    Init(request, metadata) {
        return this.rpc.unary(QueryInitDesc, QueryInitRequest.fromPartial(request), metadata);
    }
    InitAll(request, metadata) {
        return this.rpc.unary(QueryInitAllDesc, QueryAllInitsRequest.fromPartial(request), metadata);
    }
    ListOwnedNames(request, metadata) {
        return this.rpc.unary(QueryListOwnedNamesDesc, QueryListOwnedNamesRequest.fromPartial(request), metadata);
    }
};
const QueryDesc$6 = { serviceName: "canine_chain.rns.Query" };
const QueryParamsDesc$6 = {
    methodName: "Params",
    service: QueryDesc$6,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryParamsRequest$6.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryParamsResponse$6.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryNamesDesc = {
    methodName: "Names",
    service: QueryDesc$6,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryNameRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryNameResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryNamesAllDesc = {
    methodName: "NamesAll",
    service: QueryDesc$6,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryAllNamesRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryAllNamesResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryBidsDesc = {
    methodName: "Bids",
    service: QueryDesc$6,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryBidRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryBidResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryBidsAllDesc = {
    methodName: "BidsAll",
    service: QueryDesc$6,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryAllBidsRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryAllBidsResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryForsaleDesc = {
    methodName: "Forsale",
    service: QueryDesc$6,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryForsaleRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryForsaleResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryForsaleAllDesc = {
    methodName: "ForsaleAll",
    service: QueryDesc$6,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryAllForsalesRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryAllForsalesResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryInitDesc = {
    methodName: "Init",
    service: QueryDesc$6,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryInitRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryInitResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryInitAllDesc = {
    methodName: "InitAll",
    service: QueryDesc$6,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryAllInitsRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryAllInitsResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryListOwnedNamesDesc = {
    methodName: "ListOwnedNames",
    service: QueryDesc$6,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryListOwnedNamesRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryListOwnedNamesResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
let GrpcWebImpl$h = class GrpcWebImpl {
    host;
    options;
    constructor(host, options) {
        this.host = host;
        this.options = options;
    }
    unary(methodDesc, _request, metadata) {
        const request = { ..._request, ...methodDesc.requestType };
        const maybeCombinedMetadata = metadata && this.options.metadata
            ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
            : metadata ?? this.options.metadata;
        return new Promise((resolve, reject) => {
            grpc.unary(methodDesc, {
                request,
                host: this.host,
                metadata: maybeCombinedMetadata ?? {},
                ...(this.options.transport !== undefined ? { transport: this.options.transport } : {}),
                debug: this.options.debug ?? false,
                onEnd: function (response) {
                    if (response.status === grpc.Code.OK) {
                        resolve(response.message.toObject());
                    }
                    else {
                        const err = new GrpcWebError$h(response.statusMessage, response.status, response.trailers);
                        reject(err);
                    }
                },
            });
        });
    }
};
const tsProtoGlobalThis$x = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function isSet$C(value) {
    return value !== null && value !== undefined;
}
let GrpcWebError$h = class GrpcWebError extends tsProtoGlobalThis$x.Error {
    code;
    metadata;
    constructor(message, code, metadata) {
        super(message);
        this.code = code;
        this.metadata = metadata;
    }
};

/* eslint-disable */
const protobufPackage$B = "canine_chain.storage";
function createBaseActiveDeals() {
    return {
        cid: "",
        signee: "",
        provider: "",
        startblock: "",
        endblock: "",
        filesize: "",
        proofverified: "",
        proofsmissed: "",
        blocktoprove: "",
        creator: "",
        merkle: "",
        fid: "",
    };
}
const ActiveDeals = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.cid !== "") {
            writer.uint32(10).string(message.cid);
        }
        if (message.signee !== "") {
            writer.uint32(18).string(message.signee);
        }
        if (message.provider !== "") {
            writer.uint32(26).string(message.provider);
        }
        if (message.startblock !== "") {
            writer.uint32(34).string(message.startblock);
        }
        if (message.endblock !== "") {
            writer.uint32(42).string(message.endblock);
        }
        if (message.filesize !== "") {
            writer.uint32(50).string(message.filesize);
        }
        if (message.proofverified !== "") {
            writer.uint32(58).string(message.proofverified);
        }
        if (message.proofsmissed !== "") {
            writer.uint32(66).string(message.proofsmissed);
        }
        if (message.blocktoprove !== "") {
            writer.uint32(74).string(message.blocktoprove);
        }
        if (message.creator !== "") {
            writer.uint32(82).string(message.creator);
        }
        if (message.merkle !== "") {
            writer.uint32(90).string(message.merkle);
        }
        if (message.fid !== "") {
            writer.uint32(98).string(message.fid);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseActiveDeals();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.cid = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.signee = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.provider = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.startblock = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.endblock = reader.string();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.filesize = reader.string();
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.proofverified = reader.string();
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.proofsmissed = reader.string();
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.blocktoprove = reader.string();
                    continue;
                case 10:
                    if (tag !== 82) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 11:
                    if (tag !== 90) {
                        break;
                    }
                    message.merkle = reader.string();
                    continue;
                case 12:
                    if (tag !== 98) {
                        break;
                    }
                    message.fid = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            cid: isSet$B(object.cid) ? String(object.cid) : "",
            signee: isSet$B(object.signee) ? String(object.signee) : "",
            provider: isSet$B(object.provider) ? String(object.provider) : "",
            startblock: isSet$B(object.startblock) ? String(object.startblock) : "",
            endblock: isSet$B(object.endblock) ? String(object.endblock) : "",
            filesize: isSet$B(object.filesize) ? String(object.filesize) : "",
            proofverified: isSet$B(object.proofverified) ? String(object.proofverified) : "",
            proofsmissed: isSet$B(object.proofsmissed) ? String(object.proofsmissed) : "",
            blocktoprove: isSet$B(object.blocktoprove) ? String(object.blocktoprove) : "",
            creator: isSet$B(object.creator) ? String(object.creator) : "",
            merkle: isSet$B(object.merkle) ? String(object.merkle) : "",
            fid: isSet$B(object.fid) ? String(object.fid) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.cid !== "") {
            obj.cid = message.cid;
        }
        if (message.signee !== "") {
            obj.signee = message.signee;
        }
        if (message.provider !== "") {
            obj.provider = message.provider;
        }
        if (message.startblock !== "") {
            obj.startblock = message.startblock;
        }
        if (message.endblock !== "") {
            obj.endblock = message.endblock;
        }
        if (message.filesize !== "") {
            obj.filesize = message.filesize;
        }
        if (message.proofverified !== "") {
            obj.proofverified = message.proofverified;
        }
        if (message.proofsmissed !== "") {
            obj.proofsmissed = message.proofsmissed;
        }
        if (message.blocktoprove !== "") {
            obj.blocktoprove = message.blocktoprove;
        }
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.merkle !== "") {
            obj.merkle = message.merkle;
        }
        if (message.fid !== "") {
            obj.fid = message.fid;
        }
        return obj;
    },
    create(base) {
        return ActiveDeals.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseActiveDeals();
        message.cid = object.cid ?? "";
        message.signee = object.signee ?? "";
        message.provider = object.provider ?? "";
        message.startblock = object.startblock ?? "";
        message.endblock = object.endblock ?? "";
        message.filesize = object.filesize ?? "";
        message.proofverified = object.proofverified ?? "";
        message.proofsmissed = object.proofsmissed ?? "";
        message.blocktoprove = object.blocktoprove ?? "";
        message.creator = object.creator ?? "";
        message.merkle = object.merkle ?? "";
        message.fid = object.fid ?? "";
        return message;
    },
};
function isSet$B(value) {
    return value !== null && value !== undefined;
}

/* eslint-disable */
const protobufPackage$A = "canine_chain.storage";
function createBaseContracts() {
    return {
        cid: "",
        priceamt: "",
        pricedenom: "",
        creator: "",
        merkle: "",
        signee: "",
        duration: "",
        filesize: "",
        fid: "",
        age: 0,
    };
}
const Contracts = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.cid !== "") {
            writer.uint32(10).string(message.cid);
        }
        if (message.priceamt !== "") {
            writer.uint32(18).string(message.priceamt);
        }
        if (message.pricedenom !== "") {
            writer.uint32(26).string(message.pricedenom);
        }
        if (message.creator !== "") {
            writer.uint32(34).string(message.creator);
        }
        if (message.merkle !== "") {
            writer.uint32(42).string(message.merkle);
        }
        if (message.signee !== "") {
            writer.uint32(50).string(message.signee);
        }
        if (message.duration !== "") {
            writer.uint32(58).string(message.duration);
        }
        if (message.filesize !== "") {
            writer.uint32(66).string(message.filesize);
        }
        if (message.fid !== "") {
            writer.uint32(74).string(message.fid);
        }
        if (message.age !== 0) {
            writer.uint32(80).int64(message.age);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseContracts();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.cid = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.priceamt = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.pricedenom = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.merkle = reader.string();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.signee = reader.string();
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.duration = reader.string();
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.filesize = reader.string();
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.fid = reader.string();
                    continue;
                case 10:
                    if (tag !== 80) {
                        break;
                    }
                    message.age = longToNumber$k(reader.int64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            cid: isSet$A(object.cid) ? String(object.cid) : "",
            priceamt: isSet$A(object.priceamt) ? String(object.priceamt) : "",
            pricedenom: isSet$A(object.pricedenom) ? String(object.pricedenom) : "",
            creator: isSet$A(object.creator) ? String(object.creator) : "",
            merkle: isSet$A(object.merkle) ? String(object.merkle) : "",
            signee: isSet$A(object.signee) ? String(object.signee) : "",
            duration: isSet$A(object.duration) ? String(object.duration) : "",
            filesize: isSet$A(object.filesize) ? String(object.filesize) : "",
            fid: isSet$A(object.fid) ? String(object.fid) : "",
            age: isSet$A(object.age) ? Number(object.age) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.cid !== "") {
            obj.cid = message.cid;
        }
        if (message.priceamt !== "") {
            obj.priceamt = message.priceamt;
        }
        if (message.pricedenom !== "") {
            obj.pricedenom = message.pricedenom;
        }
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.merkle !== "") {
            obj.merkle = message.merkle;
        }
        if (message.signee !== "") {
            obj.signee = message.signee;
        }
        if (message.duration !== "") {
            obj.duration = message.duration;
        }
        if (message.filesize !== "") {
            obj.filesize = message.filesize;
        }
        if (message.fid !== "") {
            obj.fid = message.fid;
        }
        if (message.age !== 0) {
            obj.age = Math.round(message.age);
        }
        return obj;
    },
    create(base) {
        return Contracts.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseContracts();
        message.cid = object.cid ?? "";
        message.priceamt = object.priceamt ?? "";
        message.pricedenom = object.pricedenom ?? "";
        message.creator = object.creator ?? "";
        message.merkle = object.merkle ?? "";
        message.signee = object.signee ?? "";
        message.duration = object.duration ?? "";
        message.filesize = object.filesize ?? "";
        message.fid = object.fid ?? "";
        message.age = object.age ?? 0;
        return message;
    },
};
const tsProtoGlobalThis$w = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function longToNumber$k(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new tsProtoGlobalThis$w.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isSet$A(value) {
    return value !== null && value !== undefined;
}

/* eslint-disable */
const protobufPackage$z = "canine_chain.storage";
function createBaseFidCid() {
    return { fid: "", cids: "" };
}
const FidCid = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.fid !== "") {
            writer.uint32(10).string(message.fid);
        }
        if (message.cids !== "") {
            writer.uint32(18).string(message.cids);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFidCid();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.fid = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.cids = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { fid: isSet$z(object.fid) ? String(object.fid) : "", cids: isSet$z(object.cids) ? String(object.cids) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.fid !== "") {
            obj.fid = message.fid;
        }
        if (message.cids !== "") {
            obj.cids = message.cids;
        }
        return obj;
    },
    create(base) {
        return FidCid.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFidCid();
        message.fid = object.fid ?? "";
        message.cids = object.cids ?? "";
        return message;
    },
};
function isSet$z(value) {
    return value !== null && value !== undefined;
}

/* eslint-disable */
const protobufPackage$y = "canine_chain.storage";
function createBaseParams$4() {
    return {
        depositAccount: "",
        proofWindow: 0,
        chunkSize: 0,
        missesToBurn: 0,
        priceFeed: "",
        maxContractAgeInBlocks: 0,
        pricePerTbPerMonth: 0,
    };
}
const Params$4 = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.depositAccount !== "") {
            writer.uint32(10).string(message.depositAccount);
        }
        if (message.proofWindow !== 0) {
            writer.uint32(16).int64(message.proofWindow);
        }
        if (message.chunkSize !== 0) {
            writer.uint32(24).int64(message.chunkSize);
        }
        if (message.missesToBurn !== 0) {
            writer.uint32(32).int64(message.missesToBurn);
        }
        if (message.priceFeed !== "") {
            writer.uint32(42).string(message.priceFeed);
        }
        if (message.maxContractAgeInBlocks !== 0) {
            writer.uint32(48).int64(message.maxContractAgeInBlocks);
        }
        if (message.pricePerTbPerMonth !== 0) {
            writer.uint32(56).int64(message.pricePerTbPerMonth);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParams$4();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.depositAccount = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.proofWindow = longToNumber$j(reader.int64());
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.chunkSize = longToNumber$j(reader.int64());
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.missesToBurn = longToNumber$j(reader.int64());
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.priceFeed = reader.string();
                    continue;
                case 6:
                    if (tag !== 48) {
                        break;
                    }
                    message.maxContractAgeInBlocks = longToNumber$j(reader.int64());
                    continue;
                case 7:
                    if (tag !== 56) {
                        break;
                    }
                    message.pricePerTbPerMonth = longToNumber$j(reader.int64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            depositAccount: isSet$y(object.depositAccount) ? String(object.depositAccount) : "",
            proofWindow: isSet$y(object.proofWindow) ? Number(object.proofWindow) : 0,
            chunkSize: isSet$y(object.chunkSize) ? Number(object.chunkSize) : 0,
            missesToBurn: isSet$y(object.missesToBurn) ? Number(object.missesToBurn) : 0,
            priceFeed: isSet$y(object.priceFeed) ? String(object.priceFeed) : "",
            maxContractAgeInBlocks: isSet$y(object.maxContractAgeInBlocks) ? Number(object.maxContractAgeInBlocks) : 0,
            pricePerTbPerMonth: isSet$y(object.pricePerTbPerMonth) ? Number(object.pricePerTbPerMonth) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.depositAccount !== "") {
            obj.depositAccount = message.depositAccount;
        }
        if (message.proofWindow !== 0) {
            obj.proofWindow = Math.round(message.proofWindow);
        }
        if (message.chunkSize !== 0) {
            obj.chunkSize = Math.round(message.chunkSize);
        }
        if (message.missesToBurn !== 0) {
            obj.missesToBurn = Math.round(message.missesToBurn);
        }
        if (message.priceFeed !== "") {
            obj.priceFeed = message.priceFeed;
        }
        if (message.maxContractAgeInBlocks !== 0) {
            obj.maxContractAgeInBlocks = Math.round(message.maxContractAgeInBlocks);
        }
        if (message.pricePerTbPerMonth !== 0) {
            obj.pricePerTbPerMonth = Math.round(message.pricePerTbPerMonth);
        }
        return obj;
    },
    create(base) {
        return Params$4.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseParams$4();
        message.depositAccount = object.depositAccount ?? "";
        message.proofWindow = object.proofWindow ?? 0;
        message.chunkSize = object.chunkSize ?? 0;
        message.missesToBurn = object.missesToBurn ?? 0;
        message.priceFeed = object.priceFeed ?? "";
        message.maxContractAgeInBlocks = object.maxContractAgeInBlocks ?? 0;
        message.pricePerTbPerMonth = object.pricePerTbPerMonth ?? 0;
        return message;
    },
};
const tsProtoGlobalThis$v = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function longToNumber$j(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new tsProtoGlobalThis$v.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isSet$y(value) {
    return value !== null && value !== undefined;
}

/* eslint-disable */
const protobufPackage$x = "canine_chain.storage";
function createBaseStoragePaymentInfo() {
    return { start: undefined, end: undefined, spaceAvailable: 0, spaceUsed: 0, address: "" };
}
const StoragePaymentInfo = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.start !== undefined) {
            Timestamp.encode(toTimestamp$6(message.start), writer.uint32(10).fork()).ldelim();
        }
        if (message.end !== undefined) {
            Timestamp.encode(toTimestamp$6(message.end), writer.uint32(18).fork()).ldelim();
        }
        if (message.spaceAvailable !== 0) {
            writer.uint32(24).int64(message.spaceAvailable);
        }
        if (message.spaceUsed !== 0) {
            writer.uint32(32).int64(message.spaceUsed);
        }
        if (message.address !== "") {
            writer.uint32(42).string(message.address);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStoragePaymentInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.start = fromTimestamp$6(Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.end = fromTimestamp$6(Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.spaceAvailable = longToNumber$i(reader.int64());
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.spaceUsed = longToNumber$i(reader.int64());
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            start: isSet$x(object.start) ? fromJsonTimestamp$6(object.start) : undefined,
            end: isSet$x(object.end) ? fromJsonTimestamp$6(object.end) : undefined,
            spaceAvailable: isSet$x(object.spaceAvailable) ? Number(object.spaceAvailable) : 0,
            spaceUsed: isSet$x(object.spaceUsed) ? Number(object.spaceUsed) : 0,
            address: isSet$x(object.address) ? String(object.address) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.start !== undefined) {
            obj.start = message.start.toISOString();
        }
        if (message.end !== undefined) {
            obj.end = message.end.toISOString();
        }
        if (message.spaceAvailable !== 0) {
            obj.spaceAvailable = Math.round(message.spaceAvailable);
        }
        if (message.spaceUsed !== 0) {
            obj.spaceUsed = Math.round(message.spaceUsed);
        }
        if (message.address !== "") {
            obj.address = message.address;
        }
        return obj;
    },
    create(base) {
        return StoragePaymentInfo.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseStoragePaymentInfo();
        message.start = object.start ?? undefined;
        message.end = object.end ?? undefined;
        message.spaceAvailable = object.spaceAvailable ?? 0;
        message.spaceUsed = object.spaceUsed ?? 0;
        message.address = object.address ?? "";
        return message;
    },
};
const tsProtoGlobalThis$u = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function toTimestamp$6(date) {
    const seconds = date.getTime() / 1_000;
    const nanos = (date.getTime() % 1_000) * 1_000_000;
    return { seconds, nanos };
}
function fromTimestamp$6(t) {
    let millis = (t.seconds || 0) * 1_000;
    millis += (t.nanos || 0) / 1_000_000;
    return new Date(millis);
}
function fromJsonTimestamp$6(o) {
    if (o instanceof Date) {
        return o;
    }
    else if (typeof o === "string") {
        return new Date(o);
    }
    else {
        return fromTimestamp$6(Timestamp.fromJSON(o));
    }
}
function longToNumber$i(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new tsProtoGlobalThis$u.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isSet$x(value) {
    return value !== null && value !== undefined;
}

/* eslint-disable */
const protobufPackage$w = "canine_chain.storage";
function createBaseProviders() {
    return {
        address: "",
        ip: "",
        totalspace: "",
        burnedContracts: "",
        creator: "",
        keybaseIdentity: "",
        authClaimers: [],
    };
}
const Providers = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        if (message.ip !== "") {
            writer.uint32(18).string(message.ip);
        }
        if (message.totalspace !== "") {
            writer.uint32(26).string(message.totalspace);
        }
        if (message.burnedContracts !== "") {
            writer.uint32(34).string(message.burnedContracts);
        }
        if (message.creator !== "") {
            writer.uint32(42).string(message.creator);
        }
        if (message.keybaseIdentity !== "") {
            writer.uint32(50).string(message.keybaseIdentity);
        }
        for (const v of message.authClaimers) {
            writer.uint32(58).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProviders();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.ip = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.totalspace = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.burnedContracts = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.keybaseIdentity = reader.string();
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.authClaimers.push(reader.string());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            address: isSet$w(object.address) ? String(object.address) : "",
            ip: isSet$w(object.ip) ? String(object.ip) : "",
            totalspace: isSet$w(object.totalspace) ? String(object.totalspace) : "",
            burnedContracts: isSet$w(object.burnedContracts) ? String(object.burnedContracts) : "",
            creator: isSet$w(object.creator) ? String(object.creator) : "",
            keybaseIdentity: isSet$w(object.keybaseIdentity) ? String(object.keybaseIdentity) : "",
            authClaimers: Array.isArray(object?.authClaimers) ? object.authClaimers.map((e) => String(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.address !== "") {
            obj.address = message.address;
        }
        if (message.ip !== "") {
            obj.ip = message.ip;
        }
        if (message.totalspace !== "") {
            obj.totalspace = message.totalspace;
        }
        if (message.burnedContracts !== "") {
            obj.burnedContracts = message.burnedContracts;
        }
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.keybaseIdentity !== "") {
            obj.keybaseIdentity = message.keybaseIdentity;
        }
        if (message.authClaimers?.length) {
            obj.authClaimers = message.authClaimers;
        }
        return obj;
    },
    create(base) {
        return Providers.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseProviders();
        message.address = object.address ?? "";
        message.ip = object.ip ?? "";
        message.totalspace = object.totalspace ?? "";
        message.burnedContracts = object.burnedContracts ?? "";
        message.creator = object.creator ?? "";
        message.keybaseIdentity = object.keybaseIdentity ?? "";
        message.authClaimers = object.authClaimers?.map((e) => e) || [];
        return message;
    },
};
function isSet$w(value) {
    return value !== null && value !== undefined;
}

/* eslint-disable */
const protobufPackage$v = "canine_chain.storage";
function createBaseStrays() {
    return { cid: "", fid: "", signee: "", filesize: "", merkle: "", end: 0 };
}
const Strays = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.cid !== "") {
            writer.uint32(10).string(message.cid);
        }
        if (message.fid !== "") {
            writer.uint32(18).string(message.fid);
        }
        if (message.signee !== "") {
            writer.uint32(26).string(message.signee);
        }
        if (message.filesize !== "") {
            writer.uint32(34).string(message.filesize);
        }
        if (message.merkle !== "") {
            writer.uint32(42).string(message.merkle);
        }
        if (message.end !== 0) {
            writer.uint32(48).int64(message.end);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStrays();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.cid = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.fid = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.signee = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.filesize = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.merkle = reader.string();
                    continue;
                case 6:
                    if (tag !== 48) {
                        break;
                    }
                    message.end = longToNumber$h(reader.int64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            cid: isSet$v(object.cid) ? String(object.cid) : "",
            fid: isSet$v(object.fid) ? String(object.fid) : "",
            signee: isSet$v(object.signee) ? String(object.signee) : "",
            filesize: isSet$v(object.filesize) ? String(object.filesize) : "",
            merkle: isSet$v(object.merkle) ? String(object.merkle) : "",
            end: isSet$v(object.end) ? Number(object.end) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.cid !== "") {
            obj.cid = message.cid;
        }
        if (message.fid !== "") {
            obj.fid = message.fid;
        }
        if (message.signee !== "") {
            obj.signee = message.signee;
        }
        if (message.filesize !== "") {
            obj.filesize = message.filesize;
        }
        if (message.merkle !== "") {
            obj.merkle = message.merkle;
        }
        if (message.end !== 0) {
            obj.end = Math.round(message.end);
        }
        return obj;
    },
    create(base) {
        return Strays.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseStrays();
        message.cid = object.cid ?? "";
        message.fid = object.fid ?? "";
        message.signee = object.signee ?? "";
        message.filesize = object.filesize ?? "";
        message.merkle = object.merkle ?? "";
        message.end = object.end ?? 0;
        return message;
    },
};
const tsProtoGlobalThis$t = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function longToNumber$h(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new tsProtoGlobalThis$t.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isSet$v(value) {
    return value !== null && value !== undefined;
}

/* eslint-disable */
const protobufPackage$u = "canine_chain.storage";
function createBaseQueryParamsRequest$5() {
    return {};
}
const QueryParamsRequest$5 = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest$5();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return QueryParamsRequest$5.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseQueryParamsRequest$5();
        return message;
    },
};
function createBaseQueryParamsResponse$5() {
    return { params: undefined };
}
const QueryParamsResponse$5 = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.params !== undefined) {
            Params$4.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse$5();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.params = Params$4.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { params: isSet$u(object.params) ? Params$4.fromJSON(object.params) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.params !== undefined) {
            obj.params = Params$4.toJSON(message.params);
        }
        return obj;
    },
    create(base) {
        return QueryParamsResponse$5.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryParamsResponse$5();
        message.params = (object.params !== undefined && object.params !== null)
            ? Params$4.fromPartial(object.params)
            : undefined;
        return message;
    },
};
function createBaseQueryContractRequest() {
    return { cid: "" };
}
const QueryContractRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.cid !== "") {
            writer.uint32(10).string(message.cid);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryContractRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.cid = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { cid: isSet$u(object.cid) ? String(object.cid) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.cid !== "") {
            obj.cid = message.cid;
        }
        return obj;
    },
    create(base) {
        return QueryContractRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryContractRequest();
        message.cid = object.cid ?? "";
        return message;
    },
};
function createBaseQueryContractResponse() {
    return { contracts: undefined };
}
const QueryContractResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.contracts !== undefined) {
            Contracts.encode(message.contracts, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryContractResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.contracts = Contracts.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { contracts: isSet$u(object.contracts) ? Contracts.fromJSON(object.contracts) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.contracts !== undefined) {
            obj.contracts = Contracts.toJSON(message.contracts);
        }
        return obj;
    },
    create(base) {
        return QueryContractResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryContractResponse();
        message.contracts = (object.contracts !== undefined && object.contracts !== null)
            ? Contracts.fromPartial(object.contracts)
            : undefined;
        return message;
    },
};
function createBaseQueryAllContractsRequest() {
    return { pagination: undefined };
}
const QueryAllContractsRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.pagination !== undefined) {
            PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllContractsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.pagination = PageRequest.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { pagination: isSet$u(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.pagination !== undefined) {
            obj.pagination = PageRequest.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryAllContractsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryAllContractsRequest();
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageRequest.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryAllContractsResponse() {
    return { contracts: [], pagination: undefined };
}
const QueryAllContractsResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.contracts) {
            Contracts.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllContractsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.contracts.push(Contracts.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageResponse.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            contracts: Array.isArray(object?.contracts) ? object.contracts.map((e) => Contracts.fromJSON(e)) : [],
            pagination: isSet$u(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.contracts?.length) {
            obj.contracts = message.contracts.map((e) => Contracts.toJSON(e));
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageResponse.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryAllContractsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryAllContractsResponse();
        message.contracts = object.contracts?.map((e) => Contracts.fromPartial(e)) || [];
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageResponse.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryActiveDealRequest() {
    return { cid: "" };
}
const QueryActiveDealRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.cid !== "") {
            writer.uint32(10).string(message.cid);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryActiveDealRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.cid = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { cid: isSet$u(object.cid) ? String(object.cid) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.cid !== "") {
            obj.cid = message.cid;
        }
        return obj;
    },
    create(base) {
        return QueryActiveDealRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryActiveDealRequest();
        message.cid = object.cid ?? "";
        return message;
    },
};
function createBaseQueryActiveDealResponse() {
    return { activeDeals: undefined };
}
const QueryActiveDealResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.activeDeals !== undefined) {
            ActiveDeals.encode(message.activeDeals, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryActiveDealResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.activeDeals = ActiveDeals.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { activeDeals: isSet$u(object.activeDeals) ? ActiveDeals.fromJSON(object.activeDeals) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.activeDeals !== undefined) {
            obj.activeDeals = ActiveDeals.toJSON(message.activeDeals);
        }
        return obj;
    },
    create(base) {
        return QueryActiveDealResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryActiveDealResponse();
        message.activeDeals = (object.activeDeals !== undefined && object.activeDeals !== null)
            ? ActiveDeals.fromPartial(object.activeDeals)
            : undefined;
        return message;
    },
};
function createBaseQueryAllActiveDealsRequest() {
    return { pagination: undefined };
}
const QueryAllActiveDealsRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.pagination !== undefined) {
            PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllActiveDealsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.pagination = PageRequest.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { pagination: isSet$u(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.pagination !== undefined) {
            obj.pagination = PageRequest.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryAllActiveDealsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryAllActiveDealsRequest();
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageRequest.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryAllActiveDealsResponse() {
    return { activeDeals: [], pagination: undefined };
}
const QueryAllActiveDealsResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.activeDeals) {
            ActiveDeals.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllActiveDealsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.activeDeals.push(ActiveDeals.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageResponse.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            activeDeals: Array.isArray(object?.activeDeals)
                ? object.activeDeals.map((e) => ActiveDeals.fromJSON(e))
                : [],
            pagination: isSet$u(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.activeDeals?.length) {
            obj.activeDeals = message.activeDeals.map((e) => ActiveDeals.toJSON(e));
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageResponse.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryAllActiveDealsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryAllActiveDealsResponse();
        message.activeDeals = object.activeDeals?.map((e) => ActiveDeals.fromPartial(e)) || [];
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageResponse.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryProviderRequest() {
    return { address: "" };
}
const QueryProviderRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryProviderRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { address: isSet$u(object.address) ? String(object.address) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.address !== "") {
            obj.address = message.address;
        }
        return obj;
    },
    create(base) {
        return QueryProviderRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryProviderRequest();
        message.address = object.address ?? "";
        return message;
    },
};
function createBaseQueryProviderResponse() {
    return { providers: undefined };
}
const QueryProviderResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.providers !== undefined) {
            Providers.encode(message.providers, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryProviderResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.providers = Providers.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { providers: isSet$u(object.providers) ? Providers.fromJSON(object.providers) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.providers !== undefined) {
            obj.providers = Providers.toJSON(message.providers);
        }
        return obj;
    },
    create(base) {
        return QueryProviderResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryProviderResponse();
        message.providers = (object.providers !== undefined && object.providers !== null)
            ? Providers.fromPartial(object.providers)
            : undefined;
        return message;
    },
};
function createBaseQueryAllProvidersRequest() {
    return { pagination: undefined };
}
const QueryAllProvidersRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.pagination !== undefined) {
            PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllProvidersRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.pagination = PageRequest.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { pagination: isSet$u(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.pagination !== undefined) {
            obj.pagination = PageRequest.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryAllProvidersRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryAllProvidersRequest();
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageRequest.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryAllProvidersResponse() {
    return { providers: [], pagination: undefined };
}
const QueryAllProvidersResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.providers) {
            Providers.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllProvidersResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.providers.push(Providers.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageResponse.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            providers: Array.isArray(object?.providers) ? object.providers.map((e) => Providers.fromJSON(e)) : [],
            pagination: isSet$u(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.providers?.length) {
            obj.providers = message.providers.map((e) => Providers.toJSON(e));
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageResponse.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryAllProvidersResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryAllProvidersResponse();
        message.providers = object.providers?.map((e) => Providers.fromPartial(e)) || [];
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageResponse.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryFreespaceRequest() {
    return { address: "" };
}
const QueryFreespaceRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryFreespaceRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { address: isSet$u(object.address) ? String(object.address) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.address !== "") {
            obj.address = message.address;
        }
        return obj;
    },
    create(base) {
        return QueryFreespaceRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryFreespaceRequest();
        message.address = object.address ?? "";
        return message;
    },
};
function createBaseQueryStoreCountRequest() {
    return { address: "" };
}
const QueryStoreCountRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryStoreCountRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { address: isSet$u(object.address) ? String(object.address) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.address !== "") {
            obj.address = message.address;
        }
        return obj;
    },
    create(base) {
        return QueryStoreCountRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryStoreCountRequest();
        message.address = object.address ?? "";
        return message;
    },
};
function createBaseQueryFreespaceResponse() {
    return { space: "" };
}
const QueryFreespaceResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.space !== "") {
            writer.uint32(10).string(message.space);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryFreespaceResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.space = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { space: isSet$u(object.space) ? String(object.space) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.space !== "") {
            obj.space = message.space;
        }
        return obj;
    },
    create(base) {
        return QueryFreespaceResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryFreespaceResponse();
        message.space = object.space ?? "";
        return message;
    },
};
function createBaseQueryStoreCountResponse() {
    return { count: "" };
}
const QueryStoreCountResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.count !== "") {
            writer.uint32(10).string(message.count);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryStoreCountResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.count = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { count: isSet$u(object.count) ? String(object.count) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.count !== "") {
            obj.count = message.count;
        }
        return obj;
    },
    create(base) {
        return QueryStoreCountResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryStoreCountResponse();
        message.count = object.count ?? "";
        return message;
    },
};
function createBaseQueryFindFileRequest() {
    return { fid: "" };
}
const QueryFindFileRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.fid !== "") {
            writer.uint32(10).string(message.fid);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryFindFileRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.fid = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { fid: isSet$u(object.fid) ? String(object.fid) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.fid !== "") {
            obj.fid = message.fid;
        }
        return obj;
    },
    create(base) {
        return QueryFindFileRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryFindFileRequest();
        message.fid = object.fid ?? "";
        return message;
    },
};
function createBaseQueryFindFileResponse() {
    return { providerIps: "" };
}
const QueryFindFileResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.providerIps !== "") {
            writer.uint32(10).string(message.providerIps);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryFindFileResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.providerIps = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { providerIps: isSet$u(object.providerIps) ? String(object.providerIps) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.providerIps !== "") {
            obj.providerIps = message.providerIps;
        }
        return obj;
    },
    create(base) {
        return QueryFindFileResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryFindFileResponse();
        message.providerIps = object.providerIps ?? "";
        return message;
    },
};
function createBaseQueryStrayRequest() {
    return { cid: "" };
}
const QueryStrayRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.cid !== "") {
            writer.uint32(10).string(message.cid);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryStrayRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.cid = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { cid: isSet$u(object.cid) ? String(object.cid) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.cid !== "") {
            obj.cid = message.cid;
        }
        return obj;
    },
    create(base) {
        return QueryStrayRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryStrayRequest();
        message.cid = object.cid ?? "";
        return message;
    },
};
function createBaseQueryStrayResponse() {
    return { strays: undefined };
}
const QueryStrayResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.strays !== undefined) {
            Strays.encode(message.strays, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryStrayResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.strays = Strays.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { strays: isSet$u(object.strays) ? Strays.fromJSON(object.strays) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.strays !== undefined) {
            obj.strays = Strays.toJSON(message.strays);
        }
        return obj;
    },
    create(base) {
        return QueryStrayResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryStrayResponse();
        message.strays = (object.strays !== undefined && object.strays !== null)
            ? Strays.fromPartial(object.strays)
            : undefined;
        return message;
    },
};
function createBaseQueryAllStraysRequest() {
    return { pagination: undefined };
}
const QueryAllStraysRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.pagination !== undefined) {
            PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllStraysRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.pagination = PageRequest.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { pagination: isSet$u(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.pagination !== undefined) {
            obj.pagination = PageRequest.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryAllStraysRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryAllStraysRequest();
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageRequest.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryAllStraysResponse() {
    return { strays: [], pagination: undefined };
}
const QueryAllStraysResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.strays) {
            Strays.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllStraysResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.strays.push(Strays.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageResponse.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            strays: Array.isArray(object?.strays) ? object.strays.map((e) => Strays.fromJSON(e)) : [],
            pagination: isSet$u(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.strays?.length) {
            obj.strays = message.strays.map((e) => Strays.toJSON(e));
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageResponse.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryAllStraysResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryAllStraysResponse();
        message.strays = object.strays?.map((e) => Strays.fromPartial(e)) || [];
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageResponse.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryClientFreeSpaceRequest() {
    return { address: "" };
}
const QueryClientFreeSpaceRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryClientFreeSpaceRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { address: isSet$u(object.address) ? String(object.address) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.address !== "") {
            obj.address = message.address;
        }
        return obj;
    },
    create(base) {
        return QueryClientFreeSpaceRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryClientFreeSpaceRequest();
        message.address = object.address ?? "";
        return message;
    },
};
function createBaseQueryClientFreeSpaceResponse() {
    return { bytesfree: 0 };
}
const QueryClientFreeSpaceResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.bytesfree !== 0) {
            writer.uint32(8).int64(message.bytesfree);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryClientFreeSpaceResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.bytesfree = longToNumber$g(reader.int64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { bytesfree: isSet$u(object.bytesfree) ? Number(object.bytesfree) : 0 };
    },
    toJSON(message) {
        const obj = {};
        if (message.bytesfree !== 0) {
            obj.bytesfree = Math.round(message.bytesfree);
        }
        return obj;
    },
    create(base) {
        return QueryClientFreeSpaceResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryClientFreeSpaceResponse();
        message.bytesfree = object.bytesfree ?? 0;
        return message;
    },
};
function createBaseQueryFidCidRequest() {
    return { fid: "" };
}
const QueryFidCidRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.fid !== "") {
            writer.uint32(10).string(message.fid);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryFidCidRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.fid = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { fid: isSet$u(object.fid) ? String(object.fid) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.fid !== "") {
            obj.fid = message.fid;
        }
        return obj;
    },
    create(base) {
        return QueryFidCidRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryFidCidRequest();
        message.fid = object.fid ?? "";
        return message;
    },
};
function createBaseQueryFidCidResponse() {
    return { fidCid: undefined };
}
const QueryFidCidResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.fidCid !== undefined) {
            FidCid.encode(message.fidCid, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryFidCidResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.fidCid = FidCid.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { fidCid: isSet$u(object.fidCid) ? FidCid.fromJSON(object.fidCid) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.fidCid !== undefined) {
            obj.fidCid = FidCid.toJSON(message.fidCid);
        }
        return obj;
    },
    create(base) {
        return QueryFidCidResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryFidCidResponse();
        message.fidCid = (object.fidCid !== undefined && object.fidCid !== null)
            ? FidCid.fromPartial(object.fidCid)
            : undefined;
        return message;
    },
};
function createBaseQueryAllFidCidRequest() {
    return { pagination: undefined };
}
const QueryAllFidCidRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.pagination !== undefined) {
            PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllFidCidRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.pagination = PageRequest.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { pagination: isSet$u(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.pagination !== undefined) {
            obj.pagination = PageRequest.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryAllFidCidRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryAllFidCidRequest();
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageRequest.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryAllFidCidResponse() {
    return { fidCid: [], pagination: undefined };
}
const QueryAllFidCidResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.fidCid) {
            FidCid.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllFidCidResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.fidCid.push(FidCid.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageResponse.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            fidCid: Array.isArray(object?.fidCid) ? object.fidCid.map((e) => FidCid.fromJSON(e)) : [],
            pagination: isSet$u(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.fidCid?.length) {
            obj.fidCid = message.fidCid.map((e) => FidCid.toJSON(e));
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageResponse.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryAllFidCidResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryAllFidCidResponse();
        message.fidCid = object.fidCid?.map((e) => FidCid.fromPartial(e)) || [];
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageResponse.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryPayDataRequest() {
    return { address: "" };
}
const QueryPayDataRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryPayDataRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { address: isSet$u(object.address) ? String(object.address) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.address !== "") {
            obj.address = message.address;
        }
        return obj;
    },
    create(base) {
        return QueryPayDataRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryPayDataRequest();
        message.address = object.address ?? "";
        return message;
    },
};
function createBaseQueryPayDataResponse() {
    return { timeRemaining: 0, bytes: 0 };
}
const QueryPayDataResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.timeRemaining !== 0) {
            writer.uint32(8).int64(message.timeRemaining);
        }
        if (message.bytes !== 0) {
            writer.uint32(16).int64(message.bytes);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryPayDataResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.timeRemaining = longToNumber$g(reader.int64());
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.bytes = longToNumber$g(reader.int64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            timeRemaining: isSet$u(object.timeRemaining) ? Number(object.timeRemaining) : 0,
            bytes: isSet$u(object.bytes) ? Number(object.bytes) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.timeRemaining !== 0) {
            obj.timeRemaining = Math.round(message.timeRemaining);
        }
        if (message.bytes !== 0) {
            obj.bytes = Math.round(message.bytes);
        }
        return obj;
    },
    create(base) {
        return QueryPayDataResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryPayDataResponse();
        message.timeRemaining = object.timeRemaining ?? 0;
        message.bytes = object.bytes ?? 0;
        return message;
    },
};
function createBaseQueryStoragePaymentInfoRequest() {
    return { address: "" };
}
const QueryStoragePaymentInfoRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryStoragePaymentInfoRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { address: isSet$u(object.address) ? String(object.address) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.address !== "") {
            obj.address = message.address;
        }
        return obj;
    },
    create(base) {
        return QueryStoragePaymentInfoRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryStoragePaymentInfoRequest();
        message.address = object.address ?? "";
        return message;
    },
};
function createBaseQueryStoragePaymentInfoResponse() {
    return { storagePaymentInfo: undefined };
}
const QueryStoragePaymentInfoResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.storagePaymentInfo !== undefined) {
            StoragePaymentInfo.encode(message.storagePaymentInfo, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryStoragePaymentInfoResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.storagePaymentInfo = StoragePaymentInfo.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            storagePaymentInfo: isSet$u(object.storagePaymentInfo)
                ? StoragePaymentInfo.fromJSON(object.storagePaymentInfo)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.storagePaymentInfo !== undefined) {
            obj.storagePaymentInfo = StoragePaymentInfo.toJSON(message.storagePaymentInfo);
        }
        return obj;
    },
    create(base) {
        return QueryStoragePaymentInfoResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryStoragePaymentInfoResponse();
        message.storagePaymentInfo = (object.storagePaymentInfo !== undefined && object.storagePaymentInfo !== null)
            ? StoragePaymentInfo.fromPartial(object.storagePaymentInfo)
            : undefined;
        return message;
    },
};
function createBaseQueryAllStoragePaymentInfoRequest() {
    return { pagination: undefined };
}
const QueryAllStoragePaymentInfoRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.pagination !== undefined) {
            PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllStoragePaymentInfoRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.pagination = PageRequest.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { pagination: isSet$u(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.pagination !== undefined) {
            obj.pagination = PageRequest.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryAllStoragePaymentInfoRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryAllStoragePaymentInfoRequest();
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageRequest.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryAllStoragePaymentInfoResponse() {
    return { storagePaymentInfo: [], pagination: undefined };
}
const QueryAllStoragePaymentInfoResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.storagePaymentInfo) {
            StoragePaymentInfo.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllStoragePaymentInfoResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.storagePaymentInfo.push(StoragePaymentInfo.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageResponse.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            storagePaymentInfo: Array.isArray(object?.storagePaymentInfo)
                ? object.storagePaymentInfo.map((e) => StoragePaymentInfo.fromJSON(e))
                : [],
            pagination: isSet$u(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.storagePaymentInfo?.length) {
            obj.storagePaymentInfo = message.storagePaymentInfo.map((e) => StoragePaymentInfo.toJSON(e));
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageResponse.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryAllStoragePaymentInfoResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryAllStoragePaymentInfoResponse();
        message.storagePaymentInfo = object.storagePaymentInfo?.map((e) => StoragePaymentInfo.fromPartial(e)) || [];
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageResponse.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryFileUploadCheckRequest() {
    return { address: "", bytes: 0 };
}
const QueryFileUploadCheckRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        if (message.bytes !== 0) {
            writer.uint32(16).int64(message.bytes);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryFileUploadCheckRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.bytes = longToNumber$g(reader.int64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            address: isSet$u(object.address) ? String(object.address) : "",
            bytes: isSet$u(object.bytes) ? Number(object.bytes) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.address !== "") {
            obj.address = message.address;
        }
        if (message.bytes !== 0) {
            obj.bytes = Math.round(message.bytes);
        }
        return obj;
    },
    create(base) {
        return QueryFileUploadCheckRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryFileUploadCheckRequest();
        message.address = object.address ?? "";
        message.bytes = object.bytes ?? 0;
        return message;
    },
};
function createBaseQueryFileUploadCheckResponse() {
    return { valid: false };
}
const QueryFileUploadCheckResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.valid === true) {
            writer.uint32(8).bool(message.valid);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryFileUploadCheckResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.valid = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { valid: isSet$u(object.valid) ? Boolean(object.valid) : false };
    },
    toJSON(message) {
        const obj = {};
        if (message.valid === true) {
            obj.valid = message.valid;
        }
        return obj;
    },
    create(base) {
        return QueryFileUploadCheckResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryFileUploadCheckResponse();
        message.valid = object.valid ?? false;
        return message;
    },
};
function createBaseQueryPriceCheckRequest() {
    return { duration: "", bytes: 0 };
}
const QueryPriceCheckRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.duration !== "") {
            writer.uint32(10).string(message.duration);
        }
        if (message.bytes !== 0) {
            writer.uint32(16).int64(message.bytes);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryPriceCheckRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.duration = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.bytes = longToNumber$g(reader.int64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            duration: isSet$u(object.duration) ? String(object.duration) : "",
            bytes: isSet$u(object.bytes) ? Number(object.bytes) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.duration !== "") {
            obj.duration = message.duration;
        }
        if (message.bytes !== 0) {
            obj.bytes = Math.round(message.bytes);
        }
        return obj;
    },
    create(base) {
        return QueryPriceCheckRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryPriceCheckRequest();
        message.duration = object.duration ?? "";
        message.bytes = object.bytes ?? 0;
        return message;
    },
};
function createBaseQueryPriceCheckResponse() {
    return { price: 0 };
}
const QueryPriceCheckResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.price !== 0) {
            writer.uint32(8).int64(message.price);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryPriceCheckResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.price = longToNumber$g(reader.int64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { price: isSet$u(object.price) ? Number(object.price) : 0 };
    },
    toJSON(message) {
        const obj = {};
        if (message.price !== 0) {
            obj.price = Math.round(message.price);
        }
        return obj;
    },
    create(base) {
        return QueryPriceCheckResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryPriceCheckResponse();
        message.price = object.price ?? 0;
        return message;
    },
};
let QueryClientImpl$5 = class QueryClientImpl {
    rpc;
    constructor(rpc) {
        this.rpc = rpc;
        this.Params = this.Params.bind(this);
        this.Contracts = this.Contracts.bind(this);
        this.ContractsAll = this.ContractsAll.bind(this);
        this.ActiveDeals = this.ActiveDeals.bind(this);
        this.ActiveDealsAll = this.ActiveDealsAll.bind(this);
        this.Providers = this.Providers.bind(this);
        this.ProvidersAll = this.ProvidersAll.bind(this);
        this.Freespace = this.Freespace.bind(this);
        this.StoreCount = this.StoreCount.bind(this);
        this.FindFile = this.FindFile.bind(this);
        this.Strays = this.Strays.bind(this);
        this.StraysAll = this.StraysAll.bind(this);
        this.GetClientFreeSpace = this.GetClientFreeSpace.bind(this);
        this.FidCid = this.FidCid.bind(this);
        this.FidCidAll = this.FidCidAll.bind(this);
        this.GetPayData = this.GetPayData.bind(this);
        this.StoragePaymentInfo = this.StoragePaymentInfo.bind(this);
        this.StoragePaymentInfoAll = this.StoragePaymentInfoAll.bind(this);
        this.FileUploadCheck = this.FileUploadCheck.bind(this);
        this.PriceCheck = this.PriceCheck.bind(this);
    }
    Params(request, metadata) {
        return this.rpc.unary(QueryParamsDesc$5, QueryParamsRequest$5.fromPartial(request), metadata);
    }
    Contracts(request, metadata) {
        return this.rpc.unary(QueryContractsDesc, QueryContractRequest.fromPartial(request), metadata);
    }
    ContractsAll(request, metadata) {
        return this.rpc.unary(QueryContractsAllDesc, QueryAllContractsRequest.fromPartial(request), metadata);
    }
    ActiveDeals(request, metadata) {
        return this.rpc.unary(QueryActiveDealsDesc, QueryActiveDealRequest.fromPartial(request), metadata);
    }
    ActiveDealsAll(request, metadata) {
        return this.rpc.unary(QueryActiveDealsAllDesc, QueryAllActiveDealsRequest.fromPartial(request), metadata);
    }
    Providers(request, metadata) {
        return this.rpc.unary(QueryProvidersDesc, QueryProviderRequest.fromPartial(request), metadata);
    }
    ProvidersAll(request, metadata) {
        return this.rpc.unary(QueryProvidersAllDesc, QueryAllProvidersRequest.fromPartial(request), metadata);
    }
    Freespace(request, metadata) {
        return this.rpc.unary(QueryFreespaceDesc, QueryFreespaceRequest.fromPartial(request), metadata);
    }
    StoreCount(request, metadata) {
        return this.rpc.unary(QueryStoreCountDesc, QueryStoreCountRequest.fromPartial(request), metadata);
    }
    FindFile(request, metadata) {
        return this.rpc.unary(QueryFindFileDesc, QueryFindFileRequest.fromPartial(request), metadata);
    }
    Strays(request, metadata) {
        return this.rpc.unary(QueryStraysDesc, QueryStrayRequest.fromPartial(request), metadata);
    }
    StraysAll(request, metadata) {
        return this.rpc.unary(QueryStraysAllDesc, QueryAllStraysRequest.fromPartial(request), metadata);
    }
    GetClientFreeSpace(request, metadata) {
        return this.rpc.unary(QueryGetClientFreeSpaceDesc, QueryClientFreeSpaceRequest.fromPartial(request), metadata);
    }
    FidCid(request, metadata) {
        return this.rpc.unary(QueryFidCidDesc, QueryFidCidRequest.fromPartial(request), metadata);
    }
    FidCidAll(request, metadata) {
        return this.rpc.unary(QueryFidCidAllDesc, QueryAllFidCidRequest.fromPartial(request), metadata);
    }
    GetPayData(request, metadata) {
        return this.rpc.unary(QueryGetPayDataDesc, QueryPayDataRequest.fromPartial(request), metadata);
    }
    StoragePaymentInfo(request, metadata) {
        return this.rpc.unary(QueryStoragePaymentInfoDesc, QueryStoragePaymentInfoRequest.fromPartial(request), metadata);
    }
    StoragePaymentInfoAll(request, metadata) {
        return this.rpc.unary(QueryStoragePaymentInfoAllDesc, QueryAllStoragePaymentInfoRequest.fromPartial(request), metadata);
    }
    FileUploadCheck(request, metadata) {
        return this.rpc.unary(QueryFileUploadCheckDesc, QueryFileUploadCheckRequest.fromPartial(request), metadata);
    }
    PriceCheck(request, metadata) {
        return this.rpc.unary(QueryPriceCheckDesc, QueryPriceCheckRequest.fromPartial(request), metadata);
    }
};
const QueryDesc$5 = { serviceName: "canine_chain.storage.Query" };
const QueryParamsDesc$5 = {
    methodName: "Params",
    service: QueryDesc$5,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryParamsRequest$5.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryParamsResponse$5.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryContractsDesc = {
    methodName: "Contracts",
    service: QueryDesc$5,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryContractRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryContractResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryContractsAllDesc = {
    methodName: "ContractsAll",
    service: QueryDesc$5,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryAllContractsRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryAllContractsResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryActiveDealsDesc = {
    methodName: "ActiveDeals",
    service: QueryDesc$5,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryActiveDealRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryActiveDealResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryActiveDealsAllDesc = {
    methodName: "ActiveDealsAll",
    service: QueryDesc$5,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryAllActiveDealsRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryAllActiveDealsResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryProvidersDesc = {
    methodName: "Providers",
    service: QueryDesc$5,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryProviderRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryProviderResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryProvidersAllDesc = {
    methodName: "ProvidersAll",
    service: QueryDesc$5,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryAllProvidersRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryAllProvidersResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryFreespaceDesc = {
    methodName: "Freespace",
    service: QueryDesc$5,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryFreespaceRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryFreespaceResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryStoreCountDesc = {
    methodName: "StoreCount",
    service: QueryDesc$5,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryStoreCountRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryStoreCountResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryFindFileDesc = {
    methodName: "FindFile",
    service: QueryDesc$5,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryFindFileRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryFindFileResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryStraysDesc = {
    methodName: "Strays",
    service: QueryDesc$5,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryStrayRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryStrayResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryStraysAllDesc = {
    methodName: "StraysAll",
    service: QueryDesc$5,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryAllStraysRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryAllStraysResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryGetClientFreeSpaceDesc = {
    methodName: "GetClientFreeSpace",
    service: QueryDesc$5,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryClientFreeSpaceRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryClientFreeSpaceResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryFidCidDesc = {
    methodName: "FidCid",
    service: QueryDesc$5,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryFidCidRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryFidCidResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryFidCidAllDesc = {
    methodName: "FidCidAll",
    service: QueryDesc$5,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryAllFidCidRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryAllFidCidResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryGetPayDataDesc = {
    methodName: "GetPayData",
    service: QueryDesc$5,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryPayDataRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryPayDataResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryStoragePaymentInfoDesc = {
    methodName: "StoragePaymentInfo",
    service: QueryDesc$5,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryStoragePaymentInfoRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryStoragePaymentInfoResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryStoragePaymentInfoAllDesc = {
    methodName: "StoragePaymentInfoAll",
    service: QueryDesc$5,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryAllStoragePaymentInfoRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryAllStoragePaymentInfoResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryFileUploadCheckDesc = {
    methodName: "FileUploadCheck",
    service: QueryDesc$5,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryFileUploadCheckRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryFileUploadCheckResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryPriceCheckDesc = {
    methodName: "PriceCheck",
    service: QueryDesc$5,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryPriceCheckRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryPriceCheckResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
let GrpcWebImpl$g = class GrpcWebImpl {
    host;
    options;
    constructor(host, options) {
        this.host = host;
        this.options = options;
    }
    unary(methodDesc, _request, metadata) {
        const request = { ..._request, ...methodDesc.requestType };
        const maybeCombinedMetadata = metadata && this.options.metadata
            ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
            : metadata ?? this.options.metadata;
        return new Promise((resolve, reject) => {
            grpc.unary(methodDesc, {
                request,
                host: this.host,
                metadata: maybeCombinedMetadata ?? {},
                ...(this.options.transport !== undefined ? { transport: this.options.transport } : {}),
                debug: this.options.debug ?? false,
                onEnd: function (response) {
                    if (response.status === grpc.Code.OK) {
                        resolve(response.message.toObject());
                    }
                    else {
                        const err = new GrpcWebError$g(response.statusMessage, response.status, response.trailers);
                        reject(err);
                    }
                },
            });
        });
    }
};
const tsProtoGlobalThis$s = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function longToNumber$g(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new tsProtoGlobalThis$s.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isSet$u(value) {
    return value !== null && value !== undefined;
}
let GrpcWebError$g = class GrpcWebError extends tsProtoGlobalThis$s.Error {
    code;
    metadata;
    constructor(message, code, metadata) {
        super(message);
        this.code = code;
        this.metadata = metadata;
    }
};

/* eslint-disable */
const protobufPackage$t = "tendermint.crypto";
function createBasePublicKey() {
    return { ed25519: undefined, secp256k1: undefined };
}
const PublicKey = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.ed25519 !== undefined) {
            writer.uint32(10).bytes(message.ed25519);
        }
        if (message.secp256k1 !== undefined) {
            writer.uint32(18).bytes(message.secp256k1);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePublicKey();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.ed25519 = reader.bytes();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.secp256k1 = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            ed25519: isSet$t(object.ed25519) ? bytesFromBase64$7(object.ed25519) : undefined,
            secp256k1: isSet$t(object.secp256k1) ? bytesFromBase64$7(object.secp256k1) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.ed25519 !== undefined) {
            obj.ed25519 = base64FromBytes$7(message.ed25519);
        }
        if (message.secp256k1 !== undefined) {
            obj.secp256k1 = base64FromBytes$7(message.secp256k1);
        }
        return obj;
    },
    create(base) {
        return PublicKey.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePublicKey();
        message.ed25519 = object.ed25519 ?? undefined;
        message.secp256k1 = object.secp256k1 ?? undefined;
        return message;
    },
};
const tsProtoGlobalThis$r = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function bytesFromBase64$7(b64) {
    if (tsProtoGlobalThis$r.Buffer) {
        return Uint8Array.from(tsProtoGlobalThis$r.Buffer.from(b64, "base64"));
    }
    else {
        const bin = tsProtoGlobalThis$r.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes$7(arr) {
    if (tsProtoGlobalThis$r.Buffer) {
        return tsProtoGlobalThis$r.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(String.fromCharCode(byte));
        });
        return tsProtoGlobalThis$r.btoa(bin.join(""));
    }
}
function isSet$t(value) {
    return value !== null && value !== undefined;
}

/* eslint-disable */
const protobufPackage$s = "tendermint.crypto";
function createBaseProof() {
    return { total: 0, index: 0, leafHash: new Uint8Array(0), aunts: [] };
}
const Proof = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.total !== 0) {
            writer.uint32(8).int64(message.total);
        }
        if (message.index !== 0) {
            writer.uint32(16).int64(message.index);
        }
        if (message.leafHash.length !== 0) {
            writer.uint32(26).bytes(message.leafHash);
        }
        for (const v of message.aunts) {
            writer.uint32(34).bytes(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProof();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.total = longToNumber$f(reader.int64());
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.index = longToNumber$f(reader.int64());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.leafHash = reader.bytes();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.aunts.push(reader.bytes());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            total: isSet$s(object.total) ? Number(object.total) : 0,
            index: isSet$s(object.index) ? Number(object.index) : 0,
            leafHash: isSet$s(object.leafHash) ? bytesFromBase64$6(object.leafHash) : new Uint8Array(0),
            aunts: Array.isArray(object?.aunts) ? object.aunts.map((e) => bytesFromBase64$6(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.total !== 0) {
            obj.total = Math.round(message.total);
        }
        if (message.index !== 0) {
            obj.index = Math.round(message.index);
        }
        if (message.leafHash.length !== 0) {
            obj.leafHash = base64FromBytes$6(message.leafHash);
        }
        if (message.aunts?.length) {
            obj.aunts = message.aunts.map((e) => base64FromBytes$6(e));
        }
        return obj;
    },
    create(base) {
        return Proof.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseProof();
        message.total = object.total ?? 0;
        message.index = object.index ?? 0;
        message.leafHash = object.leafHash ?? new Uint8Array(0);
        message.aunts = object.aunts?.map((e) => e) || [];
        return message;
    },
};
function createBaseValueOp() {
    return { key: new Uint8Array(0), proof: undefined };
}
const ValueOp = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key.length !== 0) {
            writer.uint32(10).bytes(message.key);
        }
        if (message.proof !== undefined) {
            Proof.encode(message.proof, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValueOp();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.bytes();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.proof = Proof.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet$s(object.key) ? bytesFromBase64$6(object.key) : new Uint8Array(0),
            proof: isSet$s(object.proof) ? Proof.fromJSON(object.proof) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key.length !== 0) {
            obj.key = base64FromBytes$6(message.key);
        }
        if (message.proof !== undefined) {
            obj.proof = Proof.toJSON(message.proof);
        }
        return obj;
    },
    create(base) {
        return ValueOp.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseValueOp();
        message.key = object.key ?? new Uint8Array(0);
        message.proof = (object.proof !== undefined && object.proof !== null) ? Proof.fromPartial(object.proof) : undefined;
        return message;
    },
};
function createBaseDominoOp() {
    return { key: "", input: "", output: "" };
}
const DominoOp = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.input !== "") {
            writer.uint32(18).string(message.input);
        }
        if (message.output !== "") {
            writer.uint32(26).string(message.output);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDominoOp();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.input = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.output = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet$s(object.key) ? String(object.key) : "",
            input: isSet$s(object.input) ? String(object.input) : "",
            output: isSet$s(object.output) ? String(object.output) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.input !== "") {
            obj.input = message.input;
        }
        if (message.output !== "") {
            obj.output = message.output;
        }
        return obj;
    },
    create(base) {
        return DominoOp.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDominoOp();
        message.key = object.key ?? "";
        message.input = object.input ?? "";
        message.output = object.output ?? "";
        return message;
    },
};
function createBaseProofOp() {
    return { type: "", key: new Uint8Array(0), data: new Uint8Array(0) };
}
const ProofOp = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.type !== "") {
            writer.uint32(10).string(message.type);
        }
        if (message.key.length !== 0) {
            writer.uint32(18).bytes(message.key);
        }
        if (message.data.length !== 0) {
            writer.uint32(26).bytes(message.data);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProofOp();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.type = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.key = reader.bytes();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.data = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            type: isSet$s(object.type) ? String(object.type) : "",
            key: isSet$s(object.key) ? bytesFromBase64$6(object.key) : new Uint8Array(0),
            data: isSet$s(object.data) ? bytesFromBase64$6(object.data) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.type !== "") {
            obj.type = message.type;
        }
        if (message.key.length !== 0) {
            obj.key = base64FromBytes$6(message.key);
        }
        if (message.data.length !== 0) {
            obj.data = base64FromBytes$6(message.data);
        }
        return obj;
    },
    create(base) {
        return ProofOp.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseProofOp();
        message.type = object.type ?? "";
        message.key = object.key ?? new Uint8Array(0);
        message.data = object.data ?? new Uint8Array(0);
        return message;
    },
};
function createBaseProofOps() {
    return { ops: [] };
}
const ProofOps = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.ops) {
            ProofOp.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProofOps();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.ops.push(ProofOp.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { ops: Array.isArray(object?.ops) ? object.ops.map((e) => ProofOp.fromJSON(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.ops?.length) {
            obj.ops = message.ops.map((e) => ProofOp.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return ProofOps.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseProofOps();
        message.ops = object.ops?.map((e) => ProofOp.fromPartial(e)) || [];
        return message;
    },
};
const tsProtoGlobalThis$q = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function bytesFromBase64$6(b64) {
    if (tsProtoGlobalThis$q.Buffer) {
        return Uint8Array.from(tsProtoGlobalThis$q.Buffer.from(b64, "base64"));
    }
    else {
        const bin = tsProtoGlobalThis$q.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes$6(arr) {
    if (tsProtoGlobalThis$q.Buffer) {
        return tsProtoGlobalThis$q.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(String.fromCharCode(byte));
        });
        return tsProtoGlobalThis$q.btoa(bin.join(""));
    }
}
function longToNumber$f(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new tsProtoGlobalThis$q.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isSet$s(value) {
    return value !== null && value !== undefined;
}

/* eslint-disable */
const protobufPackage$r = "google.protobuf";
function createBaseDuration() {
    return { seconds: 0, nanos: 0 };
}
const Duration = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.seconds !== 0) {
            writer.uint32(8).int64(message.seconds);
        }
        if (message.nanos !== 0) {
            writer.uint32(16).int32(message.nanos);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDuration();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.seconds = longToNumber$e(reader.int64());
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.nanos = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            seconds: isSet$r(object.seconds) ? Number(object.seconds) : 0,
            nanos: isSet$r(object.nanos) ? Number(object.nanos) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.seconds !== 0) {
            obj.seconds = Math.round(message.seconds);
        }
        if (message.nanos !== 0) {
            obj.nanos = Math.round(message.nanos);
        }
        return obj;
    },
    create(base) {
        return Duration.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDuration();
        message.seconds = object.seconds ?? 0;
        message.nanos = object.nanos ?? 0;
        return message;
    },
};
const tsProtoGlobalThis$p = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function longToNumber$e(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new tsProtoGlobalThis$p.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isSet$r(value) {
    return value !== null && value !== undefined;
}

/* eslint-disable */
const protobufPackage$q = "tendermint.types";
function createBaseConsensusParams$1() {
    return { block: undefined, evidence: undefined, validator: undefined, version: undefined };
}
const ConsensusParams$1 = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.block !== undefined) {
            BlockParams$1.encode(message.block, writer.uint32(10).fork()).ldelim();
        }
        if (message.evidence !== undefined) {
            EvidenceParams.encode(message.evidence, writer.uint32(18).fork()).ldelim();
        }
        if (message.validator !== undefined) {
            ValidatorParams.encode(message.validator, writer.uint32(26).fork()).ldelim();
        }
        if (message.version !== undefined) {
            VersionParams.encode(message.version, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConsensusParams$1();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.block = BlockParams$1.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.evidence = EvidenceParams.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.validator = ValidatorParams.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.version = VersionParams.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            block: isSet$q(object.block) ? BlockParams$1.fromJSON(object.block) : undefined,
            evidence: isSet$q(object.evidence) ? EvidenceParams.fromJSON(object.evidence) : undefined,
            validator: isSet$q(object.validator) ? ValidatorParams.fromJSON(object.validator) : undefined,
            version: isSet$q(object.version) ? VersionParams.fromJSON(object.version) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.block !== undefined) {
            obj.block = BlockParams$1.toJSON(message.block);
        }
        if (message.evidence !== undefined) {
            obj.evidence = EvidenceParams.toJSON(message.evidence);
        }
        if (message.validator !== undefined) {
            obj.validator = ValidatorParams.toJSON(message.validator);
        }
        if (message.version !== undefined) {
            obj.version = VersionParams.toJSON(message.version);
        }
        return obj;
    },
    create(base) {
        return ConsensusParams$1.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseConsensusParams$1();
        message.block = (object.block !== undefined && object.block !== null)
            ? BlockParams$1.fromPartial(object.block)
            : undefined;
        message.evidence = (object.evidence !== undefined && object.evidence !== null)
            ? EvidenceParams.fromPartial(object.evidence)
            : undefined;
        message.validator = (object.validator !== undefined && object.validator !== null)
            ? ValidatorParams.fromPartial(object.validator)
            : undefined;
        message.version = (object.version !== undefined && object.version !== null)
            ? VersionParams.fromPartial(object.version)
            : undefined;
        return message;
    },
};
function createBaseBlockParams$1() {
    return { maxBytes: 0, maxGas: 0, timeIotaMs: 0 };
}
const BlockParams$1 = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.maxBytes !== 0) {
            writer.uint32(8).int64(message.maxBytes);
        }
        if (message.maxGas !== 0) {
            writer.uint32(16).int64(message.maxGas);
        }
        if (message.timeIotaMs !== 0) {
            writer.uint32(24).int64(message.timeIotaMs);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockParams$1();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.maxBytes = longToNumber$d(reader.int64());
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.maxGas = longToNumber$d(reader.int64());
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.timeIotaMs = longToNumber$d(reader.int64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            maxBytes: isSet$q(object.maxBytes) ? Number(object.maxBytes) : 0,
            maxGas: isSet$q(object.maxGas) ? Number(object.maxGas) : 0,
            timeIotaMs: isSet$q(object.timeIotaMs) ? Number(object.timeIotaMs) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.maxBytes !== 0) {
            obj.maxBytes = Math.round(message.maxBytes);
        }
        if (message.maxGas !== 0) {
            obj.maxGas = Math.round(message.maxGas);
        }
        if (message.timeIotaMs !== 0) {
            obj.timeIotaMs = Math.round(message.timeIotaMs);
        }
        return obj;
    },
    create(base) {
        return BlockParams$1.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBlockParams$1();
        message.maxBytes = object.maxBytes ?? 0;
        message.maxGas = object.maxGas ?? 0;
        message.timeIotaMs = object.timeIotaMs ?? 0;
        return message;
    },
};
function createBaseEvidenceParams() {
    return { maxAgeNumBlocks: 0, maxAgeDuration: undefined, maxBytes: 0 };
}
const EvidenceParams = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.maxAgeNumBlocks !== 0) {
            writer.uint32(8).int64(message.maxAgeNumBlocks);
        }
        if (message.maxAgeDuration !== undefined) {
            Duration.encode(message.maxAgeDuration, writer.uint32(18).fork()).ldelim();
        }
        if (message.maxBytes !== 0) {
            writer.uint32(24).int64(message.maxBytes);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEvidenceParams();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.maxAgeNumBlocks = longToNumber$d(reader.int64());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.maxAgeDuration = Duration.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.maxBytes = longToNumber$d(reader.int64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            maxAgeNumBlocks: isSet$q(object.maxAgeNumBlocks) ? Number(object.maxAgeNumBlocks) : 0,
            maxAgeDuration: isSet$q(object.maxAgeDuration) ? Duration.fromJSON(object.maxAgeDuration) : undefined,
            maxBytes: isSet$q(object.maxBytes) ? Number(object.maxBytes) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.maxAgeNumBlocks !== 0) {
            obj.maxAgeNumBlocks = Math.round(message.maxAgeNumBlocks);
        }
        if (message.maxAgeDuration !== undefined) {
            obj.maxAgeDuration = Duration.toJSON(message.maxAgeDuration);
        }
        if (message.maxBytes !== 0) {
            obj.maxBytes = Math.round(message.maxBytes);
        }
        return obj;
    },
    create(base) {
        return EvidenceParams.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseEvidenceParams();
        message.maxAgeNumBlocks = object.maxAgeNumBlocks ?? 0;
        message.maxAgeDuration = (object.maxAgeDuration !== undefined && object.maxAgeDuration !== null)
            ? Duration.fromPartial(object.maxAgeDuration)
            : undefined;
        message.maxBytes = object.maxBytes ?? 0;
        return message;
    },
};
function createBaseValidatorParams() {
    return { pubKeyTypes: [] };
}
const ValidatorParams = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.pubKeyTypes) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidatorParams();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.pubKeyTypes.push(reader.string());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { pubKeyTypes: Array.isArray(object?.pubKeyTypes) ? object.pubKeyTypes.map((e) => String(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.pubKeyTypes?.length) {
            obj.pubKeyTypes = message.pubKeyTypes;
        }
        return obj;
    },
    create(base) {
        return ValidatorParams.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseValidatorParams();
        message.pubKeyTypes = object.pubKeyTypes?.map((e) => e) || [];
        return message;
    },
};
function createBaseVersionParams() {
    return { appVersion: 0 };
}
const VersionParams = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.appVersion !== 0) {
            writer.uint32(8).uint64(message.appVersion);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVersionParams();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.appVersion = longToNumber$d(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { appVersion: isSet$q(object.appVersion) ? Number(object.appVersion) : 0 };
    },
    toJSON(message) {
        const obj = {};
        if (message.appVersion !== 0) {
            obj.appVersion = Math.round(message.appVersion);
        }
        return obj;
    },
    create(base) {
        return VersionParams.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseVersionParams();
        message.appVersion = object.appVersion ?? 0;
        return message;
    },
};
function createBaseHashedParams() {
    return { blockMaxBytes: 0, blockMaxGas: 0 };
}
const HashedParams = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.blockMaxBytes !== 0) {
            writer.uint32(8).int64(message.blockMaxBytes);
        }
        if (message.blockMaxGas !== 0) {
            writer.uint32(16).int64(message.blockMaxGas);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHashedParams();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.blockMaxBytes = longToNumber$d(reader.int64());
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.blockMaxGas = longToNumber$d(reader.int64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            blockMaxBytes: isSet$q(object.blockMaxBytes) ? Number(object.blockMaxBytes) : 0,
            blockMaxGas: isSet$q(object.blockMaxGas) ? Number(object.blockMaxGas) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.blockMaxBytes !== 0) {
            obj.blockMaxBytes = Math.round(message.blockMaxBytes);
        }
        if (message.blockMaxGas !== 0) {
            obj.blockMaxGas = Math.round(message.blockMaxGas);
        }
        return obj;
    },
    create(base) {
        return HashedParams.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseHashedParams();
        message.blockMaxBytes = object.blockMaxBytes ?? 0;
        message.blockMaxGas = object.blockMaxGas ?? 0;
        return message;
    },
};
const tsProtoGlobalThis$o = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function longToNumber$d(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new tsProtoGlobalThis$o.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isSet$q(value) {
    return value !== null && value !== undefined;
}

/* eslint-disable */
const protobufPackage$p = "tendermint.version";
function createBaseApp() {
    return { protocol: 0, software: "" };
}
const App = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.protocol !== 0) {
            writer.uint32(8).uint64(message.protocol);
        }
        if (message.software !== "") {
            writer.uint32(18).string(message.software);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseApp();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.protocol = longToNumber$c(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.software = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            protocol: isSet$p(object.protocol) ? Number(object.protocol) : 0,
            software: isSet$p(object.software) ? String(object.software) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.protocol !== 0) {
            obj.protocol = Math.round(message.protocol);
        }
        if (message.software !== "") {
            obj.software = message.software;
        }
        return obj;
    },
    create(base) {
        return App.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseApp();
        message.protocol = object.protocol ?? 0;
        message.software = object.software ?? "";
        return message;
    },
};
function createBaseConsensus() {
    return { block: 0, app: 0 };
}
const Consensus = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.block !== 0) {
            writer.uint32(8).uint64(message.block);
        }
        if (message.app !== 0) {
            writer.uint32(16).uint64(message.app);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConsensus();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.block = longToNumber$c(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.app = longToNumber$c(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { block: isSet$p(object.block) ? Number(object.block) : 0, app: isSet$p(object.app) ? Number(object.app) : 0 };
    },
    toJSON(message) {
        const obj = {};
        if (message.block !== 0) {
            obj.block = Math.round(message.block);
        }
        if (message.app !== 0) {
            obj.app = Math.round(message.app);
        }
        return obj;
    },
    create(base) {
        return Consensus.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseConsensus();
        message.block = object.block ?? 0;
        message.app = object.app ?? 0;
        return message;
    },
};
const tsProtoGlobalThis$n = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function longToNumber$c(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new tsProtoGlobalThis$n.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isSet$p(value) {
    return value !== null && value !== undefined;
}

/* eslint-disable */
const protobufPackage$o = "tendermint.types";
function createBaseValidatorSet() {
    return { validators: [], proposer: undefined, totalVotingPower: 0 };
}
const ValidatorSet = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.validators) {
            Validator$2.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.proposer !== undefined) {
            Validator$2.encode(message.proposer, writer.uint32(18).fork()).ldelim();
        }
        if (message.totalVotingPower !== 0) {
            writer.uint32(24).int64(message.totalVotingPower);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidatorSet();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.validators.push(Validator$2.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.proposer = Validator$2.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.totalVotingPower = longToNumber$b(reader.int64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            validators: Array.isArray(object?.validators) ? object.validators.map((e) => Validator$2.fromJSON(e)) : [],
            proposer: isSet$o(object.proposer) ? Validator$2.fromJSON(object.proposer) : undefined,
            totalVotingPower: isSet$o(object.totalVotingPower) ? Number(object.totalVotingPower) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.validators?.length) {
            obj.validators = message.validators.map((e) => Validator$2.toJSON(e));
        }
        if (message.proposer !== undefined) {
            obj.proposer = Validator$2.toJSON(message.proposer);
        }
        if (message.totalVotingPower !== 0) {
            obj.totalVotingPower = Math.round(message.totalVotingPower);
        }
        return obj;
    },
    create(base) {
        return ValidatorSet.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseValidatorSet();
        message.validators = object.validators?.map((e) => Validator$2.fromPartial(e)) || [];
        message.proposer = (object.proposer !== undefined && object.proposer !== null)
            ? Validator$2.fromPartial(object.proposer)
            : undefined;
        message.totalVotingPower = object.totalVotingPower ?? 0;
        return message;
    },
};
function createBaseValidator$2() {
    return { address: new Uint8Array(0), pubKey: undefined, votingPower: 0, proposerPriority: 0 };
}
const Validator$2 = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.address.length !== 0) {
            writer.uint32(10).bytes(message.address);
        }
        if (message.pubKey !== undefined) {
            PublicKey.encode(message.pubKey, writer.uint32(18).fork()).ldelim();
        }
        if (message.votingPower !== 0) {
            writer.uint32(24).int64(message.votingPower);
        }
        if (message.proposerPriority !== 0) {
            writer.uint32(32).int64(message.proposerPriority);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidator$2();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.address = reader.bytes();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pubKey = PublicKey.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.votingPower = longToNumber$b(reader.int64());
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.proposerPriority = longToNumber$b(reader.int64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            address: isSet$o(object.address) ? bytesFromBase64$5(object.address) : new Uint8Array(0),
            pubKey: isSet$o(object.pubKey) ? PublicKey.fromJSON(object.pubKey) : undefined,
            votingPower: isSet$o(object.votingPower) ? Number(object.votingPower) : 0,
            proposerPriority: isSet$o(object.proposerPriority) ? Number(object.proposerPriority) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.address.length !== 0) {
            obj.address = base64FromBytes$5(message.address);
        }
        if (message.pubKey !== undefined) {
            obj.pubKey = PublicKey.toJSON(message.pubKey);
        }
        if (message.votingPower !== 0) {
            obj.votingPower = Math.round(message.votingPower);
        }
        if (message.proposerPriority !== 0) {
            obj.proposerPriority = Math.round(message.proposerPriority);
        }
        return obj;
    },
    create(base) {
        return Validator$2.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseValidator$2();
        message.address = object.address ?? new Uint8Array(0);
        message.pubKey = (object.pubKey !== undefined && object.pubKey !== null)
            ? PublicKey.fromPartial(object.pubKey)
            : undefined;
        message.votingPower = object.votingPower ?? 0;
        message.proposerPriority = object.proposerPriority ?? 0;
        return message;
    },
};
function createBaseSimpleValidator() {
    return { pubKey: undefined, votingPower: 0 };
}
const SimpleValidator = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.pubKey !== undefined) {
            PublicKey.encode(message.pubKey, writer.uint32(10).fork()).ldelim();
        }
        if (message.votingPower !== 0) {
            writer.uint32(16).int64(message.votingPower);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSimpleValidator();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.pubKey = PublicKey.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.votingPower = longToNumber$b(reader.int64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            pubKey: isSet$o(object.pubKey) ? PublicKey.fromJSON(object.pubKey) : undefined,
            votingPower: isSet$o(object.votingPower) ? Number(object.votingPower) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.pubKey !== undefined) {
            obj.pubKey = PublicKey.toJSON(message.pubKey);
        }
        if (message.votingPower !== 0) {
            obj.votingPower = Math.round(message.votingPower);
        }
        return obj;
    },
    create(base) {
        return SimpleValidator.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSimpleValidator();
        message.pubKey = (object.pubKey !== undefined && object.pubKey !== null)
            ? PublicKey.fromPartial(object.pubKey)
            : undefined;
        message.votingPower = object.votingPower ?? 0;
        return message;
    },
};
const tsProtoGlobalThis$m = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function bytesFromBase64$5(b64) {
    if (tsProtoGlobalThis$m.Buffer) {
        return Uint8Array.from(tsProtoGlobalThis$m.Buffer.from(b64, "base64"));
    }
    else {
        const bin = tsProtoGlobalThis$m.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes$5(arr) {
    if (tsProtoGlobalThis$m.Buffer) {
        return tsProtoGlobalThis$m.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(String.fromCharCode(byte));
        });
        return tsProtoGlobalThis$m.btoa(bin.join(""));
    }
}
function longToNumber$b(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new tsProtoGlobalThis$m.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isSet$o(value) {
    return value !== null && value !== undefined;
}

/* eslint-disable */
const protobufPackage$n = "tendermint.types";
/** BlockIdFlag indicates which BlcokID the signature is for */
var BlockIDFlag;
(function (BlockIDFlag) {
    BlockIDFlag[BlockIDFlag["BLOCK_ID_FLAG_UNKNOWN"] = 0] = "BLOCK_ID_FLAG_UNKNOWN";
    BlockIDFlag[BlockIDFlag["BLOCK_ID_FLAG_ABSENT"] = 1] = "BLOCK_ID_FLAG_ABSENT";
    BlockIDFlag[BlockIDFlag["BLOCK_ID_FLAG_COMMIT"] = 2] = "BLOCK_ID_FLAG_COMMIT";
    BlockIDFlag[BlockIDFlag["BLOCK_ID_FLAG_NIL"] = 3] = "BLOCK_ID_FLAG_NIL";
    BlockIDFlag[BlockIDFlag["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BlockIDFlag || (BlockIDFlag = {}));
function blockIDFlagFromJSON(object) {
    switch (object) {
        case 0:
        case "BLOCK_ID_FLAG_UNKNOWN":
            return BlockIDFlag.BLOCK_ID_FLAG_UNKNOWN;
        case 1:
        case "BLOCK_ID_FLAG_ABSENT":
            return BlockIDFlag.BLOCK_ID_FLAG_ABSENT;
        case 2:
        case "BLOCK_ID_FLAG_COMMIT":
            return BlockIDFlag.BLOCK_ID_FLAG_COMMIT;
        case 3:
        case "BLOCK_ID_FLAG_NIL":
            return BlockIDFlag.BLOCK_ID_FLAG_NIL;
        case -1:
        case "UNRECOGNIZED":
        default:
            return BlockIDFlag.UNRECOGNIZED;
    }
}
function blockIDFlagToJSON(object) {
    switch (object) {
        case BlockIDFlag.BLOCK_ID_FLAG_UNKNOWN:
            return "BLOCK_ID_FLAG_UNKNOWN";
        case BlockIDFlag.BLOCK_ID_FLAG_ABSENT:
            return "BLOCK_ID_FLAG_ABSENT";
        case BlockIDFlag.BLOCK_ID_FLAG_COMMIT:
            return "BLOCK_ID_FLAG_COMMIT";
        case BlockIDFlag.BLOCK_ID_FLAG_NIL:
            return "BLOCK_ID_FLAG_NIL";
        case BlockIDFlag.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
/** SignedMsgType is a type of signed message in the consensus. */
var SignedMsgType;
(function (SignedMsgType) {
    SignedMsgType[SignedMsgType["SIGNED_MSG_TYPE_UNKNOWN"] = 0] = "SIGNED_MSG_TYPE_UNKNOWN";
    /** SIGNED_MSG_TYPE_PREVOTE - Votes */
    SignedMsgType[SignedMsgType["SIGNED_MSG_TYPE_PREVOTE"] = 1] = "SIGNED_MSG_TYPE_PREVOTE";
    SignedMsgType[SignedMsgType["SIGNED_MSG_TYPE_PRECOMMIT"] = 2] = "SIGNED_MSG_TYPE_PRECOMMIT";
    /** SIGNED_MSG_TYPE_PROPOSAL - Proposals */
    SignedMsgType[SignedMsgType["SIGNED_MSG_TYPE_PROPOSAL"] = 32] = "SIGNED_MSG_TYPE_PROPOSAL";
    SignedMsgType[SignedMsgType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(SignedMsgType || (SignedMsgType = {}));
function signedMsgTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "SIGNED_MSG_TYPE_UNKNOWN":
            return SignedMsgType.SIGNED_MSG_TYPE_UNKNOWN;
        case 1:
        case "SIGNED_MSG_TYPE_PREVOTE":
            return SignedMsgType.SIGNED_MSG_TYPE_PREVOTE;
        case 2:
        case "SIGNED_MSG_TYPE_PRECOMMIT":
            return SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT;
        case 32:
        case "SIGNED_MSG_TYPE_PROPOSAL":
            return SignedMsgType.SIGNED_MSG_TYPE_PROPOSAL;
        case -1:
        case "UNRECOGNIZED":
        default:
            return SignedMsgType.UNRECOGNIZED;
    }
}
function signedMsgTypeToJSON(object) {
    switch (object) {
        case SignedMsgType.SIGNED_MSG_TYPE_UNKNOWN:
            return "SIGNED_MSG_TYPE_UNKNOWN";
        case SignedMsgType.SIGNED_MSG_TYPE_PREVOTE:
            return "SIGNED_MSG_TYPE_PREVOTE";
        case SignedMsgType.SIGNED_MSG_TYPE_PRECOMMIT:
            return "SIGNED_MSG_TYPE_PRECOMMIT";
        case SignedMsgType.SIGNED_MSG_TYPE_PROPOSAL:
            return "SIGNED_MSG_TYPE_PROPOSAL";
        case SignedMsgType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBasePartSetHeader() {
    return { total: 0, hash: new Uint8Array(0) };
}
const PartSetHeader = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.total !== 0) {
            writer.uint32(8).uint32(message.total);
        }
        if (message.hash.length !== 0) {
            writer.uint32(18).bytes(message.hash);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePartSetHeader();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.total = reader.uint32();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.hash = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            total: isSet$n(object.total) ? Number(object.total) : 0,
            hash: isSet$n(object.hash) ? bytesFromBase64$4(object.hash) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.total !== 0) {
            obj.total = Math.round(message.total);
        }
        if (message.hash.length !== 0) {
            obj.hash = base64FromBytes$4(message.hash);
        }
        return obj;
    },
    create(base) {
        return PartSetHeader.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePartSetHeader();
        message.total = object.total ?? 0;
        message.hash = object.hash ?? new Uint8Array(0);
        return message;
    },
};
function createBasePart() {
    return { index: 0, bytes: new Uint8Array(0), proof: undefined };
}
const Part = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.index !== 0) {
            writer.uint32(8).uint32(message.index);
        }
        if (message.bytes.length !== 0) {
            writer.uint32(18).bytes(message.bytes);
        }
        if (message.proof !== undefined) {
            Proof.encode(message.proof, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePart();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.index = reader.uint32();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.bytes = reader.bytes();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.proof = Proof.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            index: isSet$n(object.index) ? Number(object.index) : 0,
            bytes: isSet$n(object.bytes) ? bytesFromBase64$4(object.bytes) : new Uint8Array(0),
            proof: isSet$n(object.proof) ? Proof.fromJSON(object.proof) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.index !== 0) {
            obj.index = Math.round(message.index);
        }
        if (message.bytes.length !== 0) {
            obj.bytes = base64FromBytes$4(message.bytes);
        }
        if (message.proof !== undefined) {
            obj.proof = Proof.toJSON(message.proof);
        }
        return obj;
    },
    create(base) {
        return Part.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePart();
        message.index = object.index ?? 0;
        message.bytes = object.bytes ?? new Uint8Array(0);
        message.proof = (object.proof !== undefined && object.proof !== null) ? Proof.fromPartial(object.proof) : undefined;
        return message;
    },
};
function createBaseBlockID() {
    return { hash: new Uint8Array(0), partSetHeader: undefined };
}
const BlockID = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.hash.length !== 0) {
            writer.uint32(10).bytes(message.hash);
        }
        if (message.partSetHeader !== undefined) {
            PartSetHeader.encode(message.partSetHeader, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockID();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.hash = reader.bytes();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.partSetHeader = PartSetHeader.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            hash: isSet$n(object.hash) ? bytesFromBase64$4(object.hash) : new Uint8Array(0),
            partSetHeader: isSet$n(object.partSetHeader) ? PartSetHeader.fromJSON(object.partSetHeader) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.hash.length !== 0) {
            obj.hash = base64FromBytes$4(message.hash);
        }
        if (message.partSetHeader !== undefined) {
            obj.partSetHeader = PartSetHeader.toJSON(message.partSetHeader);
        }
        return obj;
    },
    create(base) {
        return BlockID.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBlockID();
        message.hash = object.hash ?? new Uint8Array(0);
        message.partSetHeader = (object.partSetHeader !== undefined && object.partSetHeader !== null)
            ? PartSetHeader.fromPartial(object.partSetHeader)
            : undefined;
        return message;
    },
};
function createBaseHeader() {
    return {
        version: undefined,
        chainId: "",
        height: 0,
        time: undefined,
        lastBlockId: undefined,
        lastCommitHash: new Uint8Array(0),
        dataHash: new Uint8Array(0),
        validatorsHash: new Uint8Array(0),
        nextValidatorsHash: new Uint8Array(0),
        consensusHash: new Uint8Array(0),
        appHash: new Uint8Array(0),
        lastResultsHash: new Uint8Array(0),
        evidenceHash: new Uint8Array(0),
        proposerAddress: new Uint8Array(0),
    };
}
const Header = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.version !== undefined) {
            Consensus.encode(message.version, writer.uint32(10).fork()).ldelim();
        }
        if (message.chainId !== "") {
            writer.uint32(18).string(message.chainId);
        }
        if (message.height !== 0) {
            writer.uint32(24).int64(message.height);
        }
        if (message.time !== undefined) {
            Timestamp.encode(toTimestamp$5(message.time), writer.uint32(34).fork()).ldelim();
        }
        if (message.lastBlockId !== undefined) {
            BlockID.encode(message.lastBlockId, writer.uint32(42).fork()).ldelim();
        }
        if (message.lastCommitHash.length !== 0) {
            writer.uint32(50).bytes(message.lastCommitHash);
        }
        if (message.dataHash.length !== 0) {
            writer.uint32(58).bytes(message.dataHash);
        }
        if (message.validatorsHash.length !== 0) {
            writer.uint32(66).bytes(message.validatorsHash);
        }
        if (message.nextValidatorsHash.length !== 0) {
            writer.uint32(74).bytes(message.nextValidatorsHash);
        }
        if (message.consensusHash.length !== 0) {
            writer.uint32(82).bytes(message.consensusHash);
        }
        if (message.appHash.length !== 0) {
            writer.uint32(90).bytes(message.appHash);
        }
        if (message.lastResultsHash.length !== 0) {
            writer.uint32(98).bytes(message.lastResultsHash);
        }
        if (message.evidenceHash.length !== 0) {
            writer.uint32(106).bytes(message.evidenceHash);
        }
        if (message.proposerAddress.length !== 0) {
            writer.uint32(114).bytes(message.proposerAddress);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHeader();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.version = Consensus.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.chainId = reader.string();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.height = longToNumber$a(reader.int64());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.time = fromTimestamp$5(Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.lastBlockId = BlockID.decode(reader, reader.uint32());
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.lastCommitHash = reader.bytes();
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.dataHash = reader.bytes();
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.validatorsHash = reader.bytes();
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.nextValidatorsHash = reader.bytes();
                    continue;
                case 10:
                    if (tag !== 82) {
                        break;
                    }
                    message.consensusHash = reader.bytes();
                    continue;
                case 11:
                    if (tag !== 90) {
                        break;
                    }
                    message.appHash = reader.bytes();
                    continue;
                case 12:
                    if (tag !== 98) {
                        break;
                    }
                    message.lastResultsHash = reader.bytes();
                    continue;
                case 13:
                    if (tag !== 106) {
                        break;
                    }
                    message.evidenceHash = reader.bytes();
                    continue;
                case 14:
                    if (tag !== 114) {
                        break;
                    }
                    message.proposerAddress = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            version: isSet$n(object.version) ? Consensus.fromJSON(object.version) : undefined,
            chainId: isSet$n(object.chainId) ? String(object.chainId) : "",
            height: isSet$n(object.height) ? Number(object.height) : 0,
            time: isSet$n(object.time) ? fromJsonTimestamp$5(object.time) : undefined,
            lastBlockId: isSet$n(object.lastBlockId) ? BlockID.fromJSON(object.lastBlockId) : undefined,
            lastCommitHash: isSet$n(object.lastCommitHash) ? bytesFromBase64$4(object.lastCommitHash) : new Uint8Array(0),
            dataHash: isSet$n(object.dataHash) ? bytesFromBase64$4(object.dataHash) : new Uint8Array(0),
            validatorsHash: isSet$n(object.validatorsHash) ? bytesFromBase64$4(object.validatorsHash) : new Uint8Array(0),
            nextValidatorsHash: isSet$n(object.nextValidatorsHash)
                ? bytesFromBase64$4(object.nextValidatorsHash)
                : new Uint8Array(0),
            consensusHash: isSet$n(object.consensusHash) ? bytesFromBase64$4(object.consensusHash) : new Uint8Array(0),
            appHash: isSet$n(object.appHash) ? bytesFromBase64$4(object.appHash) : new Uint8Array(0),
            lastResultsHash: isSet$n(object.lastResultsHash) ? bytesFromBase64$4(object.lastResultsHash) : new Uint8Array(0),
            evidenceHash: isSet$n(object.evidenceHash) ? bytesFromBase64$4(object.evidenceHash) : new Uint8Array(0),
            proposerAddress: isSet$n(object.proposerAddress) ? bytesFromBase64$4(object.proposerAddress) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.version !== undefined) {
            obj.version = Consensus.toJSON(message.version);
        }
        if (message.chainId !== "") {
            obj.chainId = message.chainId;
        }
        if (message.height !== 0) {
            obj.height = Math.round(message.height);
        }
        if (message.time !== undefined) {
            obj.time = message.time.toISOString();
        }
        if (message.lastBlockId !== undefined) {
            obj.lastBlockId = BlockID.toJSON(message.lastBlockId);
        }
        if (message.lastCommitHash.length !== 0) {
            obj.lastCommitHash = base64FromBytes$4(message.lastCommitHash);
        }
        if (message.dataHash.length !== 0) {
            obj.dataHash = base64FromBytes$4(message.dataHash);
        }
        if (message.validatorsHash.length !== 0) {
            obj.validatorsHash = base64FromBytes$4(message.validatorsHash);
        }
        if (message.nextValidatorsHash.length !== 0) {
            obj.nextValidatorsHash = base64FromBytes$4(message.nextValidatorsHash);
        }
        if (message.consensusHash.length !== 0) {
            obj.consensusHash = base64FromBytes$4(message.consensusHash);
        }
        if (message.appHash.length !== 0) {
            obj.appHash = base64FromBytes$4(message.appHash);
        }
        if (message.lastResultsHash.length !== 0) {
            obj.lastResultsHash = base64FromBytes$4(message.lastResultsHash);
        }
        if (message.evidenceHash.length !== 0) {
            obj.evidenceHash = base64FromBytes$4(message.evidenceHash);
        }
        if (message.proposerAddress.length !== 0) {
            obj.proposerAddress = base64FromBytes$4(message.proposerAddress);
        }
        return obj;
    },
    create(base) {
        return Header.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseHeader();
        message.version = (object.version !== undefined && object.version !== null)
            ? Consensus.fromPartial(object.version)
            : undefined;
        message.chainId = object.chainId ?? "";
        message.height = object.height ?? 0;
        message.time = object.time ?? undefined;
        message.lastBlockId = (object.lastBlockId !== undefined && object.lastBlockId !== null)
            ? BlockID.fromPartial(object.lastBlockId)
            : undefined;
        message.lastCommitHash = object.lastCommitHash ?? new Uint8Array(0);
        message.dataHash = object.dataHash ?? new Uint8Array(0);
        message.validatorsHash = object.validatorsHash ?? new Uint8Array(0);
        message.nextValidatorsHash = object.nextValidatorsHash ?? new Uint8Array(0);
        message.consensusHash = object.consensusHash ?? new Uint8Array(0);
        message.appHash = object.appHash ?? new Uint8Array(0);
        message.lastResultsHash = object.lastResultsHash ?? new Uint8Array(0);
        message.evidenceHash = object.evidenceHash ?? new Uint8Array(0);
        message.proposerAddress = object.proposerAddress ?? new Uint8Array(0);
        return message;
    },
};
function createBaseData() {
    return { txs: [] };
}
const Data = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.txs) {
            writer.uint32(10).bytes(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.txs.push(reader.bytes());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { txs: Array.isArray(object?.txs) ? object.txs.map((e) => bytesFromBase64$4(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.txs?.length) {
            obj.txs = message.txs.map((e) => base64FromBytes$4(e));
        }
        return obj;
    },
    create(base) {
        return Data.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseData();
        message.txs = object.txs?.map((e) => e) || [];
        return message;
    },
};
function createBaseVote$1() {
    return {
        type: 0,
        height: 0,
        round: 0,
        blockId: undefined,
        timestamp: undefined,
        validatorAddress: new Uint8Array(0),
        validatorIndex: 0,
        signature: new Uint8Array(0),
    };
}
const Vote$1 = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.type !== 0) {
            writer.uint32(8).int32(message.type);
        }
        if (message.height !== 0) {
            writer.uint32(16).int64(message.height);
        }
        if (message.round !== 0) {
            writer.uint32(24).int32(message.round);
        }
        if (message.blockId !== undefined) {
            BlockID.encode(message.blockId, writer.uint32(34).fork()).ldelim();
        }
        if (message.timestamp !== undefined) {
            Timestamp.encode(toTimestamp$5(message.timestamp), writer.uint32(42).fork()).ldelim();
        }
        if (message.validatorAddress.length !== 0) {
            writer.uint32(50).bytes(message.validatorAddress);
        }
        if (message.validatorIndex !== 0) {
            writer.uint32(56).int32(message.validatorIndex);
        }
        if (message.signature.length !== 0) {
            writer.uint32(66).bytes(message.signature);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVote$1();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.type = reader.int32();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.height = longToNumber$a(reader.int64());
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.round = reader.int32();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.blockId = BlockID.decode(reader, reader.uint32());
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.timestamp = fromTimestamp$5(Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.validatorAddress = reader.bytes();
                    continue;
                case 7:
                    if (tag !== 56) {
                        break;
                    }
                    message.validatorIndex = reader.int32();
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.signature = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            type: isSet$n(object.type) ? signedMsgTypeFromJSON(object.type) : 0,
            height: isSet$n(object.height) ? Number(object.height) : 0,
            round: isSet$n(object.round) ? Number(object.round) : 0,
            blockId: isSet$n(object.blockId) ? BlockID.fromJSON(object.blockId) : undefined,
            timestamp: isSet$n(object.timestamp) ? fromJsonTimestamp$5(object.timestamp) : undefined,
            validatorAddress: isSet$n(object.validatorAddress) ? bytesFromBase64$4(object.validatorAddress) : new Uint8Array(0),
            validatorIndex: isSet$n(object.validatorIndex) ? Number(object.validatorIndex) : 0,
            signature: isSet$n(object.signature) ? bytesFromBase64$4(object.signature) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.type !== 0) {
            obj.type = signedMsgTypeToJSON(message.type);
        }
        if (message.height !== 0) {
            obj.height = Math.round(message.height);
        }
        if (message.round !== 0) {
            obj.round = Math.round(message.round);
        }
        if (message.blockId !== undefined) {
            obj.blockId = BlockID.toJSON(message.blockId);
        }
        if (message.timestamp !== undefined) {
            obj.timestamp = message.timestamp.toISOString();
        }
        if (message.validatorAddress.length !== 0) {
            obj.validatorAddress = base64FromBytes$4(message.validatorAddress);
        }
        if (message.validatorIndex !== 0) {
            obj.validatorIndex = Math.round(message.validatorIndex);
        }
        if (message.signature.length !== 0) {
            obj.signature = base64FromBytes$4(message.signature);
        }
        return obj;
    },
    create(base) {
        return Vote$1.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseVote$1();
        message.type = object.type ?? 0;
        message.height = object.height ?? 0;
        message.round = object.round ?? 0;
        message.blockId = (object.blockId !== undefined && object.blockId !== null)
            ? BlockID.fromPartial(object.blockId)
            : undefined;
        message.timestamp = object.timestamp ?? undefined;
        message.validatorAddress = object.validatorAddress ?? new Uint8Array(0);
        message.validatorIndex = object.validatorIndex ?? 0;
        message.signature = object.signature ?? new Uint8Array(0);
        return message;
    },
};
function createBaseCommit() {
    return { height: 0, round: 0, blockId: undefined, signatures: [] };
}
const Commit = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.height !== 0) {
            writer.uint32(8).int64(message.height);
        }
        if (message.round !== 0) {
            writer.uint32(16).int32(message.round);
        }
        if (message.blockId !== undefined) {
            BlockID.encode(message.blockId, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.signatures) {
            CommitSig.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommit();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.height = longToNumber$a(reader.int64());
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.round = reader.int32();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.blockId = BlockID.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.signatures.push(CommitSig.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            height: isSet$n(object.height) ? Number(object.height) : 0,
            round: isSet$n(object.round) ? Number(object.round) : 0,
            blockId: isSet$n(object.blockId) ? BlockID.fromJSON(object.blockId) : undefined,
            signatures: Array.isArray(object?.signatures) ? object.signatures.map((e) => CommitSig.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.height !== 0) {
            obj.height = Math.round(message.height);
        }
        if (message.round !== 0) {
            obj.round = Math.round(message.round);
        }
        if (message.blockId !== undefined) {
            obj.blockId = BlockID.toJSON(message.blockId);
        }
        if (message.signatures?.length) {
            obj.signatures = message.signatures.map((e) => CommitSig.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return Commit.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCommit();
        message.height = object.height ?? 0;
        message.round = object.round ?? 0;
        message.blockId = (object.blockId !== undefined && object.blockId !== null)
            ? BlockID.fromPartial(object.blockId)
            : undefined;
        message.signatures = object.signatures?.map((e) => CommitSig.fromPartial(e)) || [];
        return message;
    },
};
function createBaseCommitSig() {
    return { blockIdFlag: 0, validatorAddress: new Uint8Array(0), timestamp: undefined, signature: new Uint8Array(0) };
}
const CommitSig = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.blockIdFlag !== 0) {
            writer.uint32(8).int32(message.blockIdFlag);
        }
        if (message.validatorAddress.length !== 0) {
            writer.uint32(18).bytes(message.validatorAddress);
        }
        if (message.timestamp !== undefined) {
            Timestamp.encode(toTimestamp$5(message.timestamp), writer.uint32(26).fork()).ldelim();
        }
        if (message.signature.length !== 0) {
            writer.uint32(34).bytes(message.signature);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommitSig();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.blockIdFlag = reader.int32();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.validatorAddress = reader.bytes();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.timestamp = fromTimestamp$5(Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.signature = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            blockIdFlag: isSet$n(object.blockIdFlag) ? blockIDFlagFromJSON(object.blockIdFlag) : 0,
            validatorAddress: isSet$n(object.validatorAddress) ? bytesFromBase64$4(object.validatorAddress) : new Uint8Array(0),
            timestamp: isSet$n(object.timestamp) ? fromJsonTimestamp$5(object.timestamp) : undefined,
            signature: isSet$n(object.signature) ? bytesFromBase64$4(object.signature) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.blockIdFlag !== 0) {
            obj.blockIdFlag = blockIDFlagToJSON(message.blockIdFlag);
        }
        if (message.validatorAddress.length !== 0) {
            obj.validatorAddress = base64FromBytes$4(message.validatorAddress);
        }
        if (message.timestamp !== undefined) {
            obj.timestamp = message.timestamp.toISOString();
        }
        if (message.signature.length !== 0) {
            obj.signature = base64FromBytes$4(message.signature);
        }
        return obj;
    },
    create(base) {
        return CommitSig.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCommitSig();
        message.blockIdFlag = object.blockIdFlag ?? 0;
        message.validatorAddress = object.validatorAddress ?? new Uint8Array(0);
        message.timestamp = object.timestamp ?? undefined;
        message.signature = object.signature ?? new Uint8Array(0);
        return message;
    },
};
function createBaseProposal$1() {
    return {
        type: 0,
        height: 0,
        round: 0,
        polRound: 0,
        blockId: undefined,
        timestamp: undefined,
        signature: new Uint8Array(0),
    };
}
const Proposal$1 = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.type !== 0) {
            writer.uint32(8).int32(message.type);
        }
        if (message.height !== 0) {
            writer.uint32(16).int64(message.height);
        }
        if (message.round !== 0) {
            writer.uint32(24).int32(message.round);
        }
        if (message.polRound !== 0) {
            writer.uint32(32).int32(message.polRound);
        }
        if (message.blockId !== undefined) {
            BlockID.encode(message.blockId, writer.uint32(42).fork()).ldelim();
        }
        if (message.timestamp !== undefined) {
            Timestamp.encode(toTimestamp$5(message.timestamp), writer.uint32(50).fork()).ldelim();
        }
        if (message.signature.length !== 0) {
            writer.uint32(58).bytes(message.signature);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProposal$1();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.type = reader.int32();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.height = longToNumber$a(reader.int64());
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.round = reader.int32();
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.polRound = reader.int32();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.blockId = BlockID.decode(reader, reader.uint32());
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.timestamp = fromTimestamp$5(Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.signature = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            type: isSet$n(object.type) ? signedMsgTypeFromJSON(object.type) : 0,
            height: isSet$n(object.height) ? Number(object.height) : 0,
            round: isSet$n(object.round) ? Number(object.round) : 0,
            polRound: isSet$n(object.polRound) ? Number(object.polRound) : 0,
            blockId: isSet$n(object.blockId) ? BlockID.fromJSON(object.blockId) : undefined,
            timestamp: isSet$n(object.timestamp) ? fromJsonTimestamp$5(object.timestamp) : undefined,
            signature: isSet$n(object.signature) ? bytesFromBase64$4(object.signature) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.type !== 0) {
            obj.type = signedMsgTypeToJSON(message.type);
        }
        if (message.height !== 0) {
            obj.height = Math.round(message.height);
        }
        if (message.round !== 0) {
            obj.round = Math.round(message.round);
        }
        if (message.polRound !== 0) {
            obj.polRound = Math.round(message.polRound);
        }
        if (message.blockId !== undefined) {
            obj.blockId = BlockID.toJSON(message.blockId);
        }
        if (message.timestamp !== undefined) {
            obj.timestamp = message.timestamp.toISOString();
        }
        if (message.signature.length !== 0) {
            obj.signature = base64FromBytes$4(message.signature);
        }
        return obj;
    },
    create(base) {
        return Proposal$1.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseProposal$1();
        message.type = object.type ?? 0;
        message.height = object.height ?? 0;
        message.round = object.round ?? 0;
        message.polRound = object.polRound ?? 0;
        message.blockId = (object.blockId !== undefined && object.blockId !== null)
            ? BlockID.fromPartial(object.blockId)
            : undefined;
        message.timestamp = object.timestamp ?? undefined;
        message.signature = object.signature ?? new Uint8Array(0);
        return message;
    },
};
function createBaseSignedHeader() {
    return { header: undefined, commit: undefined };
}
const SignedHeader = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.header !== undefined) {
            Header.encode(message.header, writer.uint32(10).fork()).ldelim();
        }
        if (message.commit !== undefined) {
            Commit.encode(message.commit, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSignedHeader();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.header = Header.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.commit = Commit.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            header: isSet$n(object.header) ? Header.fromJSON(object.header) : undefined,
            commit: isSet$n(object.commit) ? Commit.fromJSON(object.commit) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.header !== undefined) {
            obj.header = Header.toJSON(message.header);
        }
        if (message.commit !== undefined) {
            obj.commit = Commit.toJSON(message.commit);
        }
        return obj;
    },
    create(base) {
        return SignedHeader.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSignedHeader();
        message.header = (object.header !== undefined && object.header !== null)
            ? Header.fromPartial(object.header)
            : undefined;
        message.commit = (object.commit !== undefined && object.commit !== null)
            ? Commit.fromPartial(object.commit)
            : undefined;
        return message;
    },
};
function createBaseLightBlock() {
    return { signedHeader: undefined, validatorSet: undefined };
}
const LightBlock = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.signedHeader !== undefined) {
            SignedHeader.encode(message.signedHeader, writer.uint32(10).fork()).ldelim();
        }
        if (message.validatorSet !== undefined) {
            ValidatorSet.encode(message.validatorSet, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLightBlock();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.signedHeader = SignedHeader.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.validatorSet = ValidatorSet.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            signedHeader: isSet$n(object.signedHeader) ? SignedHeader.fromJSON(object.signedHeader) : undefined,
            validatorSet: isSet$n(object.validatorSet) ? ValidatorSet.fromJSON(object.validatorSet) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.signedHeader !== undefined) {
            obj.signedHeader = SignedHeader.toJSON(message.signedHeader);
        }
        if (message.validatorSet !== undefined) {
            obj.validatorSet = ValidatorSet.toJSON(message.validatorSet);
        }
        return obj;
    },
    create(base) {
        return LightBlock.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseLightBlock();
        message.signedHeader = (object.signedHeader !== undefined && object.signedHeader !== null)
            ? SignedHeader.fromPartial(object.signedHeader)
            : undefined;
        message.validatorSet = (object.validatorSet !== undefined && object.validatorSet !== null)
            ? ValidatorSet.fromPartial(object.validatorSet)
            : undefined;
        return message;
    },
};
function createBaseBlockMeta() {
    return { blockId: undefined, blockSize: 0, header: undefined, numTxs: 0 };
}
const BlockMeta = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.blockId !== undefined) {
            BlockID.encode(message.blockId, writer.uint32(10).fork()).ldelim();
        }
        if (message.blockSize !== 0) {
            writer.uint32(16).int64(message.blockSize);
        }
        if (message.header !== undefined) {
            Header.encode(message.header, writer.uint32(26).fork()).ldelim();
        }
        if (message.numTxs !== 0) {
            writer.uint32(32).int64(message.numTxs);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockMeta();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.blockId = BlockID.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.blockSize = longToNumber$a(reader.int64());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.header = Header.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.numTxs = longToNumber$a(reader.int64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            blockId: isSet$n(object.blockId) ? BlockID.fromJSON(object.blockId) : undefined,
            blockSize: isSet$n(object.blockSize) ? Number(object.blockSize) : 0,
            header: isSet$n(object.header) ? Header.fromJSON(object.header) : undefined,
            numTxs: isSet$n(object.numTxs) ? Number(object.numTxs) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.blockId !== undefined) {
            obj.blockId = BlockID.toJSON(message.blockId);
        }
        if (message.blockSize !== 0) {
            obj.blockSize = Math.round(message.blockSize);
        }
        if (message.header !== undefined) {
            obj.header = Header.toJSON(message.header);
        }
        if (message.numTxs !== 0) {
            obj.numTxs = Math.round(message.numTxs);
        }
        return obj;
    },
    create(base) {
        return BlockMeta.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBlockMeta();
        message.blockId = (object.blockId !== undefined && object.blockId !== null)
            ? BlockID.fromPartial(object.blockId)
            : undefined;
        message.blockSize = object.blockSize ?? 0;
        message.header = (object.header !== undefined && object.header !== null)
            ? Header.fromPartial(object.header)
            : undefined;
        message.numTxs = object.numTxs ?? 0;
        return message;
    },
};
function createBaseTxProof() {
    return { rootHash: new Uint8Array(0), data: new Uint8Array(0), proof: undefined };
}
const TxProof = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.rootHash.length !== 0) {
            writer.uint32(10).bytes(message.rootHash);
        }
        if (message.data.length !== 0) {
            writer.uint32(18).bytes(message.data);
        }
        if (message.proof !== undefined) {
            Proof.encode(message.proof, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTxProof();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.rootHash = reader.bytes();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.data = reader.bytes();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.proof = Proof.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            rootHash: isSet$n(object.rootHash) ? bytesFromBase64$4(object.rootHash) : new Uint8Array(0),
            data: isSet$n(object.data) ? bytesFromBase64$4(object.data) : new Uint8Array(0),
            proof: isSet$n(object.proof) ? Proof.fromJSON(object.proof) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.rootHash.length !== 0) {
            obj.rootHash = base64FromBytes$4(message.rootHash);
        }
        if (message.data.length !== 0) {
            obj.data = base64FromBytes$4(message.data);
        }
        if (message.proof !== undefined) {
            obj.proof = Proof.toJSON(message.proof);
        }
        return obj;
    },
    create(base) {
        return TxProof.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTxProof();
        message.rootHash = object.rootHash ?? new Uint8Array(0);
        message.data = object.data ?? new Uint8Array(0);
        message.proof = (object.proof !== undefined && object.proof !== null) ? Proof.fromPartial(object.proof) : undefined;
        return message;
    },
};
const tsProtoGlobalThis$l = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function bytesFromBase64$4(b64) {
    if (tsProtoGlobalThis$l.Buffer) {
        return Uint8Array.from(tsProtoGlobalThis$l.Buffer.from(b64, "base64"));
    }
    else {
        const bin = tsProtoGlobalThis$l.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes$4(arr) {
    if (tsProtoGlobalThis$l.Buffer) {
        return tsProtoGlobalThis$l.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(String.fromCharCode(byte));
        });
        return tsProtoGlobalThis$l.btoa(bin.join(""));
    }
}
function toTimestamp$5(date) {
    const seconds = date.getTime() / 1_000;
    const nanos = (date.getTime() % 1_000) * 1_000_000;
    return { seconds, nanos };
}
function fromTimestamp$5(t) {
    let millis = (t.seconds || 0) * 1_000;
    millis += (t.nanos || 0) / 1_000_000;
    return new Date(millis);
}
function fromJsonTimestamp$5(o) {
    if (o instanceof Date) {
        return o;
    }
    else if (typeof o === "string") {
        return new Date(o);
    }
    else {
        return fromTimestamp$5(Timestamp.fromJSON(o));
    }
}
function longToNumber$a(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new tsProtoGlobalThis$l.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isSet$n(value) {
    return value !== null && value !== undefined;
}

/* eslint-disable */
const protobufPackage$m = "tendermint.abci";
var CheckTxType;
(function (CheckTxType) {
    CheckTxType[CheckTxType["NEW"] = 0] = "NEW";
    CheckTxType[CheckTxType["RECHECK"] = 1] = "RECHECK";
    CheckTxType[CheckTxType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(CheckTxType || (CheckTxType = {}));
function checkTxTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "NEW":
            return CheckTxType.NEW;
        case 1:
        case "RECHECK":
            return CheckTxType.RECHECK;
        case -1:
        case "UNRECOGNIZED":
        default:
            return CheckTxType.UNRECOGNIZED;
    }
}
function checkTxTypeToJSON(object) {
    switch (object) {
        case CheckTxType.NEW:
            return "NEW";
        case CheckTxType.RECHECK:
            return "RECHECK";
        case CheckTxType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
var EvidenceType;
(function (EvidenceType) {
    EvidenceType[EvidenceType["UNKNOWN"] = 0] = "UNKNOWN";
    EvidenceType[EvidenceType["DUPLICATE_VOTE"] = 1] = "DUPLICATE_VOTE";
    EvidenceType[EvidenceType["LIGHT_CLIENT_ATTACK"] = 2] = "LIGHT_CLIENT_ATTACK";
    EvidenceType[EvidenceType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(EvidenceType || (EvidenceType = {}));
function evidenceTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "UNKNOWN":
            return EvidenceType.UNKNOWN;
        case 1:
        case "DUPLICATE_VOTE":
            return EvidenceType.DUPLICATE_VOTE;
        case 2:
        case "LIGHT_CLIENT_ATTACK":
            return EvidenceType.LIGHT_CLIENT_ATTACK;
        case -1:
        case "UNRECOGNIZED":
        default:
            return EvidenceType.UNRECOGNIZED;
    }
}
function evidenceTypeToJSON(object) {
    switch (object) {
        case EvidenceType.UNKNOWN:
            return "UNKNOWN";
        case EvidenceType.DUPLICATE_VOTE:
            return "DUPLICATE_VOTE";
        case EvidenceType.LIGHT_CLIENT_ATTACK:
            return "LIGHT_CLIENT_ATTACK";
        case EvidenceType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
var ResponseOfferSnapshot_Result;
(function (ResponseOfferSnapshot_Result) {
    /** UNKNOWN - Unknown result, abort all snapshot restoration */
    ResponseOfferSnapshot_Result[ResponseOfferSnapshot_Result["UNKNOWN"] = 0] = "UNKNOWN";
    /** ACCEPT - Snapshot accepted, apply chunks */
    ResponseOfferSnapshot_Result[ResponseOfferSnapshot_Result["ACCEPT"] = 1] = "ACCEPT";
    /** ABORT - Abort all snapshot restoration */
    ResponseOfferSnapshot_Result[ResponseOfferSnapshot_Result["ABORT"] = 2] = "ABORT";
    /** REJECT - Reject this specific snapshot, try others */
    ResponseOfferSnapshot_Result[ResponseOfferSnapshot_Result["REJECT"] = 3] = "REJECT";
    /** REJECT_FORMAT - Reject all snapshots of this format, try others */
    ResponseOfferSnapshot_Result[ResponseOfferSnapshot_Result["REJECT_FORMAT"] = 4] = "REJECT_FORMAT";
    /** REJECT_SENDER - Reject all snapshots from the sender(s), try others */
    ResponseOfferSnapshot_Result[ResponseOfferSnapshot_Result["REJECT_SENDER"] = 5] = "REJECT_SENDER";
    ResponseOfferSnapshot_Result[ResponseOfferSnapshot_Result["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ResponseOfferSnapshot_Result || (ResponseOfferSnapshot_Result = {}));
function responseOfferSnapshot_ResultFromJSON(object) {
    switch (object) {
        case 0:
        case "UNKNOWN":
            return ResponseOfferSnapshot_Result.UNKNOWN;
        case 1:
        case "ACCEPT":
            return ResponseOfferSnapshot_Result.ACCEPT;
        case 2:
        case "ABORT":
            return ResponseOfferSnapshot_Result.ABORT;
        case 3:
        case "REJECT":
            return ResponseOfferSnapshot_Result.REJECT;
        case 4:
        case "REJECT_FORMAT":
            return ResponseOfferSnapshot_Result.REJECT_FORMAT;
        case 5:
        case "REJECT_SENDER":
            return ResponseOfferSnapshot_Result.REJECT_SENDER;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ResponseOfferSnapshot_Result.UNRECOGNIZED;
    }
}
function responseOfferSnapshot_ResultToJSON(object) {
    switch (object) {
        case ResponseOfferSnapshot_Result.UNKNOWN:
            return "UNKNOWN";
        case ResponseOfferSnapshot_Result.ACCEPT:
            return "ACCEPT";
        case ResponseOfferSnapshot_Result.ABORT:
            return "ABORT";
        case ResponseOfferSnapshot_Result.REJECT:
            return "REJECT";
        case ResponseOfferSnapshot_Result.REJECT_FORMAT:
            return "REJECT_FORMAT";
        case ResponseOfferSnapshot_Result.REJECT_SENDER:
            return "REJECT_SENDER";
        case ResponseOfferSnapshot_Result.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
var ResponseApplySnapshotChunk_Result;
(function (ResponseApplySnapshotChunk_Result) {
    /** UNKNOWN - Unknown result, abort all snapshot restoration */
    ResponseApplySnapshotChunk_Result[ResponseApplySnapshotChunk_Result["UNKNOWN"] = 0] = "UNKNOWN";
    /** ACCEPT - Chunk successfully accepted */
    ResponseApplySnapshotChunk_Result[ResponseApplySnapshotChunk_Result["ACCEPT"] = 1] = "ACCEPT";
    /** ABORT - Abort all snapshot restoration */
    ResponseApplySnapshotChunk_Result[ResponseApplySnapshotChunk_Result["ABORT"] = 2] = "ABORT";
    /** RETRY - Retry chunk (combine with refetch and reject) */
    ResponseApplySnapshotChunk_Result[ResponseApplySnapshotChunk_Result["RETRY"] = 3] = "RETRY";
    /** RETRY_SNAPSHOT - Retry snapshot (combine with refetch and reject) */
    ResponseApplySnapshotChunk_Result[ResponseApplySnapshotChunk_Result["RETRY_SNAPSHOT"] = 4] = "RETRY_SNAPSHOT";
    /** REJECT_SNAPSHOT - Reject this snapshot, try others */
    ResponseApplySnapshotChunk_Result[ResponseApplySnapshotChunk_Result["REJECT_SNAPSHOT"] = 5] = "REJECT_SNAPSHOT";
    ResponseApplySnapshotChunk_Result[ResponseApplySnapshotChunk_Result["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ResponseApplySnapshotChunk_Result || (ResponseApplySnapshotChunk_Result = {}));
function responseApplySnapshotChunk_ResultFromJSON(object) {
    switch (object) {
        case 0:
        case "UNKNOWN":
            return ResponseApplySnapshotChunk_Result.UNKNOWN;
        case 1:
        case "ACCEPT":
            return ResponseApplySnapshotChunk_Result.ACCEPT;
        case 2:
        case "ABORT":
            return ResponseApplySnapshotChunk_Result.ABORT;
        case 3:
        case "RETRY":
            return ResponseApplySnapshotChunk_Result.RETRY;
        case 4:
        case "RETRY_SNAPSHOT":
            return ResponseApplySnapshotChunk_Result.RETRY_SNAPSHOT;
        case 5:
        case "REJECT_SNAPSHOT":
            return ResponseApplySnapshotChunk_Result.REJECT_SNAPSHOT;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ResponseApplySnapshotChunk_Result.UNRECOGNIZED;
    }
}
function responseApplySnapshotChunk_ResultToJSON(object) {
    switch (object) {
        case ResponseApplySnapshotChunk_Result.UNKNOWN:
            return "UNKNOWN";
        case ResponseApplySnapshotChunk_Result.ACCEPT:
            return "ACCEPT";
        case ResponseApplySnapshotChunk_Result.ABORT:
            return "ABORT";
        case ResponseApplySnapshotChunk_Result.RETRY:
            return "RETRY";
        case ResponseApplySnapshotChunk_Result.RETRY_SNAPSHOT:
            return "RETRY_SNAPSHOT";
        case ResponseApplySnapshotChunk_Result.REJECT_SNAPSHOT:
            return "REJECT_SNAPSHOT";
        case ResponseApplySnapshotChunk_Result.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseRequest() {
    return {
        echo: undefined,
        flush: undefined,
        info: undefined,
        setOption: undefined,
        initChain: undefined,
        query: undefined,
        beginBlock: undefined,
        checkTx: undefined,
        deliverTx: undefined,
        endBlock: undefined,
        commit: undefined,
        listSnapshots: undefined,
        offerSnapshot: undefined,
        loadSnapshotChunk: undefined,
        applySnapshotChunk: undefined,
    };
}
const Request = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.echo !== undefined) {
            RequestEcho.encode(message.echo, writer.uint32(10).fork()).ldelim();
        }
        if (message.flush !== undefined) {
            RequestFlush.encode(message.flush, writer.uint32(18).fork()).ldelim();
        }
        if (message.info !== undefined) {
            RequestInfo.encode(message.info, writer.uint32(26).fork()).ldelim();
        }
        if (message.setOption !== undefined) {
            RequestSetOption.encode(message.setOption, writer.uint32(34).fork()).ldelim();
        }
        if (message.initChain !== undefined) {
            RequestInitChain.encode(message.initChain, writer.uint32(42).fork()).ldelim();
        }
        if (message.query !== undefined) {
            RequestQuery.encode(message.query, writer.uint32(50).fork()).ldelim();
        }
        if (message.beginBlock !== undefined) {
            RequestBeginBlock.encode(message.beginBlock, writer.uint32(58).fork()).ldelim();
        }
        if (message.checkTx !== undefined) {
            RequestCheckTx.encode(message.checkTx, writer.uint32(66).fork()).ldelim();
        }
        if (message.deliverTx !== undefined) {
            RequestDeliverTx.encode(message.deliverTx, writer.uint32(74).fork()).ldelim();
        }
        if (message.endBlock !== undefined) {
            RequestEndBlock.encode(message.endBlock, writer.uint32(82).fork()).ldelim();
        }
        if (message.commit !== undefined) {
            RequestCommit.encode(message.commit, writer.uint32(90).fork()).ldelim();
        }
        if (message.listSnapshots !== undefined) {
            RequestListSnapshots.encode(message.listSnapshots, writer.uint32(98).fork()).ldelim();
        }
        if (message.offerSnapshot !== undefined) {
            RequestOfferSnapshot.encode(message.offerSnapshot, writer.uint32(106).fork()).ldelim();
        }
        if (message.loadSnapshotChunk !== undefined) {
            RequestLoadSnapshotChunk.encode(message.loadSnapshotChunk, writer.uint32(114).fork()).ldelim();
        }
        if (message.applySnapshotChunk !== undefined) {
            RequestApplySnapshotChunk.encode(message.applySnapshotChunk, writer.uint32(122).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.echo = RequestEcho.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.flush = RequestFlush.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.info = RequestInfo.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.setOption = RequestSetOption.decode(reader, reader.uint32());
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.initChain = RequestInitChain.decode(reader, reader.uint32());
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.query = RequestQuery.decode(reader, reader.uint32());
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.beginBlock = RequestBeginBlock.decode(reader, reader.uint32());
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.checkTx = RequestCheckTx.decode(reader, reader.uint32());
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.deliverTx = RequestDeliverTx.decode(reader, reader.uint32());
                    continue;
                case 10:
                    if (tag !== 82) {
                        break;
                    }
                    message.endBlock = RequestEndBlock.decode(reader, reader.uint32());
                    continue;
                case 11:
                    if (tag !== 90) {
                        break;
                    }
                    message.commit = RequestCommit.decode(reader, reader.uint32());
                    continue;
                case 12:
                    if (tag !== 98) {
                        break;
                    }
                    message.listSnapshots = RequestListSnapshots.decode(reader, reader.uint32());
                    continue;
                case 13:
                    if (tag !== 106) {
                        break;
                    }
                    message.offerSnapshot = RequestOfferSnapshot.decode(reader, reader.uint32());
                    continue;
                case 14:
                    if (tag !== 114) {
                        break;
                    }
                    message.loadSnapshotChunk = RequestLoadSnapshotChunk.decode(reader, reader.uint32());
                    continue;
                case 15:
                    if (tag !== 122) {
                        break;
                    }
                    message.applySnapshotChunk = RequestApplySnapshotChunk.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            echo: isSet$m(object.echo) ? RequestEcho.fromJSON(object.echo) : undefined,
            flush: isSet$m(object.flush) ? RequestFlush.fromJSON(object.flush) : undefined,
            info: isSet$m(object.info) ? RequestInfo.fromJSON(object.info) : undefined,
            setOption: isSet$m(object.setOption) ? RequestSetOption.fromJSON(object.setOption) : undefined,
            initChain: isSet$m(object.initChain) ? RequestInitChain.fromJSON(object.initChain) : undefined,
            query: isSet$m(object.query) ? RequestQuery.fromJSON(object.query) : undefined,
            beginBlock: isSet$m(object.beginBlock) ? RequestBeginBlock.fromJSON(object.beginBlock) : undefined,
            checkTx: isSet$m(object.checkTx) ? RequestCheckTx.fromJSON(object.checkTx) : undefined,
            deliverTx: isSet$m(object.deliverTx) ? RequestDeliverTx.fromJSON(object.deliverTx) : undefined,
            endBlock: isSet$m(object.endBlock) ? RequestEndBlock.fromJSON(object.endBlock) : undefined,
            commit: isSet$m(object.commit) ? RequestCommit.fromJSON(object.commit) : undefined,
            listSnapshots: isSet$m(object.listSnapshots) ? RequestListSnapshots.fromJSON(object.listSnapshots) : undefined,
            offerSnapshot: isSet$m(object.offerSnapshot) ? RequestOfferSnapshot.fromJSON(object.offerSnapshot) : undefined,
            loadSnapshotChunk: isSet$m(object.loadSnapshotChunk)
                ? RequestLoadSnapshotChunk.fromJSON(object.loadSnapshotChunk)
                : undefined,
            applySnapshotChunk: isSet$m(object.applySnapshotChunk)
                ? RequestApplySnapshotChunk.fromJSON(object.applySnapshotChunk)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.echo !== undefined) {
            obj.echo = RequestEcho.toJSON(message.echo);
        }
        if (message.flush !== undefined) {
            obj.flush = RequestFlush.toJSON(message.flush);
        }
        if (message.info !== undefined) {
            obj.info = RequestInfo.toJSON(message.info);
        }
        if (message.setOption !== undefined) {
            obj.setOption = RequestSetOption.toJSON(message.setOption);
        }
        if (message.initChain !== undefined) {
            obj.initChain = RequestInitChain.toJSON(message.initChain);
        }
        if (message.query !== undefined) {
            obj.query = RequestQuery.toJSON(message.query);
        }
        if (message.beginBlock !== undefined) {
            obj.beginBlock = RequestBeginBlock.toJSON(message.beginBlock);
        }
        if (message.checkTx !== undefined) {
            obj.checkTx = RequestCheckTx.toJSON(message.checkTx);
        }
        if (message.deliverTx !== undefined) {
            obj.deliverTx = RequestDeliverTx.toJSON(message.deliverTx);
        }
        if (message.endBlock !== undefined) {
            obj.endBlock = RequestEndBlock.toJSON(message.endBlock);
        }
        if (message.commit !== undefined) {
            obj.commit = RequestCommit.toJSON(message.commit);
        }
        if (message.listSnapshots !== undefined) {
            obj.listSnapshots = RequestListSnapshots.toJSON(message.listSnapshots);
        }
        if (message.offerSnapshot !== undefined) {
            obj.offerSnapshot = RequestOfferSnapshot.toJSON(message.offerSnapshot);
        }
        if (message.loadSnapshotChunk !== undefined) {
            obj.loadSnapshotChunk = RequestLoadSnapshotChunk.toJSON(message.loadSnapshotChunk);
        }
        if (message.applySnapshotChunk !== undefined) {
            obj.applySnapshotChunk = RequestApplySnapshotChunk.toJSON(message.applySnapshotChunk);
        }
        return obj;
    },
    create(base) {
        return Request.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRequest();
        message.echo = (object.echo !== undefined && object.echo !== null)
            ? RequestEcho.fromPartial(object.echo)
            : undefined;
        message.flush = (object.flush !== undefined && object.flush !== null)
            ? RequestFlush.fromPartial(object.flush)
            : undefined;
        message.info = (object.info !== undefined && object.info !== null)
            ? RequestInfo.fromPartial(object.info)
            : undefined;
        message.setOption = (object.setOption !== undefined && object.setOption !== null)
            ? RequestSetOption.fromPartial(object.setOption)
            : undefined;
        message.initChain = (object.initChain !== undefined && object.initChain !== null)
            ? RequestInitChain.fromPartial(object.initChain)
            : undefined;
        message.query = (object.query !== undefined && object.query !== null)
            ? RequestQuery.fromPartial(object.query)
            : undefined;
        message.beginBlock = (object.beginBlock !== undefined && object.beginBlock !== null)
            ? RequestBeginBlock.fromPartial(object.beginBlock)
            : undefined;
        message.checkTx = (object.checkTx !== undefined && object.checkTx !== null)
            ? RequestCheckTx.fromPartial(object.checkTx)
            : undefined;
        message.deliverTx = (object.deliverTx !== undefined && object.deliverTx !== null)
            ? RequestDeliverTx.fromPartial(object.deliverTx)
            : undefined;
        message.endBlock = (object.endBlock !== undefined && object.endBlock !== null)
            ? RequestEndBlock.fromPartial(object.endBlock)
            : undefined;
        message.commit = (object.commit !== undefined && object.commit !== null)
            ? RequestCommit.fromPartial(object.commit)
            : undefined;
        message.listSnapshots = (object.listSnapshots !== undefined && object.listSnapshots !== null)
            ? RequestListSnapshots.fromPartial(object.listSnapshots)
            : undefined;
        message.offerSnapshot = (object.offerSnapshot !== undefined && object.offerSnapshot !== null)
            ? RequestOfferSnapshot.fromPartial(object.offerSnapshot)
            : undefined;
        message.loadSnapshotChunk = (object.loadSnapshotChunk !== undefined && object.loadSnapshotChunk !== null)
            ? RequestLoadSnapshotChunk.fromPartial(object.loadSnapshotChunk)
            : undefined;
        message.applySnapshotChunk = (object.applySnapshotChunk !== undefined && object.applySnapshotChunk !== null)
            ? RequestApplySnapshotChunk.fromPartial(object.applySnapshotChunk)
            : undefined;
        return message;
    },
};
function createBaseRequestEcho() {
    return { message: "" };
}
const RequestEcho = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.message !== "") {
            writer.uint32(10).string(message.message);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequestEcho();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.message = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { message: isSet$m(object.message) ? String(object.message) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.message !== "") {
            obj.message = message.message;
        }
        return obj;
    },
    create(base) {
        return RequestEcho.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRequestEcho();
        message.message = object.message ?? "";
        return message;
    },
};
function createBaseRequestFlush() {
    return {};
}
const RequestFlush = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequestFlush();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return RequestFlush.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseRequestFlush();
        return message;
    },
};
function createBaseRequestInfo() {
    return { version: "", blockVersion: 0, p2pVersion: 0 };
}
const RequestInfo = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.version !== "") {
            writer.uint32(10).string(message.version);
        }
        if (message.blockVersion !== 0) {
            writer.uint32(16).uint64(message.blockVersion);
        }
        if (message.p2pVersion !== 0) {
            writer.uint32(24).uint64(message.p2pVersion);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequestInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.version = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.blockVersion = longToNumber$9(reader.uint64());
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.p2pVersion = longToNumber$9(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            version: isSet$m(object.version) ? String(object.version) : "",
            blockVersion: isSet$m(object.blockVersion) ? Number(object.blockVersion) : 0,
            p2pVersion: isSet$m(object.p2pVersion) ? Number(object.p2pVersion) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.version !== "") {
            obj.version = message.version;
        }
        if (message.blockVersion !== 0) {
            obj.blockVersion = Math.round(message.blockVersion);
        }
        if (message.p2pVersion !== 0) {
            obj.p2pVersion = Math.round(message.p2pVersion);
        }
        return obj;
    },
    create(base) {
        return RequestInfo.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRequestInfo();
        message.version = object.version ?? "";
        message.blockVersion = object.blockVersion ?? 0;
        message.p2pVersion = object.p2pVersion ?? 0;
        return message;
    },
};
function createBaseRequestSetOption() {
    return { key: "", value: "" };
}
const RequestSetOption = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequestSetOption();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { key: isSet$m(object.key) ? String(object.key) : "", value: isSet$m(object.value) ? String(object.value) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return RequestSetOption.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRequestSetOption();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        return message;
    },
};
function createBaseRequestInitChain() {
    return {
        time: undefined,
        chainId: "",
        consensusParams: undefined,
        validators: [],
        appStateBytes: new Uint8Array(0),
        initialHeight: 0,
    };
}
const RequestInitChain = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.time !== undefined) {
            Timestamp.encode(toTimestamp$4(message.time), writer.uint32(10).fork()).ldelim();
        }
        if (message.chainId !== "") {
            writer.uint32(18).string(message.chainId);
        }
        if (message.consensusParams !== undefined) {
            ConsensusParams.encode(message.consensusParams, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.validators) {
            ValidatorUpdate.encode(v, writer.uint32(34).fork()).ldelim();
        }
        if (message.appStateBytes.length !== 0) {
            writer.uint32(42).bytes(message.appStateBytes);
        }
        if (message.initialHeight !== 0) {
            writer.uint32(48).int64(message.initialHeight);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequestInitChain();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.time = fromTimestamp$4(Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.chainId = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.consensusParams = ConsensusParams.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.validators.push(ValidatorUpdate.decode(reader, reader.uint32()));
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.appStateBytes = reader.bytes();
                    continue;
                case 6:
                    if (tag !== 48) {
                        break;
                    }
                    message.initialHeight = longToNumber$9(reader.int64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            time: isSet$m(object.time) ? fromJsonTimestamp$4(object.time) : undefined,
            chainId: isSet$m(object.chainId) ? String(object.chainId) : "",
            consensusParams: isSet$m(object.consensusParams) ? ConsensusParams.fromJSON(object.consensusParams) : undefined,
            validators: Array.isArray(object?.validators)
                ? object.validators.map((e) => ValidatorUpdate.fromJSON(e))
                : [],
            appStateBytes: isSet$m(object.appStateBytes) ? bytesFromBase64$3(object.appStateBytes) : new Uint8Array(0),
            initialHeight: isSet$m(object.initialHeight) ? Number(object.initialHeight) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.time !== undefined) {
            obj.time = message.time.toISOString();
        }
        if (message.chainId !== "") {
            obj.chainId = message.chainId;
        }
        if (message.consensusParams !== undefined) {
            obj.consensusParams = ConsensusParams.toJSON(message.consensusParams);
        }
        if (message.validators?.length) {
            obj.validators = message.validators.map((e) => ValidatorUpdate.toJSON(e));
        }
        if (message.appStateBytes.length !== 0) {
            obj.appStateBytes = base64FromBytes$3(message.appStateBytes);
        }
        if (message.initialHeight !== 0) {
            obj.initialHeight = Math.round(message.initialHeight);
        }
        return obj;
    },
    create(base) {
        return RequestInitChain.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRequestInitChain();
        message.time = object.time ?? undefined;
        message.chainId = object.chainId ?? "";
        message.consensusParams = (object.consensusParams !== undefined && object.consensusParams !== null)
            ? ConsensusParams.fromPartial(object.consensusParams)
            : undefined;
        message.validators = object.validators?.map((e) => ValidatorUpdate.fromPartial(e)) || [];
        message.appStateBytes = object.appStateBytes ?? new Uint8Array(0);
        message.initialHeight = object.initialHeight ?? 0;
        return message;
    },
};
function createBaseRequestQuery() {
    return { data: new Uint8Array(0), path: "", height: 0, prove: false };
}
const RequestQuery = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.data.length !== 0) {
            writer.uint32(10).bytes(message.data);
        }
        if (message.path !== "") {
            writer.uint32(18).string(message.path);
        }
        if (message.height !== 0) {
            writer.uint32(24).int64(message.height);
        }
        if (message.prove === true) {
            writer.uint32(32).bool(message.prove);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequestQuery();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.data = reader.bytes();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.path = reader.string();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.height = longToNumber$9(reader.int64());
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.prove = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            data: isSet$m(object.data) ? bytesFromBase64$3(object.data) : new Uint8Array(0),
            path: isSet$m(object.path) ? String(object.path) : "",
            height: isSet$m(object.height) ? Number(object.height) : 0,
            prove: isSet$m(object.prove) ? Boolean(object.prove) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.data.length !== 0) {
            obj.data = base64FromBytes$3(message.data);
        }
        if (message.path !== "") {
            obj.path = message.path;
        }
        if (message.height !== 0) {
            obj.height = Math.round(message.height);
        }
        if (message.prove === true) {
            obj.prove = message.prove;
        }
        return obj;
    },
    create(base) {
        return RequestQuery.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRequestQuery();
        message.data = object.data ?? new Uint8Array(0);
        message.path = object.path ?? "";
        message.height = object.height ?? 0;
        message.prove = object.prove ?? false;
        return message;
    },
};
function createBaseRequestBeginBlock() {
    return { hash: new Uint8Array(0), header: undefined, lastCommitInfo: undefined, byzantineValidators: [] };
}
const RequestBeginBlock = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.hash.length !== 0) {
            writer.uint32(10).bytes(message.hash);
        }
        if (message.header !== undefined) {
            Header.encode(message.header, writer.uint32(18).fork()).ldelim();
        }
        if (message.lastCommitInfo !== undefined) {
            LastCommitInfo.encode(message.lastCommitInfo, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.byzantineValidators) {
            Evidence.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequestBeginBlock();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.hash = reader.bytes();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.header = Header.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.lastCommitInfo = LastCommitInfo.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.byzantineValidators.push(Evidence.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            hash: isSet$m(object.hash) ? bytesFromBase64$3(object.hash) : new Uint8Array(0),
            header: isSet$m(object.header) ? Header.fromJSON(object.header) : undefined,
            lastCommitInfo: isSet$m(object.lastCommitInfo) ? LastCommitInfo.fromJSON(object.lastCommitInfo) : undefined,
            byzantineValidators: Array.isArray(object?.byzantineValidators)
                ? object.byzantineValidators.map((e) => Evidence.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.hash.length !== 0) {
            obj.hash = base64FromBytes$3(message.hash);
        }
        if (message.header !== undefined) {
            obj.header = Header.toJSON(message.header);
        }
        if (message.lastCommitInfo !== undefined) {
            obj.lastCommitInfo = LastCommitInfo.toJSON(message.lastCommitInfo);
        }
        if (message.byzantineValidators?.length) {
            obj.byzantineValidators = message.byzantineValidators.map((e) => Evidence.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return RequestBeginBlock.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRequestBeginBlock();
        message.hash = object.hash ?? new Uint8Array(0);
        message.header = (object.header !== undefined && object.header !== null)
            ? Header.fromPartial(object.header)
            : undefined;
        message.lastCommitInfo = (object.lastCommitInfo !== undefined && object.lastCommitInfo !== null)
            ? LastCommitInfo.fromPartial(object.lastCommitInfo)
            : undefined;
        message.byzantineValidators = object.byzantineValidators?.map((e) => Evidence.fromPartial(e)) || [];
        return message;
    },
};
function createBaseRequestCheckTx() {
    return { tx: new Uint8Array(0), type: 0 };
}
const RequestCheckTx = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.tx.length !== 0) {
            writer.uint32(10).bytes(message.tx);
        }
        if (message.type !== 0) {
            writer.uint32(16).int32(message.type);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequestCheckTx();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.tx = reader.bytes();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.type = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            tx: isSet$m(object.tx) ? bytesFromBase64$3(object.tx) : new Uint8Array(0),
            type: isSet$m(object.type) ? checkTxTypeFromJSON(object.type) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.tx.length !== 0) {
            obj.tx = base64FromBytes$3(message.tx);
        }
        if (message.type !== 0) {
            obj.type = checkTxTypeToJSON(message.type);
        }
        return obj;
    },
    create(base) {
        return RequestCheckTx.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRequestCheckTx();
        message.tx = object.tx ?? new Uint8Array(0);
        message.type = object.type ?? 0;
        return message;
    },
};
function createBaseRequestDeliverTx() {
    return { tx: new Uint8Array(0) };
}
const RequestDeliverTx = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.tx.length !== 0) {
            writer.uint32(10).bytes(message.tx);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequestDeliverTx();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.tx = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { tx: isSet$m(object.tx) ? bytesFromBase64$3(object.tx) : new Uint8Array(0) };
    },
    toJSON(message) {
        const obj = {};
        if (message.tx.length !== 0) {
            obj.tx = base64FromBytes$3(message.tx);
        }
        return obj;
    },
    create(base) {
        return RequestDeliverTx.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRequestDeliverTx();
        message.tx = object.tx ?? new Uint8Array(0);
        return message;
    },
};
function createBaseRequestEndBlock() {
    return { height: 0 };
}
const RequestEndBlock = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.height !== 0) {
            writer.uint32(8).int64(message.height);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequestEndBlock();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.height = longToNumber$9(reader.int64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { height: isSet$m(object.height) ? Number(object.height) : 0 };
    },
    toJSON(message) {
        const obj = {};
        if (message.height !== 0) {
            obj.height = Math.round(message.height);
        }
        return obj;
    },
    create(base) {
        return RequestEndBlock.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRequestEndBlock();
        message.height = object.height ?? 0;
        return message;
    },
};
function createBaseRequestCommit() {
    return {};
}
const RequestCommit = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequestCommit();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return RequestCommit.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseRequestCommit();
        return message;
    },
};
function createBaseRequestListSnapshots() {
    return {};
}
const RequestListSnapshots = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequestListSnapshots();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return RequestListSnapshots.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseRequestListSnapshots();
        return message;
    },
};
function createBaseRequestOfferSnapshot() {
    return { snapshot: undefined, appHash: new Uint8Array(0) };
}
const RequestOfferSnapshot = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.snapshot !== undefined) {
            Snapshot.encode(message.snapshot, writer.uint32(10).fork()).ldelim();
        }
        if (message.appHash.length !== 0) {
            writer.uint32(18).bytes(message.appHash);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequestOfferSnapshot();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.snapshot = Snapshot.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.appHash = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            snapshot: isSet$m(object.snapshot) ? Snapshot.fromJSON(object.snapshot) : undefined,
            appHash: isSet$m(object.appHash) ? bytesFromBase64$3(object.appHash) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.snapshot !== undefined) {
            obj.snapshot = Snapshot.toJSON(message.snapshot);
        }
        if (message.appHash.length !== 0) {
            obj.appHash = base64FromBytes$3(message.appHash);
        }
        return obj;
    },
    create(base) {
        return RequestOfferSnapshot.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRequestOfferSnapshot();
        message.snapshot = (object.snapshot !== undefined && object.snapshot !== null)
            ? Snapshot.fromPartial(object.snapshot)
            : undefined;
        message.appHash = object.appHash ?? new Uint8Array(0);
        return message;
    },
};
function createBaseRequestLoadSnapshotChunk() {
    return { height: 0, format: 0, chunk: 0 };
}
const RequestLoadSnapshotChunk = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.height !== 0) {
            writer.uint32(8).uint64(message.height);
        }
        if (message.format !== 0) {
            writer.uint32(16).uint32(message.format);
        }
        if (message.chunk !== 0) {
            writer.uint32(24).uint32(message.chunk);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequestLoadSnapshotChunk();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.height = longToNumber$9(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.format = reader.uint32();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.chunk = reader.uint32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            height: isSet$m(object.height) ? Number(object.height) : 0,
            format: isSet$m(object.format) ? Number(object.format) : 0,
            chunk: isSet$m(object.chunk) ? Number(object.chunk) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.height !== 0) {
            obj.height = Math.round(message.height);
        }
        if (message.format !== 0) {
            obj.format = Math.round(message.format);
        }
        if (message.chunk !== 0) {
            obj.chunk = Math.round(message.chunk);
        }
        return obj;
    },
    create(base) {
        return RequestLoadSnapshotChunk.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRequestLoadSnapshotChunk();
        message.height = object.height ?? 0;
        message.format = object.format ?? 0;
        message.chunk = object.chunk ?? 0;
        return message;
    },
};
function createBaseRequestApplySnapshotChunk() {
    return { index: 0, chunk: new Uint8Array(0), sender: "" };
}
const RequestApplySnapshotChunk = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.index !== 0) {
            writer.uint32(8).uint32(message.index);
        }
        if (message.chunk.length !== 0) {
            writer.uint32(18).bytes(message.chunk);
        }
        if (message.sender !== "") {
            writer.uint32(26).string(message.sender);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRequestApplySnapshotChunk();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.index = reader.uint32();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.chunk = reader.bytes();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.sender = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            index: isSet$m(object.index) ? Number(object.index) : 0,
            chunk: isSet$m(object.chunk) ? bytesFromBase64$3(object.chunk) : new Uint8Array(0),
            sender: isSet$m(object.sender) ? String(object.sender) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.index !== 0) {
            obj.index = Math.round(message.index);
        }
        if (message.chunk.length !== 0) {
            obj.chunk = base64FromBytes$3(message.chunk);
        }
        if (message.sender !== "") {
            obj.sender = message.sender;
        }
        return obj;
    },
    create(base) {
        return RequestApplySnapshotChunk.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRequestApplySnapshotChunk();
        message.index = object.index ?? 0;
        message.chunk = object.chunk ?? new Uint8Array(0);
        message.sender = object.sender ?? "";
        return message;
    },
};
function createBaseResponse() {
    return {
        exception: undefined,
        echo: undefined,
        flush: undefined,
        info: undefined,
        setOption: undefined,
        initChain: undefined,
        query: undefined,
        beginBlock: undefined,
        checkTx: undefined,
        deliverTx: undefined,
        endBlock: undefined,
        commit: undefined,
        listSnapshots: undefined,
        offerSnapshot: undefined,
        loadSnapshotChunk: undefined,
        applySnapshotChunk: undefined,
    };
}
const Response = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.exception !== undefined) {
            ResponseException.encode(message.exception, writer.uint32(10).fork()).ldelim();
        }
        if (message.echo !== undefined) {
            ResponseEcho.encode(message.echo, writer.uint32(18).fork()).ldelim();
        }
        if (message.flush !== undefined) {
            ResponseFlush.encode(message.flush, writer.uint32(26).fork()).ldelim();
        }
        if (message.info !== undefined) {
            ResponseInfo.encode(message.info, writer.uint32(34).fork()).ldelim();
        }
        if (message.setOption !== undefined) {
            ResponseSetOption.encode(message.setOption, writer.uint32(42).fork()).ldelim();
        }
        if (message.initChain !== undefined) {
            ResponseInitChain.encode(message.initChain, writer.uint32(50).fork()).ldelim();
        }
        if (message.query !== undefined) {
            ResponseQuery.encode(message.query, writer.uint32(58).fork()).ldelim();
        }
        if (message.beginBlock !== undefined) {
            ResponseBeginBlock.encode(message.beginBlock, writer.uint32(66).fork()).ldelim();
        }
        if (message.checkTx !== undefined) {
            ResponseCheckTx.encode(message.checkTx, writer.uint32(74).fork()).ldelim();
        }
        if (message.deliverTx !== undefined) {
            ResponseDeliverTx.encode(message.deliverTx, writer.uint32(82).fork()).ldelim();
        }
        if (message.endBlock !== undefined) {
            ResponseEndBlock.encode(message.endBlock, writer.uint32(90).fork()).ldelim();
        }
        if (message.commit !== undefined) {
            ResponseCommit.encode(message.commit, writer.uint32(98).fork()).ldelim();
        }
        if (message.listSnapshots !== undefined) {
            ResponseListSnapshots.encode(message.listSnapshots, writer.uint32(106).fork()).ldelim();
        }
        if (message.offerSnapshot !== undefined) {
            ResponseOfferSnapshot.encode(message.offerSnapshot, writer.uint32(114).fork()).ldelim();
        }
        if (message.loadSnapshotChunk !== undefined) {
            ResponseLoadSnapshotChunk.encode(message.loadSnapshotChunk, writer.uint32(122).fork()).ldelim();
        }
        if (message.applySnapshotChunk !== undefined) {
            ResponseApplySnapshotChunk.encode(message.applySnapshotChunk, writer.uint32(130).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.exception = ResponseException.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.echo = ResponseEcho.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.flush = ResponseFlush.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.info = ResponseInfo.decode(reader, reader.uint32());
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.setOption = ResponseSetOption.decode(reader, reader.uint32());
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.initChain = ResponseInitChain.decode(reader, reader.uint32());
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.query = ResponseQuery.decode(reader, reader.uint32());
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.beginBlock = ResponseBeginBlock.decode(reader, reader.uint32());
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.checkTx = ResponseCheckTx.decode(reader, reader.uint32());
                    continue;
                case 10:
                    if (tag !== 82) {
                        break;
                    }
                    message.deliverTx = ResponseDeliverTx.decode(reader, reader.uint32());
                    continue;
                case 11:
                    if (tag !== 90) {
                        break;
                    }
                    message.endBlock = ResponseEndBlock.decode(reader, reader.uint32());
                    continue;
                case 12:
                    if (tag !== 98) {
                        break;
                    }
                    message.commit = ResponseCommit.decode(reader, reader.uint32());
                    continue;
                case 13:
                    if (tag !== 106) {
                        break;
                    }
                    message.listSnapshots = ResponseListSnapshots.decode(reader, reader.uint32());
                    continue;
                case 14:
                    if (tag !== 114) {
                        break;
                    }
                    message.offerSnapshot = ResponseOfferSnapshot.decode(reader, reader.uint32());
                    continue;
                case 15:
                    if (tag !== 122) {
                        break;
                    }
                    message.loadSnapshotChunk = ResponseLoadSnapshotChunk.decode(reader, reader.uint32());
                    continue;
                case 16:
                    if (tag !== 130) {
                        break;
                    }
                    message.applySnapshotChunk = ResponseApplySnapshotChunk.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            exception: isSet$m(object.exception) ? ResponseException.fromJSON(object.exception) : undefined,
            echo: isSet$m(object.echo) ? ResponseEcho.fromJSON(object.echo) : undefined,
            flush: isSet$m(object.flush) ? ResponseFlush.fromJSON(object.flush) : undefined,
            info: isSet$m(object.info) ? ResponseInfo.fromJSON(object.info) : undefined,
            setOption: isSet$m(object.setOption) ? ResponseSetOption.fromJSON(object.setOption) : undefined,
            initChain: isSet$m(object.initChain) ? ResponseInitChain.fromJSON(object.initChain) : undefined,
            query: isSet$m(object.query) ? ResponseQuery.fromJSON(object.query) : undefined,
            beginBlock: isSet$m(object.beginBlock) ? ResponseBeginBlock.fromJSON(object.beginBlock) : undefined,
            checkTx: isSet$m(object.checkTx) ? ResponseCheckTx.fromJSON(object.checkTx) : undefined,
            deliverTx: isSet$m(object.deliverTx) ? ResponseDeliverTx.fromJSON(object.deliverTx) : undefined,
            endBlock: isSet$m(object.endBlock) ? ResponseEndBlock.fromJSON(object.endBlock) : undefined,
            commit: isSet$m(object.commit) ? ResponseCommit.fromJSON(object.commit) : undefined,
            listSnapshots: isSet$m(object.listSnapshots) ? ResponseListSnapshots.fromJSON(object.listSnapshots) : undefined,
            offerSnapshot: isSet$m(object.offerSnapshot) ? ResponseOfferSnapshot.fromJSON(object.offerSnapshot) : undefined,
            loadSnapshotChunk: isSet$m(object.loadSnapshotChunk)
                ? ResponseLoadSnapshotChunk.fromJSON(object.loadSnapshotChunk)
                : undefined,
            applySnapshotChunk: isSet$m(object.applySnapshotChunk)
                ? ResponseApplySnapshotChunk.fromJSON(object.applySnapshotChunk)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.exception !== undefined) {
            obj.exception = ResponseException.toJSON(message.exception);
        }
        if (message.echo !== undefined) {
            obj.echo = ResponseEcho.toJSON(message.echo);
        }
        if (message.flush !== undefined) {
            obj.flush = ResponseFlush.toJSON(message.flush);
        }
        if (message.info !== undefined) {
            obj.info = ResponseInfo.toJSON(message.info);
        }
        if (message.setOption !== undefined) {
            obj.setOption = ResponseSetOption.toJSON(message.setOption);
        }
        if (message.initChain !== undefined) {
            obj.initChain = ResponseInitChain.toJSON(message.initChain);
        }
        if (message.query !== undefined) {
            obj.query = ResponseQuery.toJSON(message.query);
        }
        if (message.beginBlock !== undefined) {
            obj.beginBlock = ResponseBeginBlock.toJSON(message.beginBlock);
        }
        if (message.checkTx !== undefined) {
            obj.checkTx = ResponseCheckTx.toJSON(message.checkTx);
        }
        if (message.deliverTx !== undefined) {
            obj.deliverTx = ResponseDeliverTx.toJSON(message.deliverTx);
        }
        if (message.endBlock !== undefined) {
            obj.endBlock = ResponseEndBlock.toJSON(message.endBlock);
        }
        if (message.commit !== undefined) {
            obj.commit = ResponseCommit.toJSON(message.commit);
        }
        if (message.listSnapshots !== undefined) {
            obj.listSnapshots = ResponseListSnapshots.toJSON(message.listSnapshots);
        }
        if (message.offerSnapshot !== undefined) {
            obj.offerSnapshot = ResponseOfferSnapshot.toJSON(message.offerSnapshot);
        }
        if (message.loadSnapshotChunk !== undefined) {
            obj.loadSnapshotChunk = ResponseLoadSnapshotChunk.toJSON(message.loadSnapshotChunk);
        }
        if (message.applySnapshotChunk !== undefined) {
            obj.applySnapshotChunk = ResponseApplySnapshotChunk.toJSON(message.applySnapshotChunk);
        }
        return obj;
    },
    create(base) {
        return Response.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseResponse();
        message.exception = (object.exception !== undefined && object.exception !== null)
            ? ResponseException.fromPartial(object.exception)
            : undefined;
        message.echo = (object.echo !== undefined && object.echo !== null)
            ? ResponseEcho.fromPartial(object.echo)
            : undefined;
        message.flush = (object.flush !== undefined && object.flush !== null)
            ? ResponseFlush.fromPartial(object.flush)
            : undefined;
        message.info = (object.info !== undefined && object.info !== null)
            ? ResponseInfo.fromPartial(object.info)
            : undefined;
        message.setOption = (object.setOption !== undefined && object.setOption !== null)
            ? ResponseSetOption.fromPartial(object.setOption)
            : undefined;
        message.initChain = (object.initChain !== undefined && object.initChain !== null)
            ? ResponseInitChain.fromPartial(object.initChain)
            : undefined;
        message.query = (object.query !== undefined && object.query !== null)
            ? ResponseQuery.fromPartial(object.query)
            : undefined;
        message.beginBlock = (object.beginBlock !== undefined && object.beginBlock !== null)
            ? ResponseBeginBlock.fromPartial(object.beginBlock)
            : undefined;
        message.checkTx = (object.checkTx !== undefined && object.checkTx !== null)
            ? ResponseCheckTx.fromPartial(object.checkTx)
            : undefined;
        message.deliverTx = (object.deliverTx !== undefined && object.deliverTx !== null)
            ? ResponseDeliverTx.fromPartial(object.deliverTx)
            : undefined;
        message.endBlock = (object.endBlock !== undefined && object.endBlock !== null)
            ? ResponseEndBlock.fromPartial(object.endBlock)
            : undefined;
        message.commit = (object.commit !== undefined && object.commit !== null)
            ? ResponseCommit.fromPartial(object.commit)
            : undefined;
        message.listSnapshots = (object.listSnapshots !== undefined && object.listSnapshots !== null)
            ? ResponseListSnapshots.fromPartial(object.listSnapshots)
            : undefined;
        message.offerSnapshot = (object.offerSnapshot !== undefined && object.offerSnapshot !== null)
            ? ResponseOfferSnapshot.fromPartial(object.offerSnapshot)
            : undefined;
        message.loadSnapshotChunk = (object.loadSnapshotChunk !== undefined && object.loadSnapshotChunk !== null)
            ? ResponseLoadSnapshotChunk.fromPartial(object.loadSnapshotChunk)
            : undefined;
        message.applySnapshotChunk = (object.applySnapshotChunk !== undefined && object.applySnapshotChunk !== null)
            ? ResponseApplySnapshotChunk.fromPartial(object.applySnapshotChunk)
            : undefined;
        return message;
    },
};
function createBaseResponseException() {
    return { error: "" };
}
const ResponseException = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.error !== "") {
            writer.uint32(10).string(message.error);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponseException();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.error = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { error: isSet$m(object.error) ? String(object.error) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.error !== "") {
            obj.error = message.error;
        }
        return obj;
    },
    create(base) {
        return ResponseException.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseResponseException();
        message.error = object.error ?? "";
        return message;
    },
};
function createBaseResponseEcho() {
    return { message: "" };
}
const ResponseEcho = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.message !== "") {
            writer.uint32(10).string(message.message);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponseEcho();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.message = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { message: isSet$m(object.message) ? String(object.message) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.message !== "") {
            obj.message = message.message;
        }
        return obj;
    },
    create(base) {
        return ResponseEcho.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseResponseEcho();
        message.message = object.message ?? "";
        return message;
    },
};
function createBaseResponseFlush() {
    return {};
}
const ResponseFlush = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponseFlush();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return ResponseFlush.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseResponseFlush();
        return message;
    },
};
function createBaseResponseInfo() {
    return { data: "", version: "", appVersion: 0, lastBlockHeight: 0, lastBlockAppHash: new Uint8Array(0) };
}
const ResponseInfo = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.data !== "") {
            writer.uint32(10).string(message.data);
        }
        if (message.version !== "") {
            writer.uint32(18).string(message.version);
        }
        if (message.appVersion !== 0) {
            writer.uint32(24).uint64(message.appVersion);
        }
        if (message.lastBlockHeight !== 0) {
            writer.uint32(32).int64(message.lastBlockHeight);
        }
        if (message.lastBlockAppHash.length !== 0) {
            writer.uint32(42).bytes(message.lastBlockAppHash);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponseInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.data = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.version = reader.string();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.appVersion = longToNumber$9(reader.uint64());
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.lastBlockHeight = longToNumber$9(reader.int64());
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.lastBlockAppHash = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            data: isSet$m(object.data) ? String(object.data) : "",
            version: isSet$m(object.version) ? String(object.version) : "",
            appVersion: isSet$m(object.appVersion) ? Number(object.appVersion) : 0,
            lastBlockHeight: isSet$m(object.lastBlockHeight) ? Number(object.lastBlockHeight) : 0,
            lastBlockAppHash: isSet$m(object.lastBlockAppHash) ? bytesFromBase64$3(object.lastBlockAppHash) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.data !== "") {
            obj.data = message.data;
        }
        if (message.version !== "") {
            obj.version = message.version;
        }
        if (message.appVersion !== 0) {
            obj.appVersion = Math.round(message.appVersion);
        }
        if (message.lastBlockHeight !== 0) {
            obj.lastBlockHeight = Math.round(message.lastBlockHeight);
        }
        if (message.lastBlockAppHash.length !== 0) {
            obj.lastBlockAppHash = base64FromBytes$3(message.lastBlockAppHash);
        }
        return obj;
    },
    create(base) {
        return ResponseInfo.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseResponseInfo();
        message.data = object.data ?? "";
        message.version = object.version ?? "";
        message.appVersion = object.appVersion ?? 0;
        message.lastBlockHeight = object.lastBlockHeight ?? 0;
        message.lastBlockAppHash = object.lastBlockAppHash ?? new Uint8Array(0);
        return message;
    },
};
function createBaseResponseSetOption() {
    return { code: 0, log: "", info: "" };
}
const ResponseSetOption = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.code !== 0) {
            writer.uint32(8).uint32(message.code);
        }
        if (message.log !== "") {
            writer.uint32(26).string(message.log);
        }
        if (message.info !== "") {
            writer.uint32(34).string(message.info);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponseSetOption();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.code = reader.uint32();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.log = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.info = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            code: isSet$m(object.code) ? Number(object.code) : 0,
            log: isSet$m(object.log) ? String(object.log) : "",
            info: isSet$m(object.info) ? String(object.info) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.code !== 0) {
            obj.code = Math.round(message.code);
        }
        if (message.log !== "") {
            obj.log = message.log;
        }
        if (message.info !== "") {
            obj.info = message.info;
        }
        return obj;
    },
    create(base) {
        return ResponseSetOption.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseResponseSetOption();
        message.code = object.code ?? 0;
        message.log = object.log ?? "";
        message.info = object.info ?? "";
        return message;
    },
};
function createBaseResponseInitChain() {
    return { consensusParams: undefined, validators: [], appHash: new Uint8Array(0) };
}
const ResponseInitChain = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.consensusParams !== undefined) {
            ConsensusParams.encode(message.consensusParams, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.validators) {
            ValidatorUpdate.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.appHash.length !== 0) {
            writer.uint32(26).bytes(message.appHash);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponseInitChain();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.consensusParams = ConsensusParams.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.validators.push(ValidatorUpdate.decode(reader, reader.uint32()));
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.appHash = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            consensusParams: isSet$m(object.consensusParams) ? ConsensusParams.fromJSON(object.consensusParams) : undefined,
            validators: Array.isArray(object?.validators)
                ? object.validators.map((e) => ValidatorUpdate.fromJSON(e))
                : [],
            appHash: isSet$m(object.appHash) ? bytesFromBase64$3(object.appHash) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.consensusParams !== undefined) {
            obj.consensusParams = ConsensusParams.toJSON(message.consensusParams);
        }
        if (message.validators?.length) {
            obj.validators = message.validators.map((e) => ValidatorUpdate.toJSON(e));
        }
        if (message.appHash.length !== 0) {
            obj.appHash = base64FromBytes$3(message.appHash);
        }
        return obj;
    },
    create(base) {
        return ResponseInitChain.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseResponseInitChain();
        message.consensusParams = (object.consensusParams !== undefined && object.consensusParams !== null)
            ? ConsensusParams.fromPartial(object.consensusParams)
            : undefined;
        message.validators = object.validators?.map((e) => ValidatorUpdate.fromPartial(e)) || [];
        message.appHash = object.appHash ?? new Uint8Array(0);
        return message;
    },
};
function createBaseResponseQuery() {
    return {
        code: 0,
        log: "",
        info: "",
        index: 0,
        key: new Uint8Array(0),
        value: new Uint8Array(0),
        proofOps: undefined,
        height: 0,
        codespace: "",
    };
}
const ResponseQuery = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.code !== 0) {
            writer.uint32(8).uint32(message.code);
        }
        if (message.log !== "") {
            writer.uint32(26).string(message.log);
        }
        if (message.info !== "") {
            writer.uint32(34).string(message.info);
        }
        if (message.index !== 0) {
            writer.uint32(40).int64(message.index);
        }
        if (message.key.length !== 0) {
            writer.uint32(50).bytes(message.key);
        }
        if (message.value.length !== 0) {
            writer.uint32(58).bytes(message.value);
        }
        if (message.proofOps !== undefined) {
            ProofOps.encode(message.proofOps, writer.uint32(66).fork()).ldelim();
        }
        if (message.height !== 0) {
            writer.uint32(72).int64(message.height);
        }
        if (message.codespace !== "") {
            writer.uint32(82).string(message.codespace);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponseQuery();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.code = reader.uint32();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.log = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.info = reader.string();
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.index = longToNumber$9(reader.int64());
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.key = reader.bytes();
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.value = reader.bytes();
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.proofOps = ProofOps.decode(reader, reader.uint32());
                    continue;
                case 9:
                    if (tag !== 72) {
                        break;
                    }
                    message.height = longToNumber$9(reader.int64());
                    continue;
                case 10:
                    if (tag !== 82) {
                        break;
                    }
                    message.codespace = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            code: isSet$m(object.code) ? Number(object.code) : 0,
            log: isSet$m(object.log) ? String(object.log) : "",
            info: isSet$m(object.info) ? String(object.info) : "",
            index: isSet$m(object.index) ? Number(object.index) : 0,
            key: isSet$m(object.key) ? bytesFromBase64$3(object.key) : new Uint8Array(0),
            value: isSet$m(object.value) ? bytesFromBase64$3(object.value) : new Uint8Array(0),
            proofOps: isSet$m(object.proofOps) ? ProofOps.fromJSON(object.proofOps) : undefined,
            height: isSet$m(object.height) ? Number(object.height) : 0,
            codespace: isSet$m(object.codespace) ? String(object.codespace) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.code !== 0) {
            obj.code = Math.round(message.code);
        }
        if (message.log !== "") {
            obj.log = message.log;
        }
        if (message.info !== "") {
            obj.info = message.info;
        }
        if (message.index !== 0) {
            obj.index = Math.round(message.index);
        }
        if (message.key.length !== 0) {
            obj.key = base64FromBytes$3(message.key);
        }
        if (message.value.length !== 0) {
            obj.value = base64FromBytes$3(message.value);
        }
        if (message.proofOps !== undefined) {
            obj.proofOps = ProofOps.toJSON(message.proofOps);
        }
        if (message.height !== 0) {
            obj.height = Math.round(message.height);
        }
        if (message.codespace !== "") {
            obj.codespace = message.codespace;
        }
        return obj;
    },
    create(base) {
        return ResponseQuery.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseResponseQuery();
        message.code = object.code ?? 0;
        message.log = object.log ?? "";
        message.info = object.info ?? "";
        message.index = object.index ?? 0;
        message.key = object.key ?? new Uint8Array(0);
        message.value = object.value ?? new Uint8Array(0);
        message.proofOps = (object.proofOps !== undefined && object.proofOps !== null)
            ? ProofOps.fromPartial(object.proofOps)
            : undefined;
        message.height = object.height ?? 0;
        message.codespace = object.codespace ?? "";
        return message;
    },
};
function createBaseResponseBeginBlock() {
    return { events: [] };
}
const ResponseBeginBlock = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.events) {
            Event.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponseBeginBlock();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.events.push(Event.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { events: Array.isArray(object?.events) ? object.events.map((e) => Event.fromJSON(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.events?.length) {
            obj.events = message.events.map((e) => Event.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return ResponseBeginBlock.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseResponseBeginBlock();
        message.events = object.events?.map((e) => Event.fromPartial(e)) || [];
        return message;
    },
};
function createBaseResponseCheckTx() {
    return {
        code: 0,
        data: new Uint8Array(0),
        log: "",
        info: "",
        gasWanted: 0,
        gasUsed: 0,
        events: [],
        codespace: "",
        sender: "",
        priority: 0,
        mempoolError: "",
    };
}
const ResponseCheckTx = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.code !== 0) {
            writer.uint32(8).uint32(message.code);
        }
        if (message.data.length !== 0) {
            writer.uint32(18).bytes(message.data);
        }
        if (message.log !== "") {
            writer.uint32(26).string(message.log);
        }
        if (message.info !== "") {
            writer.uint32(34).string(message.info);
        }
        if (message.gasWanted !== 0) {
            writer.uint32(40).int64(message.gasWanted);
        }
        if (message.gasUsed !== 0) {
            writer.uint32(48).int64(message.gasUsed);
        }
        for (const v of message.events) {
            Event.encode(v, writer.uint32(58).fork()).ldelim();
        }
        if (message.codespace !== "") {
            writer.uint32(66).string(message.codespace);
        }
        if (message.sender !== "") {
            writer.uint32(74).string(message.sender);
        }
        if (message.priority !== 0) {
            writer.uint32(80).int64(message.priority);
        }
        if (message.mempoolError !== "") {
            writer.uint32(90).string(message.mempoolError);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponseCheckTx();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.code = reader.uint32();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.data = reader.bytes();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.log = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.info = reader.string();
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.gasWanted = longToNumber$9(reader.int64());
                    continue;
                case 6:
                    if (tag !== 48) {
                        break;
                    }
                    message.gasUsed = longToNumber$9(reader.int64());
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.events.push(Event.decode(reader, reader.uint32()));
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.codespace = reader.string();
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.sender = reader.string();
                    continue;
                case 10:
                    if (tag !== 80) {
                        break;
                    }
                    message.priority = longToNumber$9(reader.int64());
                    continue;
                case 11:
                    if (tag !== 90) {
                        break;
                    }
                    message.mempoolError = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            code: isSet$m(object.code) ? Number(object.code) : 0,
            data: isSet$m(object.data) ? bytesFromBase64$3(object.data) : new Uint8Array(0),
            log: isSet$m(object.log) ? String(object.log) : "",
            info: isSet$m(object.info) ? String(object.info) : "",
            gasWanted: isSet$m(object.gas_wanted) ? Number(object.gas_wanted) : 0,
            gasUsed: isSet$m(object.gas_used) ? Number(object.gas_used) : 0,
            events: Array.isArray(object?.events) ? object.events.map((e) => Event.fromJSON(e)) : [],
            codespace: isSet$m(object.codespace) ? String(object.codespace) : "",
            sender: isSet$m(object.sender) ? String(object.sender) : "",
            priority: isSet$m(object.priority) ? Number(object.priority) : 0,
            mempoolError: isSet$m(object.mempoolError) ? String(object.mempoolError) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.code !== 0) {
            obj.code = Math.round(message.code);
        }
        if (message.data.length !== 0) {
            obj.data = base64FromBytes$3(message.data);
        }
        if (message.log !== "") {
            obj.log = message.log;
        }
        if (message.info !== "") {
            obj.info = message.info;
        }
        if (message.gasWanted !== 0) {
            obj.gas_wanted = Math.round(message.gasWanted);
        }
        if (message.gasUsed !== 0) {
            obj.gas_used = Math.round(message.gasUsed);
        }
        if (message.events?.length) {
            obj.events = message.events.map((e) => Event.toJSON(e));
        }
        if (message.codespace !== "") {
            obj.codespace = message.codespace;
        }
        if (message.sender !== "") {
            obj.sender = message.sender;
        }
        if (message.priority !== 0) {
            obj.priority = Math.round(message.priority);
        }
        if (message.mempoolError !== "") {
            obj.mempoolError = message.mempoolError;
        }
        return obj;
    },
    create(base) {
        return ResponseCheckTx.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseResponseCheckTx();
        message.code = object.code ?? 0;
        message.data = object.data ?? new Uint8Array(0);
        message.log = object.log ?? "";
        message.info = object.info ?? "";
        message.gasWanted = object.gasWanted ?? 0;
        message.gasUsed = object.gasUsed ?? 0;
        message.events = object.events?.map((e) => Event.fromPartial(e)) || [];
        message.codespace = object.codespace ?? "";
        message.sender = object.sender ?? "";
        message.priority = object.priority ?? 0;
        message.mempoolError = object.mempoolError ?? "";
        return message;
    },
};
function createBaseResponseDeliverTx() {
    return { code: 0, data: new Uint8Array(0), log: "", info: "", gasWanted: 0, gasUsed: 0, events: [], codespace: "" };
}
const ResponseDeliverTx = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.code !== 0) {
            writer.uint32(8).uint32(message.code);
        }
        if (message.data.length !== 0) {
            writer.uint32(18).bytes(message.data);
        }
        if (message.log !== "") {
            writer.uint32(26).string(message.log);
        }
        if (message.info !== "") {
            writer.uint32(34).string(message.info);
        }
        if (message.gasWanted !== 0) {
            writer.uint32(40).int64(message.gasWanted);
        }
        if (message.gasUsed !== 0) {
            writer.uint32(48).int64(message.gasUsed);
        }
        for (const v of message.events) {
            Event.encode(v, writer.uint32(58).fork()).ldelim();
        }
        if (message.codespace !== "") {
            writer.uint32(66).string(message.codespace);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponseDeliverTx();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.code = reader.uint32();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.data = reader.bytes();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.log = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.info = reader.string();
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.gasWanted = longToNumber$9(reader.int64());
                    continue;
                case 6:
                    if (tag !== 48) {
                        break;
                    }
                    message.gasUsed = longToNumber$9(reader.int64());
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.events.push(Event.decode(reader, reader.uint32()));
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.codespace = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            code: isSet$m(object.code) ? Number(object.code) : 0,
            data: isSet$m(object.data) ? bytesFromBase64$3(object.data) : new Uint8Array(0),
            log: isSet$m(object.log) ? String(object.log) : "",
            info: isSet$m(object.info) ? String(object.info) : "",
            gasWanted: isSet$m(object.gas_wanted) ? Number(object.gas_wanted) : 0,
            gasUsed: isSet$m(object.gas_used) ? Number(object.gas_used) : 0,
            events: Array.isArray(object?.events) ? object.events.map((e) => Event.fromJSON(e)) : [],
            codespace: isSet$m(object.codespace) ? String(object.codespace) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.code !== 0) {
            obj.code = Math.round(message.code);
        }
        if (message.data.length !== 0) {
            obj.data = base64FromBytes$3(message.data);
        }
        if (message.log !== "") {
            obj.log = message.log;
        }
        if (message.info !== "") {
            obj.info = message.info;
        }
        if (message.gasWanted !== 0) {
            obj.gas_wanted = Math.round(message.gasWanted);
        }
        if (message.gasUsed !== 0) {
            obj.gas_used = Math.round(message.gasUsed);
        }
        if (message.events?.length) {
            obj.events = message.events.map((e) => Event.toJSON(e));
        }
        if (message.codespace !== "") {
            obj.codespace = message.codespace;
        }
        return obj;
    },
    create(base) {
        return ResponseDeliverTx.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseResponseDeliverTx();
        message.code = object.code ?? 0;
        message.data = object.data ?? new Uint8Array(0);
        message.log = object.log ?? "";
        message.info = object.info ?? "";
        message.gasWanted = object.gasWanted ?? 0;
        message.gasUsed = object.gasUsed ?? 0;
        message.events = object.events?.map((e) => Event.fromPartial(e)) || [];
        message.codespace = object.codespace ?? "";
        return message;
    },
};
function createBaseResponseEndBlock() {
    return { validatorUpdates: [], consensusParamUpdates: undefined, events: [] };
}
const ResponseEndBlock = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.validatorUpdates) {
            ValidatorUpdate.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.consensusParamUpdates !== undefined) {
            ConsensusParams.encode(message.consensusParamUpdates, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.events) {
            Event.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponseEndBlock();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.validatorUpdates.push(ValidatorUpdate.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.consensusParamUpdates = ConsensusParams.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.events.push(Event.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            validatorUpdates: Array.isArray(object?.validatorUpdates)
                ? object.validatorUpdates.map((e) => ValidatorUpdate.fromJSON(e))
                : [],
            consensusParamUpdates: isSet$m(object.consensusParamUpdates)
                ? ConsensusParams.fromJSON(object.consensusParamUpdates)
                : undefined,
            events: Array.isArray(object?.events) ? object.events.map((e) => Event.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.validatorUpdates?.length) {
            obj.validatorUpdates = message.validatorUpdates.map((e) => ValidatorUpdate.toJSON(e));
        }
        if (message.consensusParamUpdates !== undefined) {
            obj.consensusParamUpdates = ConsensusParams.toJSON(message.consensusParamUpdates);
        }
        if (message.events?.length) {
            obj.events = message.events.map((e) => Event.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return ResponseEndBlock.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseResponseEndBlock();
        message.validatorUpdates = object.validatorUpdates?.map((e) => ValidatorUpdate.fromPartial(e)) || [];
        message.consensusParamUpdates =
            (object.consensusParamUpdates !== undefined && object.consensusParamUpdates !== null)
                ? ConsensusParams.fromPartial(object.consensusParamUpdates)
                : undefined;
        message.events = object.events?.map((e) => Event.fromPartial(e)) || [];
        return message;
    },
};
function createBaseResponseCommit() {
    return { data: new Uint8Array(0), retainHeight: 0 };
}
const ResponseCommit = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.data.length !== 0) {
            writer.uint32(18).bytes(message.data);
        }
        if (message.retainHeight !== 0) {
            writer.uint32(24).int64(message.retainHeight);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponseCommit();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.data = reader.bytes();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.retainHeight = longToNumber$9(reader.int64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            data: isSet$m(object.data) ? bytesFromBase64$3(object.data) : new Uint8Array(0),
            retainHeight: isSet$m(object.retainHeight) ? Number(object.retainHeight) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.data.length !== 0) {
            obj.data = base64FromBytes$3(message.data);
        }
        if (message.retainHeight !== 0) {
            obj.retainHeight = Math.round(message.retainHeight);
        }
        return obj;
    },
    create(base) {
        return ResponseCommit.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseResponseCommit();
        message.data = object.data ?? new Uint8Array(0);
        message.retainHeight = object.retainHeight ?? 0;
        return message;
    },
};
function createBaseResponseListSnapshots() {
    return { snapshots: [] };
}
const ResponseListSnapshots = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.snapshots) {
            Snapshot.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponseListSnapshots();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.snapshots.push(Snapshot.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            snapshots: Array.isArray(object?.snapshots) ? object.snapshots.map((e) => Snapshot.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.snapshots?.length) {
            obj.snapshots = message.snapshots.map((e) => Snapshot.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return ResponseListSnapshots.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseResponseListSnapshots();
        message.snapshots = object.snapshots?.map((e) => Snapshot.fromPartial(e)) || [];
        return message;
    },
};
function createBaseResponseOfferSnapshot() {
    return { result: 0 };
}
const ResponseOfferSnapshot = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.result !== 0) {
            writer.uint32(8).int32(message.result);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponseOfferSnapshot();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.result = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { result: isSet$m(object.result) ? responseOfferSnapshot_ResultFromJSON(object.result) : 0 };
    },
    toJSON(message) {
        const obj = {};
        if (message.result !== 0) {
            obj.result = responseOfferSnapshot_ResultToJSON(message.result);
        }
        return obj;
    },
    create(base) {
        return ResponseOfferSnapshot.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseResponseOfferSnapshot();
        message.result = object.result ?? 0;
        return message;
    },
};
function createBaseResponseLoadSnapshotChunk() {
    return { chunk: new Uint8Array(0) };
}
const ResponseLoadSnapshotChunk = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.chunk.length !== 0) {
            writer.uint32(10).bytes(message.chunk);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponseLoadSnapshotChunk();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.chunk = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { chunk: isSet$m(object.chunk) ? bytesFromBase64$3(object.chunk) : new Uint8Array(0) };
    },
    toJSON(message) {
        const obj = {};
        if (message.chunk.length !== 0) {
            obj.chunk = base64FromBytes$3(message.chunk);
        }
        return obj;
    },
    create(base) {
        return ResponseLoadSnapshotChunk.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseResponseLoadSnapshotChunk();
        message.chunk = object.chunk ?? new Uint8Array(0);
        return message;
    },
};
function createBaseResponseApplySnapshotChunk() {
    return { result: 0, refetchChunks: [], rejectSenders: [] };
}
const ResponseApplySnapshotChunk = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.result !== 0) {
            writer.uint32(8).int32(message.result);
        }
        writer.uint32(18).fork();
        for (const v of message.refetchChunks) {
            writer.uint32(v);
        }
        writer.ldelim();
        for (const v of message.rejectSenders) {
            writer.uint32(26).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponseApplySnapshotChunk();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.result = reader.int32();
                    continue;
                case 2:
                    if (tag === 16) {
                        message.refetchChunks.push(reader.uint32());
                        continue;
                    }
                    if (tag === 18) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.refetchChunks.push(reader.uint32());
                        }
                        continue;
                    }
                    break;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.rejectSenders.push(reader.string());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            result: isSet$m(object.result) ? responseApplySnapshotChunk_ResultFromJSON(object.result) : 0,
            refetchChunks: Array.isArray(object?.refetchChunks) ? object.refetchChunks.map((e) => Number(e)) : [],
            rejectSenders: Array.isArray(object?.rejectSenders) ? object.rejectSenders.map((e) => String(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.result !== 0) {
            obj.result = responseApplySnapshotChunk_ResultToJSON(message.result);
        }
        if (message.refetchChunks?.length) {
            obj.refetchChunks = message.refetchChunks.map((e) => Math.round(e));
        }
        if (message.rejectSenders?.length) {
            obj.rejectSenders = message.rejectSenders;
        }
        return obj;
    },
    create(base) {
        return ResponseApplySnapshotChunk.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseResponseApplySnapshotChunk();
        message.result = object.result ?? 0;
        message.refetchChunks = object.refetchChunks?.map((e) => e) || [];
        message.rejectSenders = object.rejectSenders?.map((e) => e) || [];
        return message;
    },
};
function createBaseConsensusParams() {
    return { block: undefined, evidence: undefined, validator: undefined, version: undefined };
}
const ConsensusParams = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.block !== undefined) {
            BlockParams.encode(message.block, writer.uint32(10).fork()).ldelim();
        }
        if (message.evidence !== undefined) {
            EvidenceParams.encode(message.evidence, writer.uint32(18).fork()).ldelim();
        }
        if (message.validator !== undefined) {
            ValidatorParams.encode(message.validator, writer.uint32(26).fork()).ldelim();
        }
        if (message.version !== undefined) {
            VersionParams.encode(message.version, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseConsensusParams();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.block = BlockParams.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.evidence = EvidenceParams.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.validator = ValidatorParams.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.version = VersionParams.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            block: isSet$m(object.block) ? BlockParams.fromJSON(object.block) : undefined,
            evidence: isSet$m(object.evidence) ? EvidenceParams.fromJSON(object.evidence) : undefined,
            validator: isSet$m(object.validator) ? ValidatorParams.fromJSON(object.validator) : undefined,
            version: isSet$m(object.version) ? VersionParams.fromJSON(object.version) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.block !== undefined) {
            obj.block = BlockParams.toJSON(message.block);
        }
        if (message.evidence !== undefined) {
            obj.evidence = EvidenceParams.toJSON(message.evidence);
        }
        if (message.validator !== undefined) {
            obj.validator = ValidatorParams.toJSON(message.validator);
        }
        if (message.version !== undefined) {
            obj.version = VersionParams.toJSON(message.version);
        }
        return obj;
    },
    create(base) {
        return ConsensusParams.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseConsensusParams();
        message.block = (object.block !== undefined && object.block !== null)
            ? BlockParams.fromPartial(object.block)
            : undefined;
        message.evidence = (object.evidence !== undefined && object.evidence !== null)
            ? EvidenceParams.fromPartial(object.evidence)
            : undefined;
        message.validator = (object.validator !== undefined && object.validator !== null)
            ? ValidatorParams.fromPartial(object.validator)
            : undefined;
        message.version = (object.version !== undefined && object.version !== null)
            ? VersionParams.fromPartial(object.version)
            : undefined;
        return message;
    },
};
function createBaseBlockParams() {
    return { maxBytes: 0, maxGas: 0 };
}
const BlockParams = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.maxBytes !== 0) {
            writer.uint32(8).int64(message.maxBytes);
        }
        if (message.maxGas !== 0) {
            writer.uint32(16).int64(message.maxGas);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBlockParams();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.maxBytes = longToNumber$9(reader.int64());
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.maxGas = longToNumber$9(reader.int64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            maxBytes: isSet$m(object.maxBytes) ? Number(object.maxBytes) : 0,
            maxGas: isSet$m(object.maxGas) ? Number(object.maxGas) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.maxBytes !== 0) {
            obj.maxBytes = Math.round(message.maxBytes);
        }
        if (message.maxGas !== 0) {
            obj.maxGas = Math.round(message.maxGas);
        }
        return obj;
    },
    create(base) {
        return BlockParams.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseBlockParams();
        message.maxBytes = object.maxBytes ?? 0;
        message.maxGas = object.maxGas ?? 0;
        return message;
    },
};
function createBaseLastCommitInfo() {
    return { round: 0, votes: [] };
}
const LastCommitInfo = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.round !== 0) {
            writer.uint32(8).int32(message.round);
        }
        for (const v of message.votes) {
            VoteInfo.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLastCommitInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.round = reader.int32();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.votes.push(VoteInfo.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            round: isSet$m(object.round) ? Number(object.round) : 0,
            votes: Array.isArray(object?.votes) ? object.votes.map((e) => VoteInfo.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.round !== 0) {
            obj.round = Math.round(message.round);
        }
        if (message.votes?.length) {
            obj.votes = message.votes.map((e) => VoteInfo.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return LastCommitInfo.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseLastCommitInfo();
        message.round = object.round ?? 0;
        message.votes = object.votes?.map((e) => VoteInfo.fromPartial(e)) || [];
        return message;
    },
};
function createBaseEvent() {
    return { type: "", attributes: [] };
}
const Event = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.type !== "") {
            writer.uint32(10).string(message.type);
        }
        for (const v of message.attributes) {
            EventAttribute.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEvent();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.type = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.attributes.push(EventAttribute.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            type: isSet$m(object.type) ? String(object.type) : "",
            attributes: Array.isArray(object?.attributes)
                ? object.attributes.map((e) => EventAttribute.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.type !== "") {
            obj.type = message.type;
        }
        if (message.attributes?.length) {
            obj.attributes = message.attributes.map((e) => EventAttribute.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return Event.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseEvent();
        message.type = object.type ?? "";
        message.attributes = object.attributes?.map((e) => EventAttribute.fromPartial(e)) || [];
        return message;
    },
};
function createBaseEventAttribute() {
    return { key: new Uint8Array(0), value: new Uint8Array(0), index: false };
}
const EventAttribute = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.key.length !== 0) {
            writer.uint32(10).bytes(message.key);
        }
        if (message.value.length !== 0) {
            writer.uint32(18).bytes(message.value);
        }
        if (message.index === true) {
            writer.uint32(24).bool(message.index);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEventAttribute();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.bytes();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.bytes();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.index = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet$m(object.key) ? bytesFromBase64$3(object.key) : new Uint8Array(0),
            value: isSet$m(object.value) ? bytesFromBase64$3(object.value) : new Uint8Array(0),
            index: isSet$m(object.index) ? Boolean(object.index) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key.length !== 0) {
            obj.key = base64FromBytes$3(message.key);
        }
        if (message.value.length !== 0) {
            obj.value = base64FromBytes$3(message.value);
        }
        if (message.index === true) {
            obj.index = message.index;
        }
        return obj;
    },
    create(base) {
        return EventAttribute.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseEventAttribute();
        message.key = object.key ?? new Uint8Array(0);
        message.value = object.value ?? new Uint8Array(0);
        message.index = object.index ?? false;
        return message;
    },
};
function createBaseTxResult() {
    return { height: 0, index: 0, tx: new Uint8Array(0), result: undefined };
}
const TxResult = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.height !== 0) {
            writer.uint32(8).int64(message.height);
        }
        if (message.index !== 0) {
            writer.uint32(16).uint32(message.index);
        }
        if (message.tx.length !== 0) {
            writer.uint32(26).bytes(message.tx);
        }
        if (message.result !== undefined) {
            ResponseDeliverTx.encode(message.result, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTxResult();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.height = longToNumber$9(reader.int64());
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.index = reader.uint32();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.tx = reader.bytes();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.result = ResponseDeliverTx.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            height: isSet$m(object.height) ? Number(object.height) : 0,
            index: isSet$m(object.index) ? Number(object.index) : 0,
            tx: isSet$m(object.tx) ? bytesFromBase64$3(object.tx) : new Uint8Array(0),
            result: isSet$m(object.result) ? ResponseDeliverTx.fromJSON(object.result) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.height !== 0) {
            obj.height = Math.round(message.height);
        }
        if (message.index !== 0) {
            obj.index = Math.round(message.index);
        }
        if (message.tx.length !== 0) {
            obj.tx = base64FromBytes$3(message.tx);
        }
        if (message.result !== undefined) {
            obj.result = ResponseDeliverTx.toJSON(message.result);
        }
        return obj;
    },
    create(base) {
        return TxResult.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTxResult();
        message.height = object.height ?? 0;
        message.index = object.index ?? 0;
        message.tx = object.tx ?? new Uint8Array(0);
        message.result = (object.result !== undefined && object.result !== null)
            ? ResponseDeliverTx.fromPartial(object.result)
            : undefined;
        return message;
    },
};
function createBaseValidator$1() {
    return { address: new Uint8Array(0), power: 0 };
}
const Validator$1 = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.address.length !== 0) {
            writer.uint32(10).bytes(message.address);
        }
        if (message.power !== 0) {
            writer.uint32(24).int64(message.power);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidator$1();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.address = reader.bytes();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.power = longToNumber$9(reader.int64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            address: isSet$m(object.address) ? bytesFromBase64$3(object.address) : new Uint8Array(0),
            power: isSet$m(object.power) ? Number(object.power) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.address.length !== 0) {
            obj.address = base64FromBytes$3(message.address);
        }
        if (message.power !== 0) {
            obj.power = Math.round(message.power);
        }
        return obj;
    },
    create(base) {
        return Validator$1.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseValidator$1();
        message.address = object.address ?? new Uint8Array(0);
        message.power = object.power ?? 0;
        return message;
    },
};
function createBaseValidatorUpdate() {
    return { pubKey: undefined, power: 0 };
}
const ValidatorUpdate = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.pubKey !== undefined) {
            PublicKey.encode(message.pubKey, writer.uint32(10).fork()).ldelim();
        }
        if (message.power !== 0) {
            writer.uint32(16).int64(message.power);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidatorUpdate();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.pubKey = PublicKey.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.power = longToNumber$9(reader.int64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            pubKey: isSet$m(object.pubKey) ? PublicKey.fromJSON(object.pubKey) : undefined,
            power: isSet$m(object.power) ? Number(object.power) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.pubKey !== undefined) {
            obj.pubKey = PublicKey.toJSON(message.pubKey);
        }
        if (message.power !== 0) {
            obj.power = Math.round(message.power);
        }
        return obj;
    },
    create(base) {
        return ValidatorUpdate.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseValidatorUpdate();
        message.pubKey = (object.pubKey !== undefined && object.pubKey !== null)
            ? PublicKey.fromPartial(object.pubKey)
            : undefined;
        message.power = object.power ?? 0;
        return message;
    },
};
function createBaseVoteInfo() {
    return { validator: undefined, signedLastBlock: false };
}
const VoteInfo = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.validator !== undefined) {
            Validator$1.encode(message.validator, writer.uint32(10).fork()).ldelim();
        }
        if (message.signedLastBlock === true) {
            writer.uint32(16).bool(message.signedLastBlock);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVoteInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.validator = Validator$1.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.signedLastBlock = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            validator: isSet$m(object.validator) ? Validator$1.fromJSON(object.validator) : undefined,
            signedLastBlock: isSet$m(object.signedLastBlock) ? Boolean(object.signedLastBlock) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.validator !== undefined) {
            obj.validator = Validator$1.toJSON(message.validator);
        }
        if (message.signedLastBlock === true) {
            obj.signedLastBlock = message.signedLastBlock;
        }
        return obj;
    },
    create(base) {
        return VoteInfo.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseVoteInfo();
        message.validator = (object.validator !== undefined && object.validator !== null)
            ? Validator$1.fromPartial(object.validator)
            : undefined;
        message.signedLastBlock = object.signedLastBlock ?? false;
        return message;
    },
};
function createBaseEvidence() {
    return { type: 0, validator: undefined, height: 0, time: undefined, totalVotingPower: 0 };
}
const Evidence = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.type !== 0) {
            writer.uint32(8).int32(message.type);
        }
        if (message.validator !== undefined) {
            Validator$1.encode(message.validator, writer.uint32(18).fork()).ldelim();
        }
        if (message.height !== 0) {
            writer.uint32(24).int64(message.height);
        }
        if (message.time !== undefined) {
            Timestamp.encode(toTimestamp$4(message.time), writer.uint32(34).fork()).ldelim();
        }
        if (message.totalVotingPower !== 0) {
            writer.uint32(40).int64(message.totalVotingPower);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEvidence();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.type = reader.int32();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.validator = Validator$1.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.height = longToNumber$9(reader.int64());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.time = fromTimestamp$4(Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.totalVotingPower = longToNumber$9(reader.int64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            type: isSet$m(object.type) ? evidenceTypeFromJSON(object.type) : 0,
            validator: isSet$m(object.validator) ? Validator$1.fromJSON(object.validator) : undefined,
            height: isSet$m(object.height) ? Number(object.height) : 0,
            time: isSet$m(object.time) ? fromJsonTimestamp$4(object.time) : undefined,
            totalVotingPower: isSet$m(object.totalVotingPower) ? Number(object.totalVotingPower) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.type !== 0) {
            obj.type = evidenceTypeToJSON(message.type);
        }
        if (message.validator !== undefined) {
            obj.validator = Validator$1.toJSON(message.validator);
        }
        if (message.height !== 0) {
            obj.height = Math.round(message.height);
        }
        if (message.time !== undefined) {
            obj.time = message.time.toISOString();
        }
        if (message.totalVotingPower !== 0) {
            obj.totalVotingPower = Math.round(message.totalVotingPower);
        }
        return obj;
    },
    create(base) {
        return Evidence.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseEvidence();
        message.type = object.type ?? 0;
        message.validator = (object.validator !== undefined && object.validator !== null)
            ? Validator$1.fromPartial(object.validator)
            : undefined;
        message.height = object.height ?? 0;
        message.time = object.time ?? undefined;
        message.totalVotingPower = object.totalVotingPower ?? 0;
        return message;
    },
};
function createBaseSnapshot() {
    return { height: 0, format: 0, chunks: 0, hash: new Uint8Array(0), metadata: new Uint8Array(0) };
}
const Snapshot = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.height !== 0) {
            writer.uint32(8).uint64(message.height);
        }
        if (message.format !== 0) {
            writer.uint32(16).uint32(message.format);
        }
        if (message.chunks !== 0) {
            writer.uint32(24).uint32(message.chunks);
        }
        if (message.hash.length !== 0) {
            writer.uint32(34).bytes(message.hash);
        }
        if (message.metadata.length !== 0) {
            writer.uint32(42).bytes(message.metadata);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSnapshot();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.height = longToNumber$9(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.format = reader.uint32();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.chunks = reader.uint32();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.hash = reader.bytes();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.metadata = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            height: isSet$m(object.height) ? Number(object.height) : 0,
            format: isSet$m(object.format) ? Number(object.format) : 0,
            chunks: isSet$m(object.chunks) ? Number(object.chunks) : 0,
            hash: isSet$m(object.hash) ? bytesFromBase64$3(object.hash) : new Uint8Array(0),
            metadata: isSet$m(object.metadata) ? bytesFromBase64$3(object.metadata) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.height !== 0) {
            obj.height = Math.round(message.height);
        }
        if (message.format !== 0) {
            obj.format = Math.round(message.format);
        }
        if (message.chunks !== 0) {
            obj.chunks = Math.round(message.chunks);
        }
        if (message.hash.length !== 0) {
            obj.hash = base64FromBytes$3(message.hash);
        }
        if (message.metadata.length !== 0) {
            obj.metadata = base64FromBytes$3(message.metadata);
        }
        return obj;
    },
    create(base) {
        return Snapshot.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSnapshot();
        message.height = object.height ?? 0;
        message.format = object.format ?? 0;
        message.chunks = object.chunks ?? 0;
        message.hash = object.hash ?? new Uint8Array(0);
        message.metadata = object.metadata ?? new Uint8Array(0);
        return message;
    },
};
class ABCIApplicationClientImpl {
    rpc;
    constructor(rpc) {
        this.rpc = rpc;
        this.Echo = this.Echo.bind(this);
        this.Flush = this.Flush.bind(this);
        this.Info = this.Info.bind(this);
        this.SetOption = this.SetOption.bind(this);
        this.DeliverTx = this.DeliverTx.bind(this);
        this.CheckTx = this.CheckTx.bind(this);
        this.Query = this.Query.bind(this);
        this.Commit = this.Commit.bind(this);
        this.InitChain = this.InitChain.bind(this);
        this.BeginBlock = this.BeginBlock.bind(this);
        this.EndBlock = this.EndBlock.bind(this);
        this.ListSnapshots = this.ListSnapshots.bind(this);
        this.OfferSnapshot = this.OfferSnapshot.bind(this);
        this.LoadSnapshotChunk = this.LoadSnapshotChunk.bind(this);
        this.ApplySnapshotChunk = this.ApplySnapshotChunk.bind(this);
    }
    Echo(request, metadata) {
        return this.rpc.unary(ABCIApplicationEchoDesc, RequestEcho.fromPartial(request), metadata);
    }
    Flush(request, metadata) {
        return this.rpc.unary(ABCIApplicationFlushDesc, RequestFlush.fromPartial(request), metadata);
    }
    Info(request, metadata) {
        return this.rpc.unary(ABCIApplicationInfoDesc, RequestInfo.fromPartial(request), metadata);
    }
    SetOption(request, metadata) {
        return this.rpc.unary(ABCIApplicationSetOptionDesc, RequestSetOption.fromPartial(request), metadata);
    }
    DeliverTx(request, metadata) {
        return this.rpc.unary(ABCIApplicationDeliverTxDesc, RequestDeliverTx.fromPartial(request), metadata);
    }
    CheckTx(request, metadata) {
        return this.rpc.unary(ABCIApplicationCheckTxDesc, RequestCheckTx.fromPartial(request), metadata);
    }
    Query(request, metadata) {
        return this.rpc.unary(ABCIApplicationQueryDesc, RequestQuery.fromPartial(request), metadata);
    }
    Commit(request, metadata) {
        return this.rpc.unary(ABCIApplicationCommitDesc, RequestCommit.fromPartial(request), metadata);
    }
    InitChain(request, metadata) {
        return this.rpc.unary(ABCIApplicationInitChainDesc, RequestInitChain.fromPartial(request), metadata);
    }
    BeginBlock(request, metadata) {
        return this.rpc.unary(ABCIApplicationBeginBlockDesc, RequestBeginBlock.fromPartial(request), metadata);
    }
    EndBlock(request, metadata) {
        return this.rpc.unary(ABCIApplicationEndBlockDesc, RequestEndBlock.fromPartial(request), metadata);
    }
    ListSnapshots(request, metadata) {
        return this.rpc.unary(ABCIApplicationListSnapshotsDesc, RequestListSnapshots.fromPartial(request), metadata);
    }
    OfferSnapshot(request, metadata) {
        return this.rpc.unary(ABCIApplicationOfferSnapshotDesc, RequestOfferSnapshot.fromPartial(request), metadata);
    }
    LoadSnapshotChunk(request, metadata) {
        return this.rpc.unary(ABCIApplicationLoadSnapshotChunkDesc, RequestLoadSnapshotChunk.fromPartial(request), metadata);
    }
    ApplySnapshotChunk(request, metadata) {
        return this.rpc.unary(ABCIApplicationApplySnapshotChunkDesc, RequestApplySnapshotChunk.fromPartial(request), metadata);
    }
}
const ABCIApplicationDesc = { serviceName: "tendermint.abci.ABCIApplication" };
const ABCIApplicationEchoDesc = {
    methodName: "Echo",
    service: ABCIApplicationDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return RequestEcho.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = ResponseEcho.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const ABCIApplicationFlushDesc = {
    methodName: "Flush",
    service: ABCIApplicationDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return RequestFlush.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = ResponseFlush.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const ABCIApplicationInfoDesc = {
    methodName: "Info",
    service: ABCIApplicationDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return RequestInfo.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = ResponseInfo.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const ABCIApplicationSetOptionDesc = {
    methodName: "SetOption",
    service: ABCIApplicationDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return RequestSetOption.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = ResponseSetOption.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const ABCIApplicationDeliverTxDesc = {
    methodName: "DeliverTx",
    service: ABCIApplicationDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return RequestDeliverTx.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = ResponseDeliverTx.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const ABCIApplicationCheckTxDesc = {
    methodName: "CheckTx",
    service: ABCIApplicationDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return RequestCheckTx.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = ResponseCheckTx.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const ABCIApplicationQueryDesc = {
    methodName: "Query",
    service: ABCIApplicationDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return RequestQuery.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = ResponseQuery.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const ABCIApplicationCommitDesc = {
    methodName: "Commit",
    service: ABCIApplicationDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return RequestCommit.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = ResponseCommit.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const ABCIApplicationInitChainDesc = {
    methodName: "InitChain",
    service: ABCIApplicationDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return RequestInitChain.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = ResponseInitChain.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const ABCIApplicationBeginBlockDesc = {
    methodName: "BeginBlock",
    service: ABCIApplicationDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return RequestBeginBlock.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = ResponseBeginBlock.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const ABCIApplicationEndBlockDesc = {
    methodName: "EndBlock",
    service: ABCIApplicationDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return RequestEndBlock.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = ResponseEndBlock.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const ABCIApplicationListSnapshotsDesc = {
    methodName: "ListSnapshots",
    service: ABCIApplicationDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return RequestListSnapshots.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = ResponseListSnapshots.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const ABCIApplicationOfferSnapshotDesc = {
    methodName: "OfferSnapshot",
    service: ABCIApplicationDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return RequestOfferSnapshot.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = ResponseOfferSnapshot.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const ABCIApplicationLoadSnapshotChunkDesc = {
    methodName: "LoadSnapshotChunk",
    service: ABCIApplicationDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return RequestLoadSnapshotChunk.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = ResponseLoadSnapshotChunk.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const ABCIApplicationApplySnapshotChunkDesc = {
    methodName: "ApplySnapshotChunk",
    service: ABCIApplicationDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return RequestApplySnapshotChunk.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = ResponseApplySnapshotChunk.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
let GrpcWebImpl$f = class GrpcWebImpl {
    host;
    options;
    constructor(host, options) {
        this.host = host;
        this.options = options;
    }
    unary(methodDesc, _request, metadata) {
        const request = { ..._request, ...methodDesc.requestType };
        const maybeCombinedMetadata = metadata && this.options.metadata
            ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
            : metadata ?? this.options.metadata;
        return new Promise((resolve, reject) => {
            grpc.unary(methodDesc, {
                request,
                host: this.host,
                metadata: maybeCombinedMetadata ?? {},
                ...(this.options.transport !== undefined ? { transport: this.options.transport } : {}),
                debug: this.options.debug ?? false,
                onEnd: function (response) {
                    if (response.status === grpc.Code.OK) {
                        resolve(response.message.toObject());
                    }
                    else {
                        const err = new GrpcWebError$f(response.statusMessage, response.status, response.trailers);
                        reject(err);
                    }
                },
            });
        });
    }
};
const tsProtoGlobalThis$k = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function bytesFromBase64$3(b64) {
    if (tsProtoGlobalThis$k.Buffer) {
        return Uint8Array.from(tsProtoGlobalThis$k.Buffer.from(b64, "base64"));
    }
    else {
        const bin = tsProtoGlobalThis$k.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes$3(arr) {
    if (tsProtoGlobalThis$k.Buffer) {
        return tsProtoGlobalThis$k.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(String.fromCharCode(byte));
        });
        return tsProtoGlobalThis$k.btoa(bin.join(""));
    }
}
function toTimestamp$4(date) {
    const seconds = date.getTime() / 1_000;
    const nanos = (date.getTime() % 1_000) * 1_000_000;
    return { seconds, nanos };
}
function fromTimestamp$4(t) {
    let millis = (t.seconds || 0) * 1_000;
    millis += (t.nanos || 0) / 1_000_000;
    return new Date(millis);
}
function fromJsonTimestamp$4(o) {
    if (o instanceof Date) {
        return o;
    }
    else if (typeof o === "string") {
        return new Date(o);
    }
    else {
        return fromTimestamp$4(Timestamp.fromJSON(o));
    }
}
function longToNumber$9(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new tsProtoGlobalThis$k.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isSet$m(value) {
    return value !== null && value !== undefined;
}
let GrpcWebError$f = class GrpcWebError extends tsProtoGlobalThis$k.Error {
    code;
    metadata;
    constructor(message, code, metadata) {
        super(message);
        this.code = code;
        this.metadata = metadata;
    }
};

/* eslint-disable */
const protobufPackage$l = "cosmos.base.v1beta1";
function createBaseCoin() {
    return { denom: "", amount: "" };
}
const Coin = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.denom !== "") {
            writer.uint32(10).string(message.denom);
        }
        if (message.amount !== "") {
            writer.uint32(18).string(message.amount);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCoin();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.denom = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.amount = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            denom: isSet$l(object.denom) ? String(object.denom) : "",
            amount: isSet$l(object.amount) ? String(object.amount) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.denom !== "") {
            obj.denom = message.denom;
        }
        if (message.amount !== "") {
            obj.amount = message.amount;
        }
        return obj;
    },
    create(base) {
        return Coin.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCoin();
        message.denom = object.denom ?? "";
        message.amount = object.amount ?? "";
        return message;
    },
};
function createBaseDecCoin() {
    return { denom: "", amount: "" };
}
const DecCoin = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.denom !== "") {
            writer.uint32(10).string(message.denom);
        }
        if (message.amount !== "") {
            writer.uint32(18).string(message.amount);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDecCoin();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.denom = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.amount = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            denom: isSet$l(object.denom) ? String(object.denom) : "",
            amount: isSet$l(object.amount) ? String(object.amount) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.denom !== "") {
            obj.denom = message.denom;
        }
        if (message.amount !== "") {
            obj.amount = message.amount;
        }
        return obj;
    },
    create(base) {
        return DecCoin.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDecCoin();
        message.denom = object.denom ?? "";
        message.amount = object.amount ?? "";
        return message;
    },
};
function createBaseIntProto() {
    return { int: "" };
}
const IntProto = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.int !== "") {
            writer.uint32(10).string(message.int);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseIntProto();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.int = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { int: isSet$l(object.int) ? String(object.int) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.int !== "") {
            obj.int = message.int;
        }
        return obj;
    },
    create(base) {
        return IntProto.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseIntProto();
        message.int = object.int ?? "";
        return message;
    },
};
function createBaseDecProto() {
    return { dec: "" };
}
const DecProto = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.dec !== "") {
            writer.uint32(10).string(message.dec);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDecProto();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.dec = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { dec: isSet$l(object.dec) ? String(object.dec) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.dec !== "") {
            obj.dec = message.dec;
        }
        return obj;
    },
    create(base) {
        return DecProto.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDecProto();
        message.dec = object.dec ?? "";
        return message;
    },
};
function isSet$l(value) {
    return value !== null && value !== undefined;
}

/* eslint-disable */
const protobufPackage$k = "cosmos.bank.v1beta1";
function createBaseParams$3() {
    return { sendEnabled: [], defaultSendEnabled: false };
}
const Params$3 = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.sendEnabled) {
            SendEnabled.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.defaultSendEnabled === true) {
            writer.uint32(16).bool(message.defaultSendEnabled);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParams$3();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.sendEnabled.push(SendEnabled.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.defaultSendEnabled = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            sendEnabled: Array.isArray(object?.sendEnabled)
                ? object.sendEnabled.map((e) => SendEnabled.fromJSON(e))
                : [],
            defaultSendEnabled: isSet$k(object.defaultSendEnabled) ? Boolean(object.defaultSendEnabled) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.sendEnabled?.length) {
            obj.sendEnabled = message.sendEnabled.map((e) => SendEnabled.toJSON(e));
        }
        if (message.defaultSendEnabled === true) {
            obj.defaultSendEnabled = message.defaultSendEnabled;
        }
        return obj;
    },
    create(base) {
        return Params$3.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseParams$3();
        message.sendEnabled = object.sendEnabled?.map((e) => SendEnabled.fromPartial(e)) || [];
        message.defaultSendEnabled = object.defaultSendEnabled ?? false;
        return message;
    },
};
function createBaseSendEnabled() {
    return { denom: "", enabled: false };
}
const SendEnabled = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.denom !== "") {
            writer.uint32(10).string(message.denom);
        }
        if (message.enabled === true) {
            writer.uint32(16).bool(message.enabled);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSendEnabled();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.denom = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.enabled = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            denom: isSet$k(object.denom) ? String(object.denom) : "",
            enabled: isSet$k(object.enabled) ? Boolean(object.enabled) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.denom !== "") {
            obj.denom = message.denom;
        }
        if (message.enabled === true) {
            obj.enabled = message.enabled;
        }
        return obj;
    },
    create(base) {
        return SendEnabled.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSendEnabled();
        message.denom = object.denom ?? "";
        message.enabled = object.enabled ?? false;
        return message;
    },
};
function createBaseInput() {
    return { address: "", coins: [] };
}
const Input = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        for (const v of message.coins) {
            Coin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInput();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.coins.push(Coin.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            address: isSet$k(object.address) ? String(object.address) : "",
            coins: Array.isArray(object?.coins) ? object.coins.map((e) => Coin.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.address !== "") {
            obj.address = message.address;
        }
        if (message.coins?.length) {
            obj.coins = message.coins.map((e) => Coin.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return Input.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseInput();
        message.address = object.address ?? "";
        message.coins = object.coins?.map((e) => Coin.fromPartial(e)) || [];
        return message;
    },
};
function createBaseOutput() {
    return { address: "", coins: [] };
}
const Output = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        for (const v of message.coins) {
            Coin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOutput();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.coins.push(Coin.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            address: isSet$k(object.address) ? String(object.address) : "",
            coins: Array.isArray(object?.coins) ? object.coins.map((e) => Coin.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.address !== "") {
            obj.address = message.address;
        }
        if (message.coins?.length) {
            obj.coins = message.coins.map((e) => Coin.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return Output.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseOutput();
        message.address = object.address ?? "";
        message.coins = object.coins?.map((e) => Coin.fromPartial(e)) || [];
        return message;
    },
};
function createBaseSupply() {
    return { total: [] };
}
const Supply = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.total) {
            Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSupply();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.total.push(Coin.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { total: Array.isArray(object?.total) ? object.total.map((e) => Coin.fromJSON(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.total?.length) {
            obj.total = message.total.map((e) => Coin.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return Supply.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSupply();
        message.total = object.total?.map((e) => Coin.fromPartial(e)) || [];
        return message;
    },
};
function createBaseDenomUnit() {
    return { denom: "", exponent: 0, aliases: [] };
}
const DenomUnit = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.denom !== "") {
            writer.uint32(10).string(message.denom);
        }
        if (message.exponent !== 0) {
            writer.uint32(16).uint32(message.exponent);
        }
        for (const v of message.aliases) {
            writer.uint32(26).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDenomUnit();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.denom = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.exponent = reader.uint32();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.aliases.push(reader.string());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            denom: isSet$k(object.denom) ? String(object.denom) : "",
            exponent: isSet$k(object.exponent) ? Number(object.exponent) : 0,
            aliases: Array.isArray(object?.aliases) ? object.aliases.map((e) => String(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.denom !== "") {
            obj.denom = message.denom;
        }
        if (message.exponent !== 0) {
            obj.exponent = Math.round(message.exponent);
        }
        if (message.aliases?.length) {
            obj.aliases = message.aliases;
        }
        return obj;
    },
    create(base) {
        return DenomUnit.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDenomUnit();
        message.denom = object.denom ?? "";
        message.exponent = object.exponent ?? 0;
        message.aliases = object.aliases?.map((e) => e) || [];
        return message;
    },
};
function createBaseMetadata() {
    return { description: "", denomUnits: [], base: "", display: "", name: "", symbol: "" };
}
const Metadata = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.description !== "") {
            writer.uint32(10).string(message.description);
        }
        for (const v of message.denomUnits) {
            DenomUnit.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.base !== "") {
            writer.uint32(26).string(message.base);
        }
        if (message.display !== "") {
            writer.uint32(34).string(message.display);
        }
        if (message.name !== "") {
            writer.uint32(42).string(message.name);
        }
        if (message.symbol !== "") {
            writer.uint32(50).string(message.symbol);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMetadata();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.description = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.denomUnits.push(DenomUnit.decode(reader, reader.uint32()));
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.base = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.display = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.symbol = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            description: isSet$k(object.description) ? String(object.description) : "",
            denomUnits: Array.isArray(object?.denomUnits) ? object.denomUnits.map((e) => DenomUnit.fromJSON(e)) : [],
            base: isSet$k(object.base) ? String(object.base) : "",
            display: isSet$k(object.display) ? String(object.display) : "",
            name: isSet$k(object.name) ? String(object.name) : "",
            symbol: isSet$k(object.symbol) ? String(object.symbol) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.description !== "") {
            obj.description = message.description;
        }
        if (message.denomUnits?.length) {
            obj.denomUnits = message.denomUnits.map((e) => DenomUnit.toJSON(e));
        }
        if (message.base !== "") {
            obj.base = message.base;
        }
        if (message.display !== "") {
            obj.display = message.display;
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.symbol !== "") {
            obj.symbol = message.symbol;
        }
        return obj;
    },
    create(base) {
        return Metadata.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMetadata();
        message.description = object.description ?? "";
        message.denomUnits = object.denomUnits?.map((e) => DenomUnit.fromPartial(e)) || [];
        message.base = object.base ?? "";
        message.display = object.display ?? "";
        message.name = object.name ?? "";
        message.symbol = object.symbol ?? "";
        return message;
    },
};
function isSet$k(value) {
    return value !== null && value !== undefined;
}

/* eslint-disable */
const protobufPackage$j = "cosmos.bank.v1beta1";
function createBaseQueryBalanceRequest() {
    return { address: "", denom: "" };
}
const QueryBalanceRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        if (message.denom !== "") {
            writer.uint32(18).string(message.denom);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryBalanceRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.denom = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            address: isSet$j(object.address) ? String(object.address) : "",
            denom: isSet$j(object.denom) ? String(object.denom) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.address !== "") {
            obj.address = message.address;
        }
        if (message.denom !== "") {
            obj.denom = message.denom;
        }
        return obj;
    },
    create(base) {
        return QueryBalanceRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryBalanceRequest();
        message.address = object.address ?? "";
        message.denom = object.denom ?? "";
        return message;
    },
};
function createBaseQueryBalanceResponse() {
    return { balance: undefined };
}
const QueryBalanceResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.balance !== undefined) {
            Coin.encode(message.balance, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryBalanceResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.balance = Coin.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { balance: isSet$j(object.balance) ? Coin.fromJSON(object.balance) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.balance !== undefined) {
            obj.balance = Coin.toJSON(message.balance);
        }
        return obj;
    },
    create(base) {
        return QueryBalanceResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryBalanceResponse();
        message.balance = (object.balance !== undefined && object.balance !== null)
            ? Coin.fromPartial(object.balance)
            : undefined;
        return message;
    },
};
function createBaseQueryAllBalancesRequest() {
    return { address: "", pagination: undefined };
}
const QueryAllBalancesRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        if (message.pagination !== undefined) {
            PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllBalancesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageRequest.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            address: isSet$j(object.address) ? String(object.address) : "",
            pagination: isSet$j(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.address !== "") {
            obj.address = message.address;
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageRequest.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryAllBalancesRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryAllBalancesRequest();
        message.address = object.address ?? "";
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageRequest.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryAllBalancesResponse() {
    return { balances: [], pagination: undefined };
}
const QueryAllBalancesResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.balances) {
            Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryAllBalancesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.balances.push(Coin.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageResponse.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            balances: Array.isArray(object?.balances) ? object.balances.map((e) => Coin.fromJSON(e)) : [],
            pagination: isSet$j(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.balances?.length) {
            obj.balances = message.balances.map((e) => Coin.toJSON(e));
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageResponse.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryAllBalancesResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryAllBalancesResponse();
        message.balances = object.balances?.map((e) => Coin.fromPartial(e)) || [];
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageResponse.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQuerySpendableBalancesRequest() {
    return { address: "", pagination: undefined };
}
const QuerySpendableBalancesRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        if (message.pagination !== undefined) {
            PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQuerySpendableBalancesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageRequest.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            address: isSet$j(object.address) ? String(object.address) : "",
            pagination: isSet$j(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.address !== "") {
            obj.address = message.address;
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageRequest.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QuerySpendableBalancesRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQuerySpendableBalancesRequest();
        message.address = object.address ?? "";
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageRequest.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQuerySpendableBalancesResponse() {
    return { balances: [], pagination: undefined };
}
const QuerySpendableBalancesResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.balances) {
            Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQuerySpendableBalancesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.balances.push(Coin.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageResponse.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            balances: Array.isArray(object?.balances) ? object.balances.map((e) => Coin.fromJSON(e)) : [],
            pagination: isSet$j(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.balances?.length) {
            obj.balances = message.balances.map((e) => Coin.toJSON(e));
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageResponse.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QuerySpendableBalancesResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQuerySpendableBalancesResponse();
        message.balances = object.balances?.map((e) => Coin.fromPartial(e)) || [];
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageResponse.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryTotalSupplyRequest() {
    return { pagination: undefined };
}
const QueryTotalSupplyRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.pagination !== undefined) {
            PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryTotalSupplyRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.pagination = PageRequest.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { pagination: isSet$j(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.pagination !== undefined) {
            obj.pagination = PageRequest.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryTotalSupplyRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryTotalSupplyRequest();
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageRequest.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryTotalSupplyResponse() {
    return { supply: [], pagination: undefined };
}
const QueryTotalSupplyResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.supply) {
            Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryTotalSupplyResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.supply.push(Coin.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageResponse.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            supply: Array.isArray(object?.supply) ? object.supply.map((e) => Coin.fromJSON(e)) : [],
            pagination: isSet$j(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.supply?.length) {
            obj.supply = message.supply.map((e) => Coin.toJSON(e));
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageResponse.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryTotalSupplyResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryTotalSupplyResponse();
        message.supply = object.supply?.map((e) => Coin.fromPartial(e)) || [];
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageResponse.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQuerySupplyOfRequest() {
    return { denom: "" };
}
const QuerySupplyOfRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.denom !== "") {
            writer.uint32(10).string(message.denom);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQuerySupplyOfRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.denom = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { denom: isSet$j(object.denom) ? String(object.denom) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.denom !== "") {
            obj.denom = message.denom;
        }
        return obj;
    },
    create(base) {
        return QuerySupplyOfRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQuerySupplyOfRequest();
        message.denom = object.denom ?? "";
        return message;
    },
};
function createBaseQuerySupplyOfResponse() {
    return { amount: undefined };
}
const QuerySupplyOfResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.amount !== undefined) {
            Coin.encode(message.amount, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQuerySupplyOfResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.amount = Coin.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { amount: isSet$j(object.amount) ? Coin.fromJSON(object.amount) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.amount !== undefined) {
            obj.amount = Coin.toJSON(message.amount);
        }
        return obj;
    },
    create(base) {
        return QuerySupplyOfResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQuerySupplyOfResponse();
        message.amount = (object.amount !== undefined && object.amount !== null)
            ? Coin.fromPartial(object.amount)
            : undefined;
        return message;
    },
};
function createBaseQueryParamsRequest$4() {
    return {};
}
const QueryParamsRequest$4 = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest$4();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return QueryParamsRequest$4.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseQueryParamsRequest$4();
        return message;
    },
};
function createBaseQueryParamsResponse$4() {
    return { params: undefined };
}
const QueryParamsResponse$4 = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.params !== undefined) {
            Params$3.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse$4();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.params = Params$3.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { params: isSet$j(object.params) ? Params$3.fromJSON(object.params) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.params !== undefined) {
            obj.params = Params$3.toJSON(message.params);
        }
        return obj;
    },
    create(base) {
        return QueryParamsResponse$4.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryParamsResponse$4();
        message.params = (object.params !== undefined && object.params !== null)
            ? Params$3.fromPartial(object.params)
            : undefined;
        return message;
    },
};
function createBaseQueryDenomsMetadataRequest() {
    return { pagination: undefined };
}
const QueryDenomsMetadataRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.pagination !== undefined) {
            PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomsMetadataRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.pagination = PageRequest.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { pagination: isSet$j(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.pagination !== undefined) {
            obj.pagination = PageRequest.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryDenomsMetadataRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryDenomsMetadataRequest();
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageRequest.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryDenomsMetadataResponse() {
    return { metadatas: [], pagination: undefined };
}
const QueryDenomsMetadataResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.metadatas) {
            Metadata.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomsMetadataResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.metadatas.push(Metadata.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageResponse.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            metadatas: Array.isArray(object?.metadatas) ? object.metadatas.map((e) => Metadata.fromJSON(e)) : [],
            pagination: isSet$j(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.metadatas?.length) {
            obj.metadatas = message.metadatas.map((e) => Metadata.toJSON(e));
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageResponse.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryDenomsMetadataResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryDenomsMetadataResponse();
        message.metadatas = object.metadatas?.map((e) => Metadata.fromPartial(e)) || [];
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageResponse.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryDenomMetadataRequest() {
    return { denom: "" };
}
const QueryDenomMetadataRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.denom !== "") {
            writer.uint32(10).string(message.denom);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomMetadataRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.denom = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { denom: isSet$j(object.denom) ? String(object.denom) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.denom !== "") {
            obj.denom = message.denom;
        }
        return obj;
    },
    create(base) {
        return QueryDenomMetadataRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryDenomMetadataRequest();
        message.denom = object.denom ?? "";
        return message;
    },
};
function createBaseQueryDenomMetadataResponse() {
    return { metadata: undefined };
}
const QueryDenomMetadataResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.metadata !== undefined) {
            Metadata.encode(message.metadata, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDenomMetadataResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.metadata = Metadata.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { metadata: isSet$j(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.metadata !== undefined) {
            obj.metadata = Metadata.toJSON(message.metadata);
        }
        return obj;
    },
    create(base) {
        return QueryDenomMetadataResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryDenomMetadataResponse();
        message.metadata = (object.metadata !== undefined && object.metadata !== null)
            ? Metadata.fromPartial(object.metadata)
            : undefined;
        return message;
    },
};
let QueryClientImpl$4 = class QueryClientImpl {
    rpc;
    constructor(rpc) {
        this.rpc = rpc;
        this.Balance = this.Balance.bind(this);
        this.AllBalances = this.AllBalances.bind(this);
        this.SpendableBalances = this.SpendableBalances.bind(this);
        this.TotalSupply = this.TotalSupply.bind(this);
        this.SupplyOf = this.SupplyOf.bind(this);
        this.Params = this.Params.bind(this);
        this.DenomMetadata = this.DenomMetadata.bind(this);
        this.DenomsMetadata = this.DenomsMetadata.bind(this);
    }
    Balance(request, metadata) {
        return this.rpc.unary(QueryBalanceDesc, QueryBalanceRequest.fromPartial(request), metadata);
    }
    AllBalances(request, metadata) {
        return this.rpc.unary(QueryAllBalancesDesc, QueryAllBalancesRequest.fromPartial(request), metadata);
    }
    SpendableBalances(request, metadata) {
        return this.rpc.unary(QuerySpendableBalancesDesc, QuerySpendableBalancesRequest.fromPartial(request), metadata);
    }
    TotalSupply(request, metadata) {
        return this.rpc.unary(QueryTotalSupplyDesc, QueryTotalSupplyRequest.fromPartial(request), metadata);
    }
    SupplyOf(request, metadata) {
        return this.rpc.unary(QuerySupplyOfDesc, QuerySupplyOfRequest.fromPartial(request), metadata);
    }
    Params(request, metadata) {
        return this.rpc.unary(QueryParamsDesc$4, QueryParamsRequest$4.fromPartial(request), metadata);
    }
    DenomMetadata(request, metadata) {
        return this.rpc.unary(QueryDenomMetadataDesc, QueryDenomMetadataRequest.fromPartial(request), metadata);
    }
    DenomsMetadata(request, metadata) {
        return this.rpc.unary(QueryDenomsMetadataDesc, QueryDenomsMetadataRequest.fromPartial(request), metadata);
    }
};
const QueryDesc$4 = { serviceName: "cosmos.bank.v1beta1.Query" };
const QueryBalanceDesc = {
    methodName: "Balance",
    service: QueryDesc$4,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryBalanceRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryBalanceResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryAllBalancesDesc = {
    methodName: "AllBalances",
    service: QueryDesc$4,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryAllBalancesRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryAllBalancesResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QuerySpendableBalancesDesc = {
    methodName: "SpendableBalances",
    service: QueryDesc$4,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QuerySpendableBalancesRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QuerySpendableBalancesResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryTotalSupplyDesc = {
    methodName: "TotalSupply",
    service: QueryDesc$4,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryTotalSupplyRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryTotalSupplyResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QuerySupplyOfDesc = {
    methodName: "SupplyOf",
    service: QueryDesc$4,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QuerySupplyOfRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QuerySupplyOfResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryParamsDesc$4 = {
    methodName: "Params",
    service: QueryDesc$4,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryParamsRequest$4.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryParamsResponse$4.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryDenomMetadataDesc = {
    methodName: "DenomMetadata",
    service: QueryDesc$4,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryDenomMetadataRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryDenomMetadataResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryDenomsMetadataDesc = {
    methodName: "DenomsMetadata",
    service: QueryDesc$4,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryDenomsMetadataRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryDenomsMetadataResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
let GrpcWebImpl$e = class GrpcWebImpl {
    host;
    options;
    constructor(host, options) {
        this.host = host;
        this.options = options;
    }
    unary(methodDesc, _request, metadata) {
        const request = { ..._request, ...methodDesc.requestType };
        const maybeCombinedMetadata = metadata && this.options.metadata
            ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
            : metadata ?? this.options.metadata;
        return new Promise((resolve, reject) => {
            grpc.unary(methodDesc, {
                request,
                host: this.host,
                metadata: maybeCombinedMetadata ?? {},
                ...(this.options.transport !== undefined ? { transport: this.options.transport } : {}),
                debug: this.options.debug ?? false,
                onEnd: function (response) {
                    if (response.status === grpc.Code.OK) {
                        resolve(response.message.toObject());
                    }
                    else {
                        const err = new GrpcWebError$e(response.statusMessage, response.status, response.trailers);
                        reject(err);
                    }
                },
            });
        });
    }
};
const tsProtoGlobalThis$j = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function isSet$j(value) {
    return value !== null && value !== undefined;
}
let GrpcWebError$e = class GrpcWebError extends tsProtoGlobalThis$j.Error {
    code;
    metadata;
    constructor(message, code, metadata) {
        super(message);
        this.code = code;
        this.metadata = metadata;
    }
};

/* eslint-disable */
const protobufPackage$i = "cosmos.distribution.v1beta1";
function createBaseParams$2() {
    return { communityTax: "", baseProposerReward: "", bonusProposerReward: "", withdrawAddrEnabled: false };
}
const Params$2 = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.communityTax !== "") {
            writer.uint32(10).string(message.communityTax);
        }
        if (message.baseProposerReward !== "") {
            writer.uint32(18).string(message.baseProposerReward);
        }
        if (message.bonusProposerReward !== "") {
            writer.uint32(26).string(message.bonusProposerReward);
        }
        if (message.withdrawAddrEnabled === true) {
            writer.uint32(32).bool(message.withdrawAddrEnabled);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParams$2();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.communityTax = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.baseProposerReward = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.bonusProposerReward = reader.string();
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.withdrawAddrEnabled = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            communityTax: isSet$i(object.communityTax) ? String(object.communityTax) : "",
            baseProposerReward: isSet$i(object.baseProposerReward) ? String(object.baseProposerReward) : "",
            bonusProposerReward: isSet$i(object.bonusProposerReward) ? String(object.bonusProposerReward) : "",
            withdrawAddrEnabled: isSet$i(object.withdrawAddrEnabled) ? Boolean(object.withdrawAddrEnabled) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.communityTax !== "") {
            obj.communityTax = message.communityTax;
        }
        if (message.baseProposerReward !== "") {
            obj.baseProposerReward = message.baseProposerReward;
        }
        if (message.bonusProposerReward !== "") {
            obj.bonusProposerReward = message.bonusProposerReward;
        }
        if (message.withdrawAddrEnabled === true) {
            obj.withdrawAddrEnabled = message.withdrawAddrEnabled;
        }
        return obj;
    },
    create(base) {
        return Params$2.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseParams$2();
        message.communityTax = object.communityTax ?? "";
        message.baseProposerReward = object.baseProposerReward ?? "";
        message.bonusProposerReward = object.bonusProposerReward ?? "";
        message.withdrawAddrEnabled = object.withdrawAddrEnabled ?? false;
        return message;
    },
};
function createBaseValidatorHistoricalRewards() {
    return { cumulativeRewardRatio: [], referenceCount: 0 };
}
const ValidatorHistoricalRewards = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.cumulativeRewardRatio) {
            DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.referenceCount !== 0) {
            writer.uint32(16).uint32(message.referenceCount);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidatorHistoricalRewards();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.cumulativeRewardRatio.push(DecCoin.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.referenceCount = reader.uint32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            cumulativeRewardRatio: Array.isArray(object?.cumulativeRewardRatio)
                ? object.cumulativeRewardRatio.map((e) => DecCoin.fromJSON(e))
                : [],
            referenceCount: isSet$i(object.referenceCount) ? Number(object.referenceCount) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.cumulativeRewardRatio?.length) {
            obj.cumulativeRewardRatio = message.cumulativeRewardRatio.map((e) => DecCoin.toJSON(e));
        }
        if (message.referenceCount !== 0) {
            obj.referenceCount = Math.round(message.referenceCount);
        }
        return obj;
    },
    create(base) {
        return ValidatorHistoricalRewards.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseValidatorHistoricalRewards();
        message.cumulativeRewardRatio = object.cumulativeRewardRatio?.map((e) => DecCoin.fromPartial(e)) || [];
        message.referenceCount = object.referenceCount ?? 0;
        return message;
    },
};
function createBaseValidatorCurrentRewards() {
    return { rewards: [], period: 0 };
}
const ValidatorCurrentRewards = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.rewards) {
            DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.period !== 0) {
            writer.uint32(16).uint64(message.period);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidatorCurrentRewards();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.rewards.push(DecCoin.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.period = longToNumber$8(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            rewards: Array.isArray(object?.rewards) ? object.rewards.map((e) => DecCoin.fromJSON(e)) : [],
            period: isSet$i(object.period) ? Number(object.period) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.rewards?.length) {
            obj.rewards = message.rewards.map((e) => DecCoin.toJSON(e));
        }
        if (message.period !== 0) {
            obj.period = Math.round(message.period);
        }
        return obj;
    },
    create(base) {
        return ValidatorCurrentRewards.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseValidatorCurrentRewards();
        message.rewards = object.rewards?.map((e) => DecCoin.fromPartial(e)) || [];
        message.period = object.period ?? 0;
        return message;
    },
};
function createBaseValidatorAccumulatedCommission() {
    return { commission: [] };
}
const ValidatorAccumulatedCommission = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.commission) {
            DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidatorAccumulatedCommission();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.commission.push(DecCoin.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            commission: Array.isArray(object?.commission) ? object.commission.map((e) => DecCoin.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.commission?.length) {
            obj.commission = message.commission.map((e) => DecCoin.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return ValidatorAccumulatedCommission.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseValidatorAccumulatedCommission();
        message.commission = object.commission?.map((e) => DecCoin.fromPartial(e)) || [];
        return message;
    },
};
function createBaseValidatorOutstandingRewards() {
    return { rewards: [] };
}
const ValidatorOutstandingRewards = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.rewards) {
            DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidatorOutstandingRewards();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.rewards.push(DecCoin.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { rewards: Array.isArray(object?.rewards) ? object.rewards.map((e) => DecCoin.fromJSON(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.rewards?.length) {
            obj.rewards = message.rewards.map((e) => DecCoin.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return ValidatorOutstandingRewards.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseValidatorOutstandingRewards();
        message.rewards = object.rewards?.map((e) => DecCoin.fromPartial(e)) || [];
        return message;
    },
};
function createBaseValidatorSlashEvent() {
    return { validatorPeriod: 0, fraction: "" };
}
const ValidatorSlashEvent = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.validatorPeriod !== 0) {
            writer.uint32(8).uint64(message.validatorPeriod);
        }
        if (message.fraction !== "") {
            writer.uint32(18).string(message.fraction);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidatorSlashEvent();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.validatorPeriod = longToNumber$8(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.fraction = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            validatorPeriod: isSet$i(object.validatorPeriod) ? Number(object.validatorPeriod) : 0,
            fraction: isSet$i(object.fraction) ? String(object.fraction) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.validatorPeriod !== 0) {
            obj.validatorPeriod = Math.round(message.validatorPeriod);
        }
        if (message.fraction !== "") {
            obj.fraction = message.fraction;
        }
        return obj;
    },
    create(base) {
        return ValidatorSlashEvent.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseValidatorSlashEvent();
        message.validatorPeriod = object.validatorPeriod ?? 0;
        message.fraction = object.fraction ?? "";
        return message;
    },
};
function createBaseValidatorSlashEvents() {
    return { validatorSlashEvents: [] };
}
const ValidatorSlashEvents = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.validatorSlashEvents) {
            ValidatorSlashEvent.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidatorSlashEvents();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.validatorSlashEvents.push(ValidatorSlashEvent.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            validatorSlashEvents: Array.isArray(object?.validatorSlashEvents)
                ? object.validatorSlashEvents.map((e) => ValidatorSlashEvent.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.validatorSlashEvents?.length) {
            obj.validatorSlashEvents = message.validatorSlashEvents.map((e) => ValidatorSlashEvent.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return ValidatorSlashEvents.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseValidatorSlashEvents();
        message.validatorSlashEvents = object.validatorSlashEvents?.map((e) => ValidatorSlashEvent.fromPartial(e)) || [];
        return message;
    },
};
function createBaseFeePool() {
    return { communityPool: [] };
}
const FeePool = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.communityPool) {
            DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseFeePool();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.communityPool.push(DecCoin.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            communityPool: Array.isArray(object?.communityPool)
                ? object.communityPool.map((e) => DecCoin.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.communityPool?.length) {
            obj.communityPool = message.communityPool.map((e) => DecCoin.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return FeePool.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseFeePool();
        message.communityPool = object.communityPool?.map((e) => DecCoin.fromPartial(e)) || [];
        return message;
    },
};
function createBaseCommunityPoolSpendProposal() {
    return { title: "", description: "", recipient: "", amount: [] };
}
const CommunityPoolSpendProposal = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.title !== "") {
            writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
            writer.uint32(18).string(message.description);
        }
        if (message.recipient !== "") {
            writer.uint32(26).string(message.recipient);
        }
        for (const v of message.amount) {
            Coin.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommunityPoolSpendProposal();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.title = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.description = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.recipient = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.amount.push(Coin.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            title: isSet$i(object.title) ? String(object.title) : "",
            description: isSet$i(object.description) ? String(object.description) : "",
            recipient: isSet$i(object.recipient) ? String(object.recipient) : "",
            amount: Array.isArray(object?.amount) ? object.amount.map((e) => Coin.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.title !== "") {
            obj.title = message.title;
        }
        if (message.description !== "") {
            obj.description = message.description;
        }
        if (message.recipient !== "") {
            obj.recipient = message.recipient;
        }
        if (message.amount?.length) {
            obj.amount = message.amount.map((e) => Coin.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return CommunityPoolSpendProposal.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCommunityPoolSpendProposal();
        message.title = object.title ?? "";
        message.description = object.description ?? "";
        message.recipient = object.recipient ?? "";
        message.amount = object.amount?.map((e) => Coin.fromPartial(e)) || [];
        return message;
    },
};
function createBaseDelegatorStartingInfo() {
    return { previousPeriod: 0, stake: "", height: 0 };
}
const DelegatorStartingInfo = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.previousPeriod !== 0) {
            writer.uint32(8).uint64(message.previousPeriod);
        }
        if (message.stake !== "") {
            writer.uint32(18).string(message.stake);
        }
        if (message.height !== 0) {
            writer.uint32(24).uint64(message.height);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDelegatorStartingInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.previousPeriod = longToNumber$8(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.stake = reader.string();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.height = longToNumber$8(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            previousPeriod: isSet$i(object.previousPeriod) ? Number(object.previousPeriod) : 0,
            stake: isSet$i(object.stake) ? String(object.stake) : "",
            height: isSet$i(object.height) ? Number(object.height) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.previousPeriod !== 0) {
            obj.previousPeriod = Math.round(message.previousPeriod);
        }
        if (message.stake !== "") {
            obj.stake = message.stake;
        }
        if (message.height !== 0) {
            obj.height = Math.round(message.height);
        }
        return obj;
    },
    create(base) {
        return DelegatorStartingInfo.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDelegatorStartingInfo();
        message.previousPeriod = object.previousPeriod ?? 0;
        message.stake = object.stake ?? "";
        message.height = object.height ?? 0;
        return message;
    },
};
function createBaseDelegationDelegatorReward() {
    return { validatorAddress: "", reward: [] };
}
const DelegationDelegatorReward = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.validatorAddress !== "") {
            writer.uint32(10).string(message.validatorAddress);
        }
        for (const v of message.reward) {
            DecCoin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDelegationDelegatorReward();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.validatorAddress = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.reward.push(DecCoin.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            validatorAddress: isSet$i(object.validatorAddress) ? String(object.validatorAddress) : "",
            reward: Array.isArray(object?.reward) ? object.reward.map((e) => DecCoin.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.validatorAddress !== "") {
            obj.validatorAddress = message.validatorAddress;
        }
        if (message.reward?.length) {
            obj.reward = message.reward.map((e) => DecCoin.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return DelegationDelegatorReward.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDelegationDelegatorReward();
        message.validatorAddress = object.validatorAddress ?? "";
        message.reward = object.reward?.map((e) => DecCoin.fromPartial(e)) || [];
        return message;
    },
};
function createBaseCommunityPoolSpendProposalWithDeposit() {
    return { title: "", description: "", recipient: "", amount: "", deposit: "" };
}
const CommunityPoolSpendProposalWithDeposit = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.title !== "") {
            writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
            writer.uint32(18).string(message.description);
        }
        if (message.recipient !== "") {
            writer.uint32(26).string(message.recipient);
        }
        if (message.amount !== "") {
            writer.uint32(34).string(message.amount);
        }
        if (message.deposit !== "") {
            writer.uint32(42).string(message.deposit);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommunityPoolSpendProposalWithDeposit();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.title = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.description = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.recipient = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.amount = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.deposit = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            title: isSet$i(object.title) ? String(object.title) : "",
            description: isSet$i(object.description) ? String(object.description) : "",
            recipient: isSet$i(object.recipient) ? String(object.recipient) : "",
            amount: isSet$i(object.amount) ? String(object.amount) : "",
            deposit: isSet$i(object.deposit) ? String(object.deposit) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.title !== "") {
            obj.title = message.title;
        }
        if (message.description !== "") {
            obj.description = message.description;
        }
        if (message.recipient !== "") {
            obj.recipient = message.recipient;
        }
        if (message.amount !== "") {
            obj.amount = message.amount;
        }
        if (message.deposit !== "") {
            obj.deposit = message.deposit;
        }
        return obj;
    },
    create(base) {
        return CommunityPoolSpendProposalWithDeposit.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCommunityPoolSpendProposalWithDeposit();
        message.title = object.title ?? "";
        message.description = object.description ?? "";
        message.recipient = object.recipient ?? "";
        message.amount = object.amount ?? "";
        message.deposit = object.deposit ?? "";
        return message;
    },
};
const tsProtoGlobalThis$i = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function longToNumber$8(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new tsProtoGlobalThis$i.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isSet$i(value) {
    return value !== null && value !== undefined;
}

/* eslint-disable */
const protobufPackage$h = "cosmos.distribution.v1beta1";
function createBaseQueryParamsRequest$3() {
    return {};
}
const QueryParamsRequest$3 = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest$3();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return QueryParamsRequest$3.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseQueryParamsRequest$3();
        return message;
    },
};
function createBaseQueryParamsResponse$3() {
    return { params: undefined };
}
const QueryParamsResponse$3 = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.params !== undefined) {
            Params$2.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse$3();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.params = Params$2.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { params: isSet$h(object.params) ? Params$2.fromJSON(object.params) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.params !== undefined) {
            obj.params = Params$2.toJSON(message.params);
        }
        return obj;
    },
    create(base) {
        return QueryParamsResponse$3.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryParamsResponse$3();
        message.params = (object.params !== undefined && object.params !== null)
            ? Params$2.fromPartial(object.params)
            : undefined;
        return message;
    },
};
function createBaseQueryValidatorOutstandingRewardsRequest() {
    return { validatorAddress: "" };
}
const QueryValidatorOutstandingRewardsRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.validatorAddress !== "") {
            writer.uint32(10).string(message.validatorAddress);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorOutstandingRewardsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.validatorAddress = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { validatorAddress: isSet$h(object.validatorAddress) ? String(object.validatorAddress) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.validatorAddress !== "") {
            obj.validatorAddress = message.validatorAddress;
        }
        return obj;
    },
    create(base) {
        return QueryValidatorOutstandingRewardsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryValidatorOutstandingRewardsRequest();
        message.validatorAddress = object.validatorAddress ?? "";
        return message;
    },
};
function createBaseQueryValidatorOutstandingRewardsResponse() {
    return { rewards: undefined };
}
const QueryValidatorOutstandingRewardsResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.rewards !== undefined) {
            ValidatorOutstandingRewards.encode(message.rewards, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorOutstandingRewardsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.rewards = ValidatorOutstandingRewards.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { rewards: isSet$h(object.rewards) ? ValidatorOutstandingRewards.fromJSON(object.rewards) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.rewards !== undefined) {
            obj.rewards = ValidatorOutstandingRewards.toJSON(message.rewards);
        }
        return obj;
    },
    create(base) {
        return QueryValidatorOutstandingRewardsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryValidatorOutstandingRewardsResponse();
        message.rewards = (object.rewards !== undefined && object.rewards !== null)
            ? ValidatorOutstandingRewards.fromPartial(object.rewards)
            : undefined;
        return message;
    },
};
function createBaseQueryValidatorCommissionRequest() {
    return { validatorAddress: "" };
}
const QueryValidatorCommissionRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.validatorAddress !== "") {
            writer.uint32(10).string(message.validatorAddress);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorCommissionRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.validatorAddress = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { validatorAddress: isSet$h(object.validatorAddress) ? String(object.validatorAddress) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.validatorAddress !== "") {
            obj.validatorAddress = message.validatorAddress;
        }
        return obj;
    },
    create(base) {
        return QueryValidatorCommissionRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryValidatorCommissionRequest();
        message.validatorAddress = object.validatorAddress ?? "";
        return message;
    },
};
function createBaseQueryValidatorCommissionResponse() {
    return { commission: undefined };
}
const QueryValidatorCommissionResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.commission !== undefined) {
            ValidatorAccumulatedCommission.encode(message.commission, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorCommissionResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.commission = ValidatorAccumulatedCommission.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            commission: isSet$h(object.commission) ? ValidatorAccumulatedCommission.fromJSON(object.commission) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.commission !== undefined) {
            obj.commission = ValidatorAccumulatedCommission.toJSON(message.commission);
        }
        return obj;
    },
    create(base) {
        return QueryValidatorCommissionResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryValidatorCommissionResponse();
        message.commission = (object.commission !== undefined && object.commission !== null)
            ? ValidatorAccumulatedCommission.fromPartial(object.commission)
            : undefined;
        return message;
    },
};
function createBaseQueryValidatorSlashesRequest() {
    return { validatorAddress: "", startingHeight: 0, endingHeight: 0, pagination: undefined };
}
const QueryValidatorSlashesRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.validatorAddress !== "") {
            writer.uint32(10).string(message.validatorAddress);
        }
        if (message.startingHeight !== 0) {
            writer.uint32(16).uint64(message.startingHeight);
        }
        if (message.endingHeight !== 0) {
            writer.uint32(24).uint64(message.endingHeight);
        }
        if (message.pagination !== undefined) {
            PageRequest.encode(message.pagination, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorSlashesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.validatorAddress = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.startingHeight = longToNumber$7(reader.uint64());
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.endingHeight = longToNumber$7(reader.uint64());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.pagination = PageRequest.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            validatorAddress: isSet$h(object.validatorAddress) ? String(object.validatorAddress) : "",
            startingHeight: isSet$h(object.startingHeight) ? Number(object.startingHeight) : 0,
            endingHeight: isSet$h(object.endingHeight) ? Number(object.endingHeight) : 0,
            pagination: isSet$h(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.validatorAddress !== "") {
            obj.validatorAddress = message.validatorAddress;
        }
        if (message.startingHeight !== 0) {
            obj.startingHeight = Math.round(message.startingHeight);
        }
        if (message.endingHeight !== 0) {
            obj.endingHeight = Math.round(message.endingHeight);
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageRequest.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryValidatorSlashesRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryValidatorSlashesRequest();
        message.validatorAddress = object.validatorAddress ?? "";
        message.startingHeight = object.startingHeight ?? 0;
        message.endingHeight = object.endingHeight ?? 0;
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageRequest.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryValidatorSlashesResponse() {
    return { slashes: [], pagination: undefined };
}
const QueryValidatorSlashesResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.slashes) {
            ValidatorSlashEvent.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorSlashesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.slashes.push(ValidatorSlashEvent.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageResponse.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            slashes: Array.isArray(object?.slashes) ? object.slashes.map((e) => ValidatorSlashEvent.fromJSON(e)) : [],
            pagination: isSet$h(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.slashes?.length) {
            obj.slashes = message.slashes.map((e) => ValidatorSlashEvent.toJSON(e));
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageResponse.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryValidatorSlashesResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryValidatorSlashesResponse();
        message.slashes = object.slashes?.map((e) => ValidatorSlashEvent.fromPartial(e)) || [];
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageResponse.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryDelegationRewardsRequest() {
    return { delegatorAddress: "", validatorAddress: "" };
}
const QueryDelegationRewardsRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.delegatorAddress !== "") {
            writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
            writer.uint32(18).string(message.validatorAddress);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegationRewardsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.delegatorAddress = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.validatorAddress = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            delegatorAddress: isSet$h(object.delegatorAddress) ? String(object.delegatorAddress) : "",
            validatorAddress: isSet$h(object.validatorAddress) ? String(object.validatorAddress) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.delegatorAddress !== "") {
            obj.delegatorAddress = message.delegatorAddress;
        }
        if (message.validatorAddress !== "") {
            obj.validatorAddress = message.validatorAddress;
        }
        return obj;
    },
    create(base) {
        return QueryDelegationRewardsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryDelegationRewardsRequest();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        return message;
    },
};
function createBaseQueryDelegationRewardsResponse() {
    return { rewards: [] };
}
const QueryDelegationRewardsResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.rewards) {
            DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegationRewardsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.rewards.push(DecCoin.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { rewards: Array.isArray(object?.rewards) ? object.rewards.map((e) => DecCoin.fromJSON(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.rewards?.length) {
            obj.rewards = message.rewards.map((e) => DecCoin.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return QueryDelegationRewardsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryDelegationRewardsResponse();
        message.rewards = object.rewards?.map((e) => DecCoin.fromPartial(e)) || [];
        return message;
    },
};
function createBaseQueryDelegationTotalRewardsRequest() {
    return { delegatorAddress: "" };
}
const QueryDelegationTotalRewardsRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.delegatorAddress !== "") {
            writer.uint32(10).string(message.delegatorAddress);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegationTotalRewardsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.delegatorAddress = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { delegatorAddress: isSet$h(object.delegatorAddress) ? String(object.delegatorAddress) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.delegatorAddress !== "") {
            obj.delegatorAddress = message.delegatorAddress;
        }
        return obj;
    },
    create(base) {
        return QueryDelegationTotalRewardsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryDelegationTotalRewardsRequest();
        message.delegatorAddress = object.delegatorAddress ?? "";
        return message;
    },
};
function createBaseQueryDelegationTotalRewardsResponse() {
    return { rewards: [], total: [] };
}
const QueryDelegationTotalRewardsResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.rewards) {
            DelegationDelegatorReward.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.total) {
            DecCoin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegationTotalRewardsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.rewards.push(DelegationDelegatorReward.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.total.push(DecCoin.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            rewards: Array.isArray(object?.rewards)
                ? object.rewards.map((e) => DelegationDelegatorReward.fromJSON(e))
                : [],
            total: Array.isArray(object?.total) ? object.total.map((e) => DecCoin.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.rewards?.length) {
            obj.rewards = message.rewards.map((e) => DelegationDelegatorReward.toJSON(e));
        }
        if (message.total?.length) {
            obj.total = message.total.map((e) => DecCoin.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return QueryDelegationTotalRewardsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryDelegationTotalRewardsResponse();
        message.rewards = object.rewards?.map((e) => DelegationDelegatorReward.fromPartial(e)) || [];
        message.total = object.total?.map((e) => DecCoin.fromPartial(e)) || [];
        return message;
    },
};
function createBaseQueryDelegatorValidatorsRequest$1() {
    return { delegatorAddress: "" };
}
const QueryDelegatorValidatorsRequest$1 = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.delegatorAddress !== "") {
            writer.uint32(10).string(message.delegatorAddress);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorValidatorsRequest$1();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.delegatorAddress = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { delegatorAddress: isSet$h(object.delegatorAddress) ? String(object.delegatorAddress) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.delegatorAddress !== "") {
            obj.delegatorAddress = message.delegatorAddress;
        }
        return obj;
    },
    create(base) {
        return QueryDelegatorValidatorsRequest$1.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryDelegatorValidatorsRequest$1();
        message.delegatorAddress = object.delegatorAddress ?? "";
        return message;
    },
};
function createBaseQueryDelegatorValidatorsResponse$1() {
    return { validators: [] };
}
const QueryDelegatorValidatorsResponse$1 = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.validators) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorValidatorsResponse$1();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.validators.push(reader.string());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { validators: Array.isArray(object?.validators) ? object.validators.map((e) => String(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.validators?.length) {
            obj.validators = message.validators;
        }
        return obj;
    },
    create(base) {
        return QueryDelegatorValidatorsResponse$1.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryDelegatorValidatorsResponse$1();
        message.validators = object.validators?.map((e) => e) || [];
        return message;
    },
};
function createBaseQueryDelegatorWithdrawAddressRequest() {
    return { delegatorAddress: "" };
}
const QueryDelegatorWithdrawAddressRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.delegatorAddress !== "") {
            writer.uint32(10).string(message.delegatorAddress);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorWithdrawAddressRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.delegatorAddress = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { delegatorAddress: isSet$h(object.delegatorAddress) ? String(object.delegatorAddress) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.delegatorAddress !== "") {
            obj.delegatorAddress = message.delegatorAddress;
        }
        return obj;
    },
    create(base) {
        return QueryDelegatorWithdrawAddressRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryDelegatorWithdrawAddressRequest();
        message.delegatorAddress = object.delegatorAddress ?? "";
        return message;
    },
};
function createBaseQueryDelegatorWithdrawAddressResponse() {
    return { withdrawAddress: "" };
}
const QueryDelegatorWithdrawAddressResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.withdrawAddress !== "") {
            writer.uint32(10).string(message.withdrawAddress);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorWithdrawAddressResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.withdrawAddress = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { withdrawAddress: isSet$h(object.withdrawAddress) ? String(object.withdrawAddress) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.withdrawAddress !== "") {
            obj.withdrawAddress = message.withdrawAddress;
        }
        return obj;
    },
    create(base) {
        return QueryDelegatorWithdrawAddressResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryDelegatorWithdrawAddressResponse();
        message.withdrawAddress = object.withdrawAddress ?? "";
        return message;
    },
};
function createBaseQueryCommunityPoolRequest() {
    return {};
}
const QueryCommunityPoolRequest = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryCommunityPoolRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return QueryCommunityPoolRequest.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseQueryCommunityPoolRequest();
        return message;
    },
};
function createBaseQueryCommunityPoolResponse() {
    return { pool: [] };
}
const QueryCommunityPoolResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.pool) {
            DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryCommunityPoolResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.pool.push(DecCoin.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { pool: Array.isArray(object?.pool) ? object.pool.map((e) => DecCoin.fromJSON(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.pool?.length) {
            obj.pool = message.pool.map((e) => DecCoin.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return QueryCommunityPoolResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryCommunityPoolResponse();
        message.pool = object.pool?.map((e) => DecCoin.fromPartial(e)) || [];
        return message;
    },
};
let QueryClientImpl$3 = class QueryClientImpl {
    rpc;
    constructor(rpc) {
        this.rpc = rpc;
        this.Params = this.Params.bind(this);
        this.ValidatorOutstandingRewards = this.ValidatorOutstandingRewards.bind(this);
        this.ValidatorCommission = this.ValidatorCommission.bind(this);
        this.ValidatorSlashes = this.ValidatorSlashes.bind(this);
        this.DelegationRewards = this.DelegationRewards.bind(this);
        this.DelegationTotalRewards = this.DelegationTotalRewards.bind(this);
        this.DelegatorValidators = this.DelegatorValidators.bind(this);
        this.DelegatorWithdrawAddress = this.DelegatorWithdrawAddress.bind(this);
        this.CommunityPool = this.CommunityPool.bind(this);
    }
    Params(request, metadata) {
        return this.rpc.unary(QueryParamsDesc$3, QueryParamsRequest$3.fromPartial(request), metadata);
    }
    ValidatorOutstandingRewards(request, metadata) {
        return this.rpc.unary(QueryValidatorOutstandingRewardsDesc, QueryValidatorOutstandingRewardsRequest.fromPartial(request), metadata);
    }
    ValidatorCommission(request, metadata) {
        return this.rpc.unary(QueryValidatorCommissionDesc, QueryValidatorCommissionRequest.fromPartial(request), metadata);
    }
    ValidatorSlashes(request, metadata) {
        return this.rpc.unary(QueryValidatorSlashesDesc, QueryValidatorSlashesRequest.fromPartial(request), metadata);
    }
    DelegationRewards(request, metadata) {
        return this.rpc.unary(QueryDelegationRewardsDesc, QueryDelegationRewardsRequest.fromPartial(request), metadata);
    }
    DelegationTotalRewards(request, metadata) {
        return this.rpc.unary(QueryDelegationTotalRewardsDesc, QueryDelegationTotalRewardsRequest.fromPartial(request), metadata);
    }
    DelegatorValidators(request, metadata) {
        return this.rpc.unary(QueryDelegatorValidatorsDesc$1, QueryDelegatorValidatorsRequest$1.fromPartial(request), metadata);
    }
    DelegatorWithdrawAddress(request, metadata) {
        return this.rpc.unary(QueryDelegatorWithdrawAddressDesc, QueryDelegatorWithdrawAddressRequest.fromPartial(request), metadata);
    }
    CommunityPool(request, metadata) {
        return this.rpc.unary(QueryCommunityPoolDesc, QueryCommunityPoolRequest.fromPartial(request), metadata);
    }
};
const QueryDesc$3 = { serviceName: "cosmos.distribution.v1beta1.Query" };
const QueryParamsDesc$3 = {
    methodName: "Params",
    service: QueryDesc$3,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryParamsRequest$3.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryParamsResponse$3.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryValidatorOutstandingRewardsDesc = {
    methodName: "ValidatorOutstandingRewards",
    service: QueryDesc$3,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryValidatorOutstandingRewardsRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryValidatorOutstandingRewardsResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryValidatorCommissionDesc = {
    methodName: "ValidatorCommission",
    service: QueryDesc$3,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryValidatorCommissionRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryValidatorCommissionResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryValidatorSlashesDesc = {
    methodName: "ValidatorSlashes",
    service: QueryDesc$3,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryValidatorSlashesRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryValidatorSlashesResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryDelegationRewardsDesc = {
    methodName: "DelegationRewards",
    service: QueryDesc$3,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryDelegationRewardsRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryDelegationRewardsResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryDelegationTotalRewardsDesc = {
    methodName: "DelegationTotalRewards",
    service: QueryDesc$3,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryDelegationTotalRewardsRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryDelegationTotalRewardsResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryDelegatorValidatorsDesc$1 = {
    methodName: "DelegatorValidators",
    service: QueryDesc$3,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryDelegatorValidatorsRequest$1.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryDelegatorValidatorsResponse$1.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryDelegatorWithdrawAddressDesc = {
    methodName: "DelegatorWithdrawAddress",
    service: QueryDesc$3,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryDelegatorWithdrawAddressRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryDelegatorWithdrawAddressResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryCommunityPoolDesc = {
    methodName: "CommunityPool",
    service: QueryDesc$3,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryCommunityPoolRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryCommunityPoolResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
let GrpcWebImpl$d = class GrpcWebImpl {
    host;
    options;
    constructor(host, options) {
        this.host = host;
        this.options = options;
    }
    unary(methodDesc, _request, metadata) {
        const request = { ..._request, ...methodDesc.requestType };
        const maybeCombinedMetadata = metadata && this.options.metadata
            ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
            : metadata ?? this.options.metadata;
        return new Promise((resolve, reject) => {
            grpc.unary(methodDesc, {
                request,
                host: this.host,
                metadata: maybeCombinedMetadata ?? {},
                ...(this.options.transport !== undefined ? { transport: this.options.transport } : {}),
                debug: this.options.debug ?? false,
                onEnd: function (response) {
                    if (response.status === grpc.Code.OK) {
                        resolve(response.message.toObject());
                    }
                    else {
                        const err = new GrpcWebError$d(response.statusMessage, response.status, response.trailers);
                        reject(err);
                    }
                },
            });
        });
    }
};
const tsProtoGlobalThis$h = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function longToNumber$7(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new tsProtoGlobalThis$h.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isSet$h(value) {
    return value !== null && value !== undefined;
}
let GrpcWebError$d = class GrpcWebError extends tsProtoGlobalThis$h.Error {
    code;
    metadata;
    constructor(message, code, metadata) {
        super(message);
        this.code = code;
        this.metadata = metadata;
    }
};

/* eslint-disable */
const protobufPackage$g = "google.protobuf";
function createBaseAny() {
    return { typeUrl: "", value: new Uint8Array(0) };
}
const Any = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.typeUrl !== "") {
            writer.uint32(10).string(message.typeUrl);
        }
        if (message.value.length !== 0) {
            writer.uint32(18).bytes(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseAny();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.typeUrl = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            typeUrl: isSet$g(object.typeUrl) ? String(object.typeUrl) : "",
            value: isSet$g(object.value) ? bytesFromBase64$2(object.value) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.typeUrl !== "") {
            obj.typeUrl = message.typeUrl;
        }
        if (message.value.length !== 0) {
            obj.value = base64FromBytes$2(message.value);
        }
        return obj;
    },
    create(base) {
        return Any.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseAny();
        message.typeUrl = object.typeUrl ?? "";
        message.value = object.value ?? new Uint8Array(0);
        return message;
    },
};
const tsProtoGlobalThis$g = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function bytesFromBase64$2(b64) {
    if (tsProtoGlobalThis$g.Buffer) {
        return Uint8Array.from(tsProtoGlobalThis$g.Buffer.from(b64, "base64"));
    }
    else {
        const bin = tsProtoGlobalThis$g.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes$2(arr) {
    if (tsProtoGlobalThis$g.Buffer) {
        return tsProtoGlobalThis$g.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(String.fromCharCode(byte));
        });
        return tsProtoGlobalThis$g.btoa(bin.join(""));
    }
}
function isSet$g(value) {
    return value !== null && value !== undefined;
}

/* eslint-disable */
const protobufPackage$f = "cosmos.gov.v1beta1";
/** VoteOption enumerates the valid vote options for a given governance proposal. */
var VoteOption;
(function (VoteOption) {
    /** VOTE_OPTION_UNSPECIFIED - VOTE_OPTION_UNSPECIFIED defines a no-op vote option. */
    VoteOption[VoteOption["VOTE_OPTION_UNSPECIFIED"] = 0] = "VOTE_OPTION_UNSPECIFIED";
    /** VOTE_OPTION_YES - VOTE_OPTION_YES defines a yes vote option. */
    VoteOption[VoteOption["VOTE_OPTION_YES"] = 1] = "VOTE_OPTION_YES";
    /** VOTE_OPTION_ABSTAIN - VOTE_OPTION_ABSTAIN defines an abstain vote option. */
    VoteOption[VoteOption["VOTE_OPTION_ABSTAIN"] = 2] = "VOTE_OPTION_ABSTAIN";
    /** VOTE_OPTION_NO - VOTE_OPTION_NO defines a no vote option. */
    VoteOption[VoteOption["VOTE_OPTION_NO"] = 3] = "VOTE_OPTION_NO";
    /** VOTE_OPTION_NO_WITH_VETO - VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option. */
    VoteOption[VoteOption["VOTE_OPTION_NO_WITH_VETO"] = 4] = "VOTE_OPTION_NO_WITH_VETO";
    VoteOption[VoteOption["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(VoteOption || (VoteOption = {}));
function voteOptionFromJSON(object) {
    switch (object) {
        case 0:
        case "VOTE_OPTION_UNSPECIFIED":
            return VoteOption.VOTE_OPTION_UNSPECIFIED;
        case 1:
        case "VOTE_OPTION_YES":
            return VoteOption.VOTE_OPTION_YES;
        case 2:
        case "VOTE_OPTION_ABSTAIN":
            return VoteOption.VOTE_OPTION_ABSTAIN;
        case 3:
        case "VOTE_OPTION_NO":
            return VoteOption.VOTE_OPTION_NO;
        case 4:
        case "VOTE_OPTION_NO_WITH_VETO":
            return VoteOption.VOTE_OPTION_NO_WITH_VETO;
        case -1:
        case "UNRECOGNIZED":
        default:
            return VoteOption.UNRECOGNIZED;
    }
}
function voteOptionToJSON(object) {
    switch (object) {
        case VoteOption.VOTE_OPTION_UNSPECIFIED:
            return "VOTE_OPTION_UNSPECIFIED";
        case VoteOption.VOTE_OPTION_YES:
            return "VOTE_OPTION_YES";
        case VoteOption.VOTE_OPTION_ABSTAIN:
            return "VOTE_OPTION_ABSTAIN";
        case VoteOption.VOTE_OPTION_NO:
            return "VOTE_OPTION_NO";
        case VoteOption.VOTE_OPTION_NO_WITH_VETO:
            return "VOTE_OPTION_NO_WITH_VETO";
        case VoteOption.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
/** ProposalStatus enumerates the valid statuses of a proposal. */
var ProposalStatus;
(function (ProposalStatus) {
    /** PROPOSAL_STATUS_UNSPECIFIED - PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status. */
    ProposalStatus[ProposalStatus["PROPOSAL_STATUS_UNSPECIFIED"] = 0] = "PROPOSAL_STATUS_UNSPECIFIED";
    /**
     * PROPOSAL_STATUS_DEPOSIT_PERIOD - PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit
     * period.
     */
    ProposalStatus[ProposalStatus["PROPOSAL_STATUS_DEPOSIT_PERIOD"] = 1] = "PROPOSAL_STATUS_DEPOSIT_PERIOD";
    /**
     * PROPOSAL_STATUS_VOTING_PERIOD - PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting
     * period.
     */
    ProposalStatus[ProposalStatus["PROPOSAL_STATUS_VOTING_PERIOD"] = 2] = "PROPOSAL_STATUS_VOTING_PERIOD";
    /**
     * PROPOSAL_STATUS_PASSED - PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has
     * passed.
     */
    ProposalStatus[ProposalStatus["PROPOSAL_STATUS_PASSED"] = 3] = "PROPOSAL_STATUS_PASSED";
    /**
     * PROPOSAL_STATUS_REJECTED - PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has
     * been rejected.
     */
    ProposalStatus[ProposalStatus["PROPOSAL_STATUS_REJECTED"] = 4] = "PROPOSAL_STATUS_REJECTED";
    /**
     * PROPOSAL_STATUS_FAILED - PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has
     * failed.
     */
    ProposalStatus[ProposalStatus["PROPOSAL_STATUS_FAILED"] = 5] = "PROPOSAL_STATUS_FAILED";
    ProposalStatus[ProposalStatus["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ProposalStatus || (ProposalStatus = {}));
function proposalStatusFromJSON(object) {
    switch (object) {
        case 0:
        case "PROPOSAL_STATUS_UNSPECIFIED":
            return ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED;
        case 1:
        case "PROPOSAL_STATUS_DEPOSIT_PERIOD":
            return ProposalStatus.PROPOSAL_STATUS_DEPOSIT_PERIOD;
        case 2:
        case "PROPOSAL_STATUS_VOTING_PERIOD":
            return ProposalStatus.PROPOSAL_STATUS_VOTING_PERIOD;
        case 3:
        case "PROPOSAL_STATUS_PASSED":
            return ProposalStatus.PROPOSAL_STATUS_PASSED;
        case 4:
        case "PROPOSAL_STATUS_REJECTED":
            return ProposalStatus.PROPOSAL_STATUS_REJECTED;
        case 5:
        case "PROPOSAL_STATUS_FAILED":
            return ProposalStatus.PROPOSAL_STATUS_FAILED;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ProposalStatus.UNRECOGNIZED;
    }
}
function proposalStatusToJSON(object) {
    switch (object) {
        case ProposalStatus.PROPOSAL_STATUS_UNSPECIFIED:
            return "PROPOSAL_STATUS_UNSPECIFIED";
        case ProposalStatus.PROPOSAL_STATUS_DEPOSIT_PERIOD:
            return "PROPOSAL_STATUS_DEPOSIT_PERIOD";
        case ProposalStatus.PROPOSAL_STATUS_VOTING_PERIOD:
            return "PROPOSAL_STATUS_VOTING_PERIOD";
        case ProposalStatus.PROPOSAL_STATUS_PASSED:
            return "PROPOSAL_STATUS_PASSED";
        case ProposalStatus.PROPOSAL_STATUS_REJECTED:
            return "PROPOSAL_STATUS_REJECTED";
        case ProposalStatus.PROPOSAL_STATUS_FAILED:
            return "PROPOSAL_STATUS_FAILED";
        case ProposalStatus.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseWeightedVoteOption() {
    return { option: 0, weight: "" };
}
const WeightedVoteOption = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.option !== 0) {
            writer.uint32(8).int32(message.option);
        }
        if (message.weight !== "") {
            writer.uint32(18).string(message.weight);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWeightedVoteOption();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.option = reader.int32();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.weight = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            option: isSet$f(object.option) ? voteOptionFromJSON(object.option) : 0,
            weight: isSet$f(object.weight) ? String(object.weight) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.option !== 0) {
            obj.option = voteOptionToJSON(message.option);
        }
        if (message.weight !== "") {
            obj.weight = message.weight;
        }
        return obj;
    },
    create(base) {
        return WeightedVoteOption.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseWeightedVoteOption();
        message.option = object.option ?? 0;
        message.weight = object.weight ?? "";
        return message;
    },
};
function createBaseTextProposal() {
    return { title: "", description: "" };
}
const TextProposal = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.title !== "") {
            writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
            writer.uint32(18).string(message.description);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTextProposal();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.title = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.description = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            title: isSet$f(object.title) ? String(object.title) : "",
            description: isSet$f(object.description) ? String(object.description) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.title !== "") {
            obj.title = message.title;
        }
        if (message.description !== "") {
            obj.description = message.description;
        }
        return obj;
    },
    create(base) {
        return TextProposal.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTextProposal();
        message.title = object.title ?? "";
        message.description = object.description ?? "";
        return message;
    },
};
function createBaseDeposit() {
    return { proposalId: 0, depositor: "", amount: [] };
}
const Deposit = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.proposalId !== 0) {
            writer.uint32(8).uint64(message.proposalId);
        }
        if (message.depositor !== "") {
            writer.uint32(18).string(message.depositor);
        }
        for (const v of message.amount) {
            Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDeposit();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.proposalId = longToNumber$6(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.depositor = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.amount.push(Coin.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            proposalId: isSet$f(object.proposalId) ? Number(object.proposalId) : 0,
            depositor: isSet$f(object.depositor) ? String(object.depositor) : "",
            amount: Array.isArray(object?.amount) ? object.amount.map((e) => Coin.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.proposalId !== 0) {
            obj.proposalId = Math.round(message.proposalId);
        }
        if (message.depositor !== "") {
            obj.depositor = message.depositor;
        }
        if (message.amount?.length) {
            obj.amount = message.amount.map((e) => Coin.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return Deposit.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDeposit();
        message.proposalId = object.proposalId ?? 0;
        message.depositor = object.depositor ?? "";
        message.amount = object.amount?.map((e) => Coin.fromPartial(e)) || [];
        return message;
    },
};
function createBaseProposal() {
    return {
        proposalId: 0,
        content: undefined,
        status: 0,
        finalTallyResult: undefined,
        submitTime: undefined,
        depositEndTime: undefined,
        totalDeposit: [],
        votingStartTime: undefined,
        votingEndTime: undefined,
    };
}
const Proposal = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.proposalId !== 0) {
            writer.uint32(8).uint64(message.proposalId);
        }
        if (message.content !== undefined) {
            Any.encode(message.content, writer.uint32(18).fork()).ldelim();
        }
        if (message.status !== 0) {
            writer.uint32(24).int32(message.status);
        }
        if (message.finalTallyResult !== undefined) {
            TallyResult.encode(message.finalTallyResult, writer.uint32(34).fork()).ldelim();
        }
        if (message.submitTime !== undefined) {
            Timestamp.encode(toTimestamp$3(message.submitTime), writer.uint32(42).fork()).ldelim();
        }
        if (message.depositEndTime !== undefined) {
            Timestamp.encode(toTimestamp$3(message.depositEndTime), writer.uint32(50).fork()).ldelim();
        }
        for (const v of message.totalDeposit) {
            Coin.encode(v, writer.uint32(58).fork()).ldelim();
        }
        if (message.votingStartTime !== undefined) {
            Timestamp.encode(toTimestamp$3(message.votingStartTime), writer.uint32(66).fork()).ldelim();
        }
        if (message.votingEndTime !== undefined) {
            Timestamp.encode(toTimestamp$3(message.votingEndTime), writer.uint32(74).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProposal();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.proposalId = longToNumber$6(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.content = Any.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.status = reader.int32();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.finalTallyResult = TallyResult.decode(reader, reader.uint32());
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.submitTime = fromTimestamp$3(Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.depositEndTime = fromTimestamp$3(Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.totalDeposit.push(Coin.decode(reader, reader.uint32()));
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.votingStartTime = fromTimestamp$3(Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.votingEndTime = fromTimestamp$3(Timestamp.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            proposalId: isSet$f(object.proposalId) ? Number(object.proposalId) : 0,
            content: isSet$f(object.content) ? Any.fromJSON(object.content) : undefined,
            status: isSet$f(object.status) ? proposalStatusFromJSON(object.status) : 0,
            finalTallyResult: isSet$f(object.finalTallyResult) ? TallyResult.fromJSON(object.finalTallyResult) : undefined,
            submitTime: isSet$f(object.submitTime) ? fromJsonTimestamp$3(object.submitTime) : undefined,
            depositEndTime: isSet$f(object.depositEndTime) ? fromJsonTimestamp$3(object.depositEndTime) : undefined,
            totalDeposit: Array.isArray(object?.totalDeposit) ? object.totalDeposit.map((e) => Coin.fromJSON(e)) : [],
            votingStartTime: isSet$f(object.votingStartTime) ? fromJsonTimestamp$3(object.votingStartTime) : undefined,
            votingEndTime: isSet$f(object.votingEndTime) ? fromJsonTimestamp$3(object.votingEndTime) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.proposalId !== 0) {
            obj.proposalId = Math.round(message.proposalId);
        }
        if (message.content !== undefined) {
            obj.content = Any.toJSON(message.content);
        }
        if (message.status !== 0) {
            obj.status = proposalStatusToJSON(message.status);
        }
        if (message.finalTallyResult !== undefined) {
            obj.finalTallyResult = TallyResult.toJSON(message.finalTallyResult);
        }
        if (message.submitTime !== undefined) {
            obj.submitTime = message.submitTime.toISOString();
        }
        if (message.depositEndTime !== undefined) {
            obj.depositEndTime = message.depositEndTime.toISOString();
        }
        if (message.totalDeposit?.length) {
            obj.totalDeposit = message.totalDeposit.map((e) => Coin.toJSON(e));
        }
        if (message.votingStartTime !== undefined) {
            obj.votingStartTime = message.votingStartTime.toISOString();
        }
        if (message.votingEndTime !== undefined) {
            obj.votingEndTime = message.votingEndTime.toISOString();
        }
        return obj;
    },
    create(base) {
        return Proposal.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseProposal();
        message.proposalId = object.proposalId ?? 0;
        message.content = (object.content !== undefined && object.content !== null)
            ? Any.fromPartial(object.content)
            : undefined;
        message.status = object.status ?? 0;
        message.finalTallyResult = (object.finalTallyResult !== undefined && object.finalTallyResult !== null)
            ? TallyResult.fromPartial(object.finalTallyResult)
            : undefined;
        message.submitTime = object.submitTime ?? undefined;
        message.depositEndTime = object.depositEndTime ?? undefined;
        message.totalDeposit = object.totalDeposit?.map((e) => Coin.fromPartial(e)) || [];
        message.votingStartTime = object.votingStartTime ?? undefined;
        message.votingEndTime = object.votingEndTime ?? undefined;
        return message;
    },
};
function createBaseTallyResult() {
    return { yes: "", abstain: "", no: "", noWithVeto: "" };
}
const TallyResult = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.yes !== "") {
            writer.uint32(10).string(message.yes);
        }
        if (message.abstain !== "") {
            writer.uint32(18).string(message.abstain);
        }
        if (message.no !== "") {
            writer.uint32(26).string(message.no);
        }
        if (message.noWithVeto !== "") {
            writer.uint32(34).string(message.noWithVeto);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTallyResult();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.yes = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.abstain = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.no = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.noWithVeto = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            yes: isSet$f(object.yes) ? String(object.yes) : "",
            abstain: isSet$f(object.abstain) ? String(object.abstain) : "",
            no: isSet$f(object.no) ? String(object.no) : "",
            noWithVeto: isSet$f(object.noWithVeto) ? String(object.noWithVeto) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.yes !== "") {
            obj.yes = message.yes;
        }
        if (message.abstain !== "") {
            obj.abstain = message.abstain;
        }
        if (message.no !== "") {
            obj.no = message.no;
        }
        if (message.noWithVeto !== "") {
            obj.noWithVeto = message.noWithVeto;
        }
        return obj;
    },
    create(base) {
        return TallyResult.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTallyResult();
        message.yes = object.yes ?? "";
        message.abstain = object.abstain ?? "";
        message.no = object.no ?? "";
        message.noWithVeto = object.noWithVeto ?? "";
        return message;
    },
};
function createBaseVote() {
    return { proposalId: 0, voter: "", option: 0, options: [] };
}
const Vote = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.proposalId !== 0) {
            writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
            writer.uint32(18).string(message.voter);
        }
        if (message.option !== 0) {
            writer.uint32(24).int32(message.option);
        }
        for (const v of message.options) {
            WeightedVoteOption.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVote();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.proposalId = longToNumber$6(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.voter = reader.string();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.option = reader.int32();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.options.push(WeightedVoteOption.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            proposalId: isSet$f(object.proposalId) ? Number(object.proposalId) : 0,
            voter: isSet$f(object.voter) ? String(object.voter) : "",
            option: isSet$f(object.option) ? voteOptionFromJSON(object.option) : 0,
            options: Array.isArray(object?.options) ? object.options.map((e) => WeightedVoteOption.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.proposalId !== 0) {
            obj.proposalId = Math.round(message.proposalId);
        }
        if (message.voter !== "") {
            obj.voter = message.voter;
        }
        if (message.option !== 0) {
            obj.option = voteOptionToJSON(message.option);
        }
        if (message.options?.length) {
            obj.options = message.options.map((e) => WeightedVoteOption.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return Vote.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseVote();
        message.proposalId = object.proposalId ?? 0;
        message.voter = object.voter ?? "";
        message.option = object.option ?? 0;
        message.options = object.options?.map((e) => WeightedVoteOption.fromPartial(e)) || [];
        return message;
    },
};
function createBaseDepositParams() {
    return { minDeposit: [], maxDepositPeriod: undefined };
}
const DepositParams = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.minDeposit) {
            Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.maxDepositPeriod !== undefined) {
            Duration.encode(message.maxDepositPeriod, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDepositParams();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.minDeposit.push(Coin.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.maxDepositPeriod = Duration.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            minDeposit: Array.isArray(object?.minDeposit) ? object.minDeposit.map((e) => Coin.fromJSON(e)) : [],
            maxDepositPeriod: isSet$f(object.maxDepositPeriod) ? Duration.fromJSON(object.maxDepositPeriod) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.minDeposit?.length) {
            obj.minDeposit = message.minDeposit.map((e) => Coin.toJSON(e));
        }
        if (message.maxDepositPeriod !== undefined) {
            obj.maxDepositPeriod = Duration.toJSON(message.maxDepositPeriod);
        }
        return obj;
    },
    create(base) {
        return DepositParams.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDepositParams();
        message.minDeposit = object.minDeposit?.map((e) => Coin.fromPartial(e)) || [];
        message.maxDepositPeriod = (object.maxDepositPeriod !== undefined && object.maxDepositPeriod !== null)
            ? Duration.fromPartial(object.maxDepositPeriod)
            : undefined;
        return message;
    },
};
function createBaseVotingParams() {
    return { votingPeriod: undefined };
}
const VotingParams = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.votingPeriod !== undefined) {
            Duration.encode(message.votingPeriod, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseVotingParams();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.votingPeriod = Duration.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { votingPeriod: isSet$f(object.votingPeriod) ? Duration.fromJSON(object.votingPeriod) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.votingPeriod !== undefined) {
            obj.votingPeriod = Duration.toJSON(message.votingPeriod);
        }
        return obj;
    },
    create(base) {
        return VotingParams.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseVotingParams();
        message.votingPeriod = (object.votingPeriod !== undefined && object.votingPeriod !== null)
            ? Duration.fromPartial(object.votingPeriod)
            : undefined;
        return message;
    },
};
function createBaseTallyParams() {
    return { quorum: new Uint8Array(0), threshold: new Uint8Array(0), vetoThreshold: new Uint8Array(0) };
}
const TallyParams = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.quorum.length !== 0) {
            writer.uint32(10).bytes(message.quorum);
        }
        if (message.threshold.length !== 0) {
            writer.uint32(18).bytes(message.threshold);
        }
        if (message.vetoThreshold.length !== 0) {
            writer.uint32(26).bytes(message.vetoThreshold);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTallyParams();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.quorum = reader.bytes();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.threshold = reader.bytes();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.vetoThreshold = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            quorum: isSet$f(object.quorum) ? bytesFromBase64$1(object.quorum) : new Uint8Array(0),
            threshold: isSet$f(object.threshold) ? bytesFromBase64$1(object.threshold) : new Uint8Array(0),
            vetoThreshold: isSet$f(object.vetoThreshold) ? bytesFromBase64$1(object.vetoThreshold) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.quorum.length !== 0) {
            obj.quorum = base64FromBytes$1(message.quorum);
        }
        if (message.threshold.length !== 0) {
            obj.threshold = base64FromBytes$1(message.threshold);
        }
        if (message.vetoThreshold.length !== 0) {
            obj.vetoThreshold = base64FromBytes$1(message.vetoThreshold);
        }
        return obj;
    },
    create(base) {
        return TallyParams.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTallyParams();
        message.quorum = object.quorum ?? new Uint8Array(0);
        message.threshold = object.threshold ?? new Uint8Array(0);
        message.vetoThreshold = object.vetoThreshold ?? new Uint8Array(0);
        return message;
    },
};
const tsProtoGlobalThis$f = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function bytesFromBase64$1(b64) {
    if (tsProtoGlobalThis$f.Buffer) {
        return Uint8Array.from(tsProtoGlobalThis$f.Buffer.from(b64, "base64"));
    }
    else {
        const bin = tsProtoGlobalThis$f.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes$1(arr) {
    if (tsProtoGlobalThis$f.Buffer) {
        return tsProtoGlobalThis$f.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(String.fromCharCode(byte));
        });
        return tsProtoGlobalThis$f.btoa(bin.join(""));
    }
}
function toTimestamp$3(date) {
    const seconds = date.getTime() / 1_000;
    const nanos = (date.getTime() % 1_000) * 1_000_000;
    return { seconds, nanos };
}
function fromTimestamp$3(t) {
    let millis = (t.seconds || 0) * 1_000;
    millis += (t.nanos || 0) / 1_000_000;
    return new Date(millis);
}
function fromJsonTimestamp$3(o) {
    if (o instanceof Date) {
        return o;
    }
    else if (typeof o === "string") {
        return new Date(o);
    }
    else {
        return fromTimestamp$3(Timestamp.fromJSON(o));
    }
}
function longToNumber$6(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new tsProtoGlobalThis$f.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isSet$f(value) {
    return value !== null && value !== undefined;
}

/* eslint-disable */
const protobufPackage$e = "cosmos.gov.v1beta1";
function createBaseQueryProposalRequest() {
    return { proposalId: 0 };
}
const QueryProposalRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.proposalId !== 0) {
            writer.uint32(8).uint64(message.proposalId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryProposalRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.proposalId = longToNumber$5(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { proposalId: isSet$e(object.proposalId) ? Number(object.proposalId) : 0 };
    },
    toJSON(message) {
        const obj = {};
        if (message.proposalId !== 0) {
            obj.proposalId = Math.round(message.proposalId);
        }
        return obj;
    },
    create(base) {
        return QueryProposalRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryProposalRequest();
        message.proposalId = object.proposalId ?? 0;
        return message;
    },
};
function createBaseQueryProposalResponse() {
    return { proposal: undefined };
}
const QueryProposalResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.proposal !== undefined) {
            Proposal.encode(message.proposal, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryProposalResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.proposal = Proposal.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { proposal: isSet$e(object.proposal) ? Proposal.fromJSON(object.proposal) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.proposal !== undefined) {
            obj.proposal = Proposal.toJSON(message.proposal);
        }
        return obj;
    },
    create(base) {
        return QueryProposalResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryProposalResponse();
        message.proposal = (object.proposal !== undefined && object.proposal !== null)
            ? Proposal.fromPartial(object.proposal)
            : undefined;
        return message;
    },
};
function createBaseQueryProposalsRequest() {
    return { proposalStatus: 0, voter: "", depositor: "", pagination: undefined };
}
const QueryProposalsRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.proposalStatus !== 0) {
            writer.uint32(8).int32(message.proposalStatus);
        }
        if (message.voter !== "") {
            writer.uint32(18).string(message.voter);
        }
        if (message.depositor !== "") {
            writer.uint32(26).string(message.depositor);
        }
        if (message.pagination !== undefined) {
            PageRequest.encode(message.pagination, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryProposalsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.proposalStatus = reader.int32();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.voter = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.depositor = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.pagination = PageRequest.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            proposalStatus: isSet$e(object.proposalStatus) ? proposalStatusFromJSON(object.proposalStatus) : 0,
            voter: isSet$e(object.voter) ? String(object.voter) : "",
            depositor: isSet$e(object.depositor) ? String(object.depositor) : "",
            pagination: isSet$e(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.proposalStatus !== 0) {
            obj.proposalStatus = proposalStatusToJSON(message.proposalStatus);
        }
        if (message.voter !== "") {
            obj.voter = message.voter;
        }
        if (message.depositor !== "") {
            obj.depositor = message.depositor;
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageRequest.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryProposalsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryProposalsRequest();
        message.proposalStatus = object.proposalStatus ?? 0;
        message.voter = object.voter ?? "";
        message.depositor = object.depositor ?? "";
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageRequest.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryProposalsResponse() {
    return { proposals: [], pagination: undefined };
}
const QueryProposalsResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.proposals) {
            Proposal.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryProposalsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.proposals.push(Proposal.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageResponse.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            proposals: Array.isArray(object?.proposals) ? object.proposals.map((e) => Proposal.fromJSON(e)) : [],
            pagination: isSet$e(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.proposals?.length) {
            obj.proposals = message.proposals.map((e) => Proposal.toJSON(e));
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageResponse.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryProposalsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryProposalsResponse();
        message.proposals = object.proposals?.map((e) => Proposal.fromPartial(e)) || [];
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageResponse.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryVoteRequest() {
    return { proposalId: 0, voter: "" };
}
const QueryVoteRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.proposalId !== 0) {
            writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
            writer.uint32(18).string(message.voter);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryVoteRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.proposalId = longToNumber$5(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.voter = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            proposalId: isSet$e(object.proposalId) ? Number(object.proposalId) : 0,
            voter: isSet$e(object.voter) ? String(object.voter) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.proposalId !== 0) {
            obj.proposalId = Math.round(message.proposalId);
        }
        if (message.voter !== "") {
            obj.voter = message.voter;
        }
        return obj;
    },
    create(base) {
        return QueryVoteRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryVoteRequest();
        message.proposalId = object.proposalId ?? 0;
        message.voter = object.voter ?? "";
        return message;
    },
};
function createBaseQueryVoteResponse() {
    return { vote: undefined };
}
const QueryVoteResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.vote !== undefined) {
            Vote.encode(message.vote, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryVoteResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.vote = Vote.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { vote: isSet$e(object.vote) ? Vote.fromJSON(object.vote) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.vote !== undefined) {
            obj.vote = Vote.toJSON(message.vote);
        }
        return obj;
    },
    create(base) {
        return QueryVoteResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryVoteResponse();
        message.vote = (object.vote !== undefined && object.vote !== null) ? Vote.fromPartial(object.vote) : undefined;
        return message;
    },
};
function createBaseQueryVotesRequest() {
    return { proposalId: 0, pagination: undefined };
}
const QueryVotesRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.proposalId !== 0) {
            writer.uint32(8).uint64(message.proposalId);
        }
        if (message.pagination !== undefined) {
            PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryVotesRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.proposalId = longToNumber$5(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageRequest.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            proposalId: isSet$e(object.proposalId) ? Number(object.proposalId) : 0,
            pagination: isSet$e(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.proposalId !== 0) {
            obj.proposalId = Math.round(message.proposalId);
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageRequest.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryVotesRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryVotesRequest();
        message.proposalId = object.proposalId ?? 0;
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageRequest.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryVotesResponse() {
    return { votes: [], pagination: undefined };
}
const QueryVotesResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.votes) {
            Vote.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryVotesResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.votes.push(Vote.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageResponse.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            votes: Array.isArray(object?.votes) ? object.votes.map((e) => Vote.fromJSON(e)) : [],
            pagination: isSet$e(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.votes?.length) {
            obj.votes = message.votes.map((e) => Vote.toJSON(e));
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageResponse.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryVotesResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryVotesResponse();
        message.votes = object.votes?.map((e) => Vote.fromPartial(e)) || [];
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageResponse.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryParamsRequest$2() {
    return { paramsType: "" };
}
const QueryParamsRequest$2 = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.paramsType !== "") {
            writer.uint32(10).string(message.paramsType);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest$2();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.paramsType = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { paramsType: isSet$e(object.paramsType) ? String(object.paramsType) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.paramsType !== "") {
            obj.paramsType = message.paramsType;
        }
        return obj;
    },
    create(base) {
        return QueryParamsRequest$2.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryParamsRequest$2();
        message.paramsType = object.paramsType ?? "";
        return message;
    },
};
function createBaseQueryParamsResponse$2() {
    return { votingParams: undefined, depositParams: undefined, tallyParams: undefined };
}
const QueryParamsResponse$2 = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.votingParams !== undefined) {
            VotingParams.encode(message.votingParams, writer.uint32(10).fork()).ldelim();
        }
        if (message.depositParams !== undefined) {
            DepositParams.encode(message.depositParams, writer.uint32(18).fork()).ldelim();
        }
        if (message.tallyParams !== undefined) {
            TallyParams.encode(message.tallyParams, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse$2();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.votingParams = VotingParams.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.depositParams = DepositParams.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.tallyParams = TallyParams.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            votingParams: isSet$e(object.votingParams) ? VotingParams.fromJSON(object.votingParams) : undefined,
            depositParams: isSet$e(object.depositParams) ? DepositParams.fromJSON(object.depositParams) : undefined,
            tallyParams: isSet$e(object.tallyParams) ? TallyParams.fromJSON(object.tallyParams) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.votingParams !== undefined) {
            obj.votingParams = VotingParams.toJSON(message.votingParams);
        }
        if (message.depositParams !== undefined) {
            obj.depositParams = DepositParams.toJSON(message.depositParams);
        }
        if (message.tallyParams !== undefined) {
            obj.tallyParams = TallyParams.toJSON(message.tallyParams);
        }
        return obj;
    },
    create(base) {
        return QueryParamsResponse$2.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryParamsResponse$2();
        message.votingParams = (object.votingParams !== undefined && object.votingParams !== null)
            ? VotingParams.fromPartial(object.votingParams)
            : undefined;
        message.depositParams = (object.depositParams !== undefined && object.depositParams !== null)
            ? DepositParams.fromPartial(object.depositParams)
            : undefined;
        message.tallyParams = (object.tallyParams !== undefined && object.tallyParams !== null)
            ? TallyParams.fromPartial(object.tallyParams)
            : undefined;
        return message;
    },
};
function createBaseQueryDepositRequest() {
    return { proposalId: 0, depositor: "" };
}
const QueryDepositRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.proposalId !== 0) {
            writer.uint32(8).uint64(message.proposalId);
        }
        if (message.depositor !== "") {
            writer.uint32(18).string(message.depositor);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDepositRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.proposalId = longToNumber$5(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.depositor = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            proposalId: isSet$e(object.proposalId) ? Number(object.proposalId) : 0,
            depositor: isSet$e(object.depositor) ? String(object.depositor) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.proposalId !== 0) {
            obj.proposalId = Math.round(message.proposalId);
        }
        if (message.depositor !== "") {
            obj.depositor = message.depositor;
        }
        return obj;
    },
    create(base) {
        return QueryDepositRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryDepositRequest();
        message.proposalId = object.proposalId ?? 0;
        message.depositor = object.depositor ?? "";
        return message;
    },
};
function createBaseQueryDepositResponse() {
    return { deposit: undefined };
}
const QueryDepositResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.deposit !== undefined) {
            Deposit.encode(message.deposit, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDepositResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.deposit = Deposit.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { deposit: isSet$e(object.deposit) ? Deposit.fromJSON(object.deposit) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.deposit !== undefined) {
            obj.deposit = Deposit.toJSON(message.deposit);
        }
        return obj;
    },
    create(base) {
        return QueryDepositResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryDepositResponse();
        message.deposit = (object.deposit !== undefined && object.deposit !== null)
            ? Deposit.fromPartial(object.deposit)
            : undefined;
        return message;
    },
};
function createBaseQueryDepositsRequest() {
    return { proposalId: 0, pagination: undefined };
}
const QueryDepositsRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.proposalId !== 0) {
            writer.uint32(8).uint64(message.proposalId);
        }
        if (message.pagination !== undefined) {
            PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDepositsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.proposalId = longToNumber$5(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageRequest.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            proposalId: isSet$e(object.proposalId) ? Number(object.proposalId) : 0,
            pagination: isSet$e(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.proposalId !== 0) {
            obj.proposalId = Math.round(message.proposalId);
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageRequest.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryDepositsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryDepositsRequest();
        message.proposalId = object.proposalId ?? 0;
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageRequest.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryDepositsResponse() {
    return { deposits: [], pagination: undefined };
}
const QueryDepositsResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.deposits) {
            Deposit.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDepositsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.deposits.push(Deposit.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageResponse.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            deposits: Array.isArray(object?.deposits) ? object.deposits.map((e) => Deposit.fromJSON(e)) : [],
            pagination: isSet$e(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.deposits?.length) {
            obj.deposits = message.deposits.map((e) => Deposit.toJSON(e));
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageResponse.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryDepositsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryDepositsResponse();
        message.deposits = object.deposits?.map((e) => Deposit.fromPartial(e)) || [];
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageResponse.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryTallyResultRequest() {
    return { proposalId: 0 };
}
const QueryTallyResultRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.proposalId !== 0) {
            writer.uint32(8).uint64(message.proposalId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryTallyResultRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.proposalId = longToNumber$5(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { proposalId: isSet$e(object.proposalId) ? Number(object.proposalId) : 0 };
    },
    toJSON(message) {
        const obj = {};
        if (message.proposalId !== 0) {
            obj.proposalId = Math.round(message.proposalId);
        }
        return obj;
    },
    create(base) {
        return QueryTallyResultRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryTallyResultRequest();
        message.proposalId = object.proposalId ?? 0;
        return message;
    },
};
function createBaseQueryTallyResultResponse() {
    return { tally: undefined };
}
const QueryTallyResultResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.tally !== undefined) {
            TallyResult.encode(message.tally, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryTallyResultResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.tally = TallyResult.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { tally: isSet$e(object.tally) ? TallyResult.fromJSON(object.tally) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.tally !== undefined) {
            obj.tally = TallyResult.toJSON(message.tally);
        }
        return obj;
    },
    create(base) {
        return QueryTallyResultResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryTallyResultResponse();
        message.tally = (object.tally !== undefined && object.tally !== null)
            ? TallyResult.fromPartial(object.tally)
            : undefined;
        return message;
    },
};
let QueryClientImpl$2 = class QueryClientImpl {
    rpc;
    constructor(rpc) {
        this.rpc = rpc;
        this.Proposal = this.Proposal.bind(this);
        this.Proposals = this.Proposals.bind(this);
        this.Vote = this.Vote.bind(this);
        this.Votes = this.Votes.bind(this);
        this.Params = this.Params.bind(this);
        this.Deposit = this.Deposit.bind(this);
        this.Deposits = this.Deposits.bind(this);
        this.TallyResult = this.TallyResult.bind(this);
    }
    Proposal(request, metadata) {
        return this.rpc.unary(QueryProposalDesc, QueryProposalRequest.fromPartial(request), metadata);
    }
    Proposals(request, metadata) {
        return this.rpc.unary(QueryProposalsDesc, QueryProposalsRequest.fromPartial(request), metadata);
    }
    Vote(request, metadata) {
        return this.rpc.unary(QueryVoteDesc, QueryVoteRequest.fromPartial(request), metadata);
    }
    Votes(request, metadata) {
        return this.rpc.unary(QueryVotesDesc, QueryVotesRequest.fromPartial(request), metadata);
    }
    Params(request, metadata) {
        return this.rpc.unary(QueryParamsDesc$2, QueryParamsRequest$2.fromPartial(request), metadata);
    }
    Deposit(request, metadata) {
        return this.rpc.unary(QueryDepositDesc, QueryDepositRequest.fromPartial(request), metadata);
    }
    Deposits(request, metadata) {
        return this.rpc.unary(QueryDepositsDesc, QueryDepositsRequest.fromPartial(request), metadata);
    }
    TallyResult(request, metadata) {
        return this.rpc.unary(QueryTallyResultDesc, QueryTallyResultRequest.fromPartial(request), metadata);
    }
};
const QueryDesc$2 = { serviceName: "cosmos.gov.v1beta1.Query" };
const QueryProposalDesc = {
    methodName: "Proposal",
    service: QueryDesc$2,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryProposalRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryProposalResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryProposalsDesc = {
    methodName: "Proposals",
    service: QueryDesc$2,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryProposalsRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryProposalsResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryVoteDesc = {
    methodName: "Vote",
    service: QueryDesc$2,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryVoteRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryVoteResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryVotesDesc = {
    methodName: "Votes",
    service: QueryDesc$2,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryVotesRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryVotesResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryParamsDesc$2 = {
    methodName: "Params",
    service: QueryDesc$2,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryParamsRequest$2.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryParamsResponse$2.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryDepositDesc = {
    methodName: "Deposit",
    service: QueryDesc$2,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryDepositRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryDepositResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryDepositsDesc = {
    methodName: "Deposits",
    service: QueryDesc$2,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryDepositsRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryDepositsResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryTallyResultDesc = {
    methodName: "TallyResult",
    service: QueryDesc$2,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryTallyResultRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryTallyResultResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
let GrpcWebImpl$c = class GrpcWebImpl {
    host;
    options;
    constructor(host, options) {
        this.host = host;
        this.options = options;
    }
    unary(methodDesc, _request, metadata) {
        const request = { ..._request, ...methodDesc.requestType };
        const maybeCombinedMetadata = metadata && this.options.metadata
            ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
            : metadata ?? this.options.metadata;
        return new Promise((resolve, reject) => {
            grpc.unary(methodDesc, {
                request,
                host: this.host,
                metadata: maybeCombinedMetadata ?? {},
                ...(this.options.transport !== undefined ? { transport: this.options.transport } : {}),
                debug: this.options.debug ?? false,
                onEnd: function (response) {
                    if (response.status === grpc.Code.OK) {
                        resolve(response.message.toObject());
                    }
                    else {
                        const err = new GrpcWebError$c(response.statusMessage, response.status, response.trailers);
                        reject(err);
                    }
                },
            });
        });
    }
};
const tsProtoGlobalThis$e = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function longToNumber$5(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new tsProtoGlobalThis$e.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isSet$e(value) {
    return value !== null && value !== undefined;
}
let GrpcWebError$c = class GrpcWebError extends tsProtoGlobalThis$e.Error {
    code;
    metadata;
    constructor(message, code, metadata) {
        super(message);
        this.code = code;
        this.metadata = metadata;
    }
};

/* eslint-disable */
const protobufPackage$d = "cosmos.slashing.v1beta1";
function createBaseValidatorSigningInfo() {
    return {
        address: "",
        startHeight: 0,
        indexOffset: 0,
        jailedUntil: undefined,
        tombstoned: false,
        missedBlocksCounter: 0,
    };
}
const ValidatorSigningInfo = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.address !== "") {
            writer.uint32(10).string(message.address);
        }
        if (message.startHeight !== 0) {
            writer.uint32(16).int64(message.startHeight);
        }
        if (message.indexOffset !== 0) {
            writer.uint32(24).int64(message.indexOffset);
        }
        if (message.jailedUntil !== undefined) {
            Timestamp.encode(toTimestamp$2(message.jailedUntil), writer.uint32(34).fork()).ldelim();
        }
        if (message.tombstoned === true) {
            writer.uint32(40).bool(message.tombstoned);
        }
        if (message.missedBlocksCounter !== 0) {
            writer.uint32(48).int64(message.missedBlocksCounter);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidatorSigningInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.startHeight = longToNumber$4(reader.int64());
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.indexOffset = longToNumber$4(reader.int64());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.jailedUntil = fromTimestamp$2(Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.tombstoned = reader.bool();
                    continue;
                case 6:
                    if (tag !== 48) {
                        break;
                    }
                    message.missedBlocksCounter = longToNumber$4(reader.int64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            address: isSet$d(object.address) ? String(object.address) : "",
            startHeight: isSet$d(object.startHeight) ? Number(object.startHeight) : 0,
            indexOffset: isSet$d(object.indexOffset) ? Number(object.indexOffset) : 0,
            jailedUntil: isSet$d(object.jailedUntil) ? fromJsonTimestamp$2(object.jailedUntil) : undefined,
            tombstoned: isSet$d(object.tombstoned) ? Boolean(object.tombstoned) : false,
            missedBlocksCounter: isSet$d(object.missedBlocksCounter) ? Number(object.missedBlocksCounter) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.address !== "") {
            obj.address = message.address;
        }
        if (message.startHeight !== 0) {
            obj.startHeight = Math.round(message.startHeight);
        }
        if (message.indexOffset !== 0) {
            obj.indexOffset = Math.round(message.indexOffset);
        }
        if (message.jailedUntil !== undefined) {
            obj.jailedUntil = message.jailedUntil.toISOString();
        }
        if (message.tombstoned === true) {
            obj.tombstoned = message.tombstoned;
        }
        if (message.missedBlocksCounter !== 0) {
            obj.missedBlocksCounter = Math.round(message.missedBlocksCounter);
        }
        return obj;
    },
    create(base) {
        return ValidatorSigningInfo.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseValidatorSigningInfo();
        message.address = object.address ?? "";
        message.startHeight = object.startHeight ?? 0;
        message.indexOffset = object.indexOffset ?? 0;
        message.jailedUntil = object.jailedUntil ?? undefined;
        message.tombstoned = object.tombstoned ?? false;
        message.missedBlocksCounter = object.missedBlocksCounter ?? 0;
        return message;
    },
};
function createBaseParams$1() {
    return {
        signedBlocksWindow: 0,
        minSignedPerWindow: new Uint8Array(0),
        downtimeJailDuration: undefined,
        slashFractionDoubleSign: new Uint8Array(0),
        slashFractionDowntime: new Uint8Array(0),
    };
}
const Params$1 = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.signedBlocksWindow !== 0) {
            writer.uint32(8).int64(message.signedBlocksWindow);
        }
        if (message.minSignedPerWindow.length !== 0) {
            writer.uint32(18).bytes(message.minSignedPerWindow);
        }
        if (message.downtimeJailDuration !== undefined) {
            Duration.encode(message.downtimeJailDuration, writer.uint32(26).fork()).ldelim();
        }
        if (message.slashFractionDoubleSign.length !== 0) {
            writer.uint32(34).bytes(message.slashFractionDoubleSign);
        }
        if (message.slashFractionDowntime.length !== 0) {
            writer.uint32(42).bytes(message.slashFractionDowntime);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParams$1();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.signedBlocksWindow = longToNumber$4(reader.int64());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.minSignedPerWindow = reader.bytes();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.downtimeJailDuration = Duration.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.slashFractionDoubleSign = reader.bytes();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.slashFractionDowntime = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            signedBlocksWindow: isSet$d(object.signedBlocksWindow) ? Number(object.signedBlocksWindow) : 0,
            minSignedPerWindow: isSet$d(object.minSignedPerWindow)
                ? bytesFromBase64(object.minSignedPerWindow)
                : new Uint8Array(0),
            downtimeJailDuration: isSet$d(object.downtimeJailDuration)
                ? Duration.fromJSON(object.downtimeJailDuration)
                : undefined,
            slashFractionDoubleSign: isSet$d(object.slashFractionDoubleSign)
                ? bytesFromBase64(object.slashFractionDoubleSign)
                : new Uint8Array(0),
            slashFractionDowntime: isSet$d(object.slashFractionDowntime)
                ? bytesFromBase64(object.slashFractionDowntime)
                : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.signedBlocksWindow !== 0) {
            obj.signedBlocksWindow = Math.round(message.signedBlocksWindow);
        }
        if (message.minSignedPerWindow.length !== 0) {
            obj.minSignedPerWindow = base64FromBytes(message.minSignedPerWindow);
        }
        if (message.downtimeJailDuration !== undefined) {
            obj.downtimeJailDuration = Duration.toJSON(message.downtimeJailDuration);
        }
        if (message.slashFractionDoubleSign.length !== 0) {
            obj.slashFractionDoubleSign = base64FromBytes(message.slashFractionDoubleSign);
        }
        if (message.slashFractionDowntime.length !== 0) {
            obj.slashFractionDowntime = base64FromBytes(message.slashFractionDowntime);
        }
        return obj;
    },
    create(base) {
        return Params$1.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseParams$1();
        message.signedBlocksWindow = object.signedBlocksWindow ?? 0;
        message.minSignedPerWindow = object.minSignedPerWindow ?? new Uint8Array(0);
        message.downtimeJailDuration = (object.downtimeJailDuration !== undefined && object.downtimeJailDuration !== null)
            ? Duration.fromPartial(object.downtimeJailDuration)
            : undefined;
        message.slashFractionDoubleSign = object.slashFractionDoubleSign ?? new Uint8Array(0);
        message.slashFractionDowntime = object.slashFractionDowntime ?? new Uint8Array(0);
        return message;
    },
};
const tsProtoGlobalThis$d = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function bytesFromBase64(b64) {
    if (tsProtoGlobalThis$d.Buffer) {
        return Uint8Array.from(tsProtoGlobalThis$d.Buffer.from(b64, "base64"));
    }
    else {
        const bin = tsProtoGlobalThis$d.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (tsProtoGlobalThis$d.Buffer) {
        return tsProtoGlobalThis$d.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(String.fromCharCode(byte));
        });
        return tsProtoGlobalThis$d.btoa(bin.join(""));
    }
}
function toTimestamp$2(date) {
    const seconds = date.getTime() / 1_000;
    const nanos = (date.getTime() % 1_000) * 1_000_000;
    return { seconds, nanos };
}
function fromTimestamp$2(t) {
    let millis = (t.seconds || 0) * 1_000;
    millis += (t.nanos || 0) / 1_000_000;
    return new Date(millis);
}
function fromJsonTimestamp$2(o) {
    if (o instanceof Date) {
        return o;
    }
    else if (typeof o === "string") {
        return new Date(o);
    }
    else {
        return fromTimestamp$2(Timestamp.fromJSON(o));
    }
}
function longToNumber$4(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new tsProtoGlobalThis$d.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isSet$d(value) {
    return value !== null && value !== undefined;
}

/* eslint-disable */
const protobufPackage$c = "cosmos.slashing.v1beta1";
function createBaseQueryParamsRequest$1() {
    return {};
}
const QueryParamsRequest$1 = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest$1();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return QueryParamsRequest$1.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseQueryParamsRequest$1();
        return message;
    },
};
function createBaseQueryParamsResponse$1() {
    return { params: undefined };
}
const QueryParamsResponse$1 = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.params !== undefined) {
            Params$1.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse$1();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.params = Params$1.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { params: isSet$c(object.params) ? Params$1.fromJSON(object.params) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.params !== undefined) {
            obj.params = Params$1.toJSON(message.params);
        }
        return obj;
    },
    create(base) {
        return QueryParamsResponse$1.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryParamsResponse$1();
        message.params = (object.params !== undefined && object.params !== null)
            ? Params$1.fromPartial(object.params)
            : undefined;
        return message;
    },
};
function createBaseQuerySigningInfoRequest() {
    return { consAddress: "" };
}
const QuerySigningInfoRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.consAddress !== "") {
            writer.uint32(10).string(message.consAddress);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQuerySigningInfoRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.consAddress = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { consAddress: isSet$c(object.consAddress) ? String(object.consAddress) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.consAddress !== "") {
            obj.consAddress = message.consAddress;
        }
        return obj;
    },
    create(base) {
        return QuerySigningInfoRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQuerySigningInfoRequest();
        message.consAddress = object.consAddress ?? "";
        return message;
    },
};
function createBaseQuerySigningInfoResponse() {
    return { valSigningInfo: undefined };
}
const QuerySigningInfoResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.valSigningInfo !== undefined) {
            ValidatorSigningInfo.encode(message.valSigningInfo, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQuerySigningInfoResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.valSigningInfo = ValidatorSigningInfo.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            valSigningInfo: isSet$c(object.valSigningInfo) ? ValidatorSigningInfo.fromJSON(object.valSigningInfo) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.valSigningInfo !== undefined) {
            obj.valSigningInfo = ValidatorSigningInfo.toJSON(message.valSigningInfo);
        }
        return obj;
    },
    create(base) {
        return QuerySigningInfoResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQuerySigningInfoResponse();
        message.valSigningInfo = (object.valSigningInfo !== undefined && object.valSigningInfo !== null)
            ? ValidatorSigningInfo.fromPartial(object.valSigningInfo)
            : undefined;
        return message;
    },
};
function createBaseQuerySigningInfosRequest() {
    return { pagination: undefined };
}
const QuerySigningInfosRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.pagination !== undefined) {
            PageRequest.encode(message.pagination, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQuerySigningInfosRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.pagination = PageRequest.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { pagination: isSet$c(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.pagination !== undefined) {
            obj.pagination = PageRequest.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QuerySigningInfosRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQuerySigningInfosRequest();
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageRequest.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQuerySigningInfosResponse() {
    return { info: [], pagination: undefined };
}
const QuerySigningInfosResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.info) {
            ValidatorSigningInfo.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQuerySigningInfosResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.info.push(ValidatorSigningInfo.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageResponse.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            info: Array.isArray(object?.info) ? object.info.map((e) => ValidatorSigningInfo.fromJSON(e)) : [],
            pagination: isSet$c(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.info?.length) {
            obj.info = message.info.map((e) => ValidatorSigningInfo.toJSON(e));
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageResponse.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QuerySigningInfosResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQuerySigningInfosResponse();
        message.info = object.info?.map((e) => ValidatorSigningInfo.fromPartial(e)) || [];
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageResponse.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
let QueryClientImpl$1 = class QueryClientImpl {
    rpc;
    constructor(rpc) {
        this.rpc = rpc;
        this.Params = this.Params.bind(this);
        this.SigningInfo = this.SigningInfo.bind(this);
        this.SigningInfos = this.SigningInfos.bind(this);
    }
    Params(request, metadata) {
        return this.rpc.unary(QueryParamsDesc$1, QueryParamsRequest$1.fromPartial(request), metadata);
    }
    SigningInfo(request, metadata) {
        return this.rpc.unary(QuerySigningInfoDesc, QuerySigningInfoRequest.fromPartial(request), metadata);
    }
    SigningInfos(request, metadata) {
        return this.rpc.unary(QuerySigningInfosDesc, QuerySigningInfosRequest.fromPartial(request), metadata);
    }
};
const QueryDesc$1 = { serviceName: "cosmos.slashing.v1beta1.Query" };
const QueryParamsDesc$1 = {
    methodName: "Params",
    service: QueryDesc$1,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryParamsRequest$1.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryParamsResponse$1.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QuerySigningInfoDesc = {
    methodName: "SigningInfo",
    service: QueryDesc$1,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QuerySigningInfoRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QuerySigningInfoResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QuerySigningInfosDesc = {
    methodName: "SigningInfos",
    service: QueryDesc$1,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QuerySigningInfosRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QuerySigningInfosResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
let GrpcWebImpl$b = class GrpcWebImpl {
    host;
    options;
    constructor(host, options) {
        this.host = host;
        this.options = options;
    }
    unary(methodDesc, _request, metadata) {
        const request = { ..._request, ...methodDesc.requestType };
        const maybeCombinedMetadata = metadata && this.options.metadata
            ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
            : metadata ?? this.options.metadata;
        return new Promise((resolve, reject) => {
            grpc.unary(methodDesc, {
                request,
                host: this.host,
                metadata: maybeCombinedMetadata ?? {},
                ...(this.options.transport !== undefined ? { transport: this.options.transport } : {}),
                debug: this.options.debug ?? false,
                onEnd: function (response) {
                    if (response.status === grpc.Code.OK) {
                        resolve(response.message.toObject());
                    }
                    else {
                        const err = new GrpcWebError$b(response.statusMessage, response.status, response.trailers);
                        reject(err);
                    }
                },
            });
        });
    }
};
const tsProtoGlobalThis$c = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function isSet$c(value) {
    return value !== null && value !== undefined;
}
let GrpcWebError$b = class GrpcWebError extends tsProtoGlobalThis$c.Error {
    code;
    metadata;
    constructor(message, code, metadata) {
        super(message);
        this.code = code;
        this.metadata = metadata;
    }
};

/* eslint-disable */
const protobufPackage$b = "cosmos.staking.v1beta1";
/** BondStatus is the status of a validator. */
var BondStatus;
(function (BondStatus) {
    /** BOND_STATUS_UNSPECIFIED - UNSPECIFIED defines an invalid validator status. */
    BondStatus[BondStatus["BOND_STATUS_UNSPECIFIED"] = 0] = "BOND_STATUS_UNSPECIFIED";
    /** BOND_STATUS_UNBONDED - UNBONDED defines a validator that is not bonded. */
    BondStatus[BondStatus["BOND_STATUS_UNBONDED"] = 1] = "BOND_STATUS_UNBONDED";
    /** BOND_STATUS_UNBONDING - UNBONDING defines a validator that is unbonding. */
    BondStatus[BondStatus["BOND_STATUS_UNBONDING"] = 2] = "BOND_STATUS_UNBONDING";
    /** BOND_STATUS_BONDED - BONDED defines a validator that is bonded. */
    BondStatus[BondStatus["BOND_STATUS_BONDED"] = 3] = "BOND_STATUS_BONDED";
    BondStatus[BondStatus["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BondStatus || (BondStatus = {}));
function bondStatusFromJSON(object) {
    switch (object) {
        case 0:
        case "BOND_STATUS_UNSPECIFIED":
            return BondStatus.BOND_STATUS_UNSPECIFIED;
        case 1:
        case "BOND_STATUS_UNBONDED":
            return BondStatus.BOND_STATUS_UNBONDED;
        case 2:
        case "BOND_STATUS_UNBONDING":
            return BondStatus.BOND_STATUS_UNBONDING;
        case 3:
        case "BOND_STATUS_BONDED":
            return BondStatus.BOND_STATUS_BONDED;
        case -1:
        case "UNRECOGNIZED":
        default:
            return BondStatus.UNRECOGNIZED;
    }
}
function bondStatusToJSON(object) {
    switch (object) {
        case BondStatus.BOND_STATUS_UNSPECIFIED:
            return "BOND_STATUS_UNSPECIFIED";
        case BondStatus.BOND_STATUS_UNBONDED:
            return "BOND_STATUS_UNBONDED";
        case BondStatus.BOND_STATUS_UNBONDING:
            return "BOND_STATUS_UNBONDING";
        case BondStatus.BOND_STATUS_BONDED:
            return "BOND_STATUS_BONDED";
        case BondStatus.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseHistoricalInfo() {
    return { header: undefined, valset: [] };
}
const HistoricalInfo = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.header !== undefined) {
            Header.encode(message.header, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.valset) {
            Validator.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHistoricalInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.header = Header.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.valset.push(Validator.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            header: isSet$b(object.header) ? Header.fromJSON(object.header) : undefined,
            valset: Array.isArray(object?.valset) ? object.valset.map((e) => Validator.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.header !== undefined) {
            obj.header = Header.toJSON(message.header);
        }
        if (message.valset?.length) {
            obj.valset = message.valset.map((e) => Validator.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return HistoricalInfo.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseHistoricalInfo();
        message.header = (object.header !== undefined && object.header !== null)
            ? Header.fromPartial(object.header)
            : undefined;
        message.valset = object.valset?.map((e) => Validator.fromPartial(e)) || [];
        return message;
    },
};
function createBaseCommissionRates() {
    return { rate: "", maxRate: "", maxChangeRate: "" };
}
const CommissionRates = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.rate !== "") {
            writer.uint32(10).string(message.rate);
        }
        if (message.maxRate !== "") {
            writer.uint32(18).string(message.maxRate);
        }
        if (message.maxChangeRate !== "") {
            writer.uint32(26).string(message.maxChangeRate);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommissionRates();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.rate = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.maxRate = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.maxChangeRate = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            rate: isSet$b(object.rate) ? String(object.rate) : "",
            maxRate: isSet$b(object.maxRate) ? String(object.maxRate) : "",
            maxChangeRate: isSet$b(object.maxChangeRate) ? String(object.maxChangeRate) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.rate !== "") {
            obj.rate = message.rate;
        }
        if (message.maxRate !== "") {
            obj.maxRate = message.maxRate;
        }
        if (message.maxChangeRate !== "") {
            obj.maxChangeRate = message.maxChangeRate;
        }
        return obj;
    },
    create(base) {
        return CommissionRates.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCommissionRates();
        message.rate = object.rate ?? "";
        message.maxRate = object.maxRate ?? "";
        message.maxChangeRate = object.maxChangeRate ?? "";
        return message;
    },
};
function createBaseCommission() {
    return { commissionRates: undefined, updateTime: undefined };
}
const Commission = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.commissionRates !== undefined) {
            CommissionRates.encode(message.commissionRates, writer.uint32(10).fork()).ldelim();
        }
        if (message.updateTime !== undefined) {
            Timestamp.encode(toTimestamp$1(message.updateTime), writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCommission();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.commissionRates = CommissionRates.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.updateTime = fromTimestamp$1(Timestamp.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            commissionRates: isSet$b(object.commissionRates) ? CommissionRates.fromJSON(object.commissionRates) : undefined,
            updateTime: isSet$b(object.updateTime) ? fromJsonTimestamp$1(object.updateTime) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.commissionRates !== undefined) {
            obj.commissionRates = CommissionRates.toJSON(message.commissionRates);
        }
        if (message.updateTime !== undefined) {
            obj.updateTime = message.updateTime.toISOString();
        }
        return obj;
    },
    create(base) {
        return Commission.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseCommission();
        message.commissionRates = (object.commissionRates !== undefined && object.commissionRates !== null)
            ? CommissionRates.fromPartial(object.commissionRates)
            : undefined;
        message.updateTime = object.updateTime ?? undefined;
        return message;
    },
};
function createBaseDescription() {
    return { moniker: "", identity: "", website: "", securityContact: "", details: "" };
}
const Description = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.moniker !== "") {
            writer.uint32(10).string(message.moniker);
        }
        if (message.identity !== "") {
            writer.uint32(18).string(message.identity);
        }
        if (message.website !== "") {
            writer.uint32(26).string(message.website);
        }
        if (message.securityContact !== "") {
            writer.uint32(34).string(message.securityContact);
        }
        if (message.details !== "") {
            writer.uint32(42).string(message.details);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDescription();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.moniker = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.identity = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.website = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.securityContact = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.details = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            moniker: isSet$b(object.moniker) ? String(object.moniker) : "",
            identity: isSet$b(object.identity) ? String(object.identity) : "",
            website: isSet$b(object.website) ? String(object.website) : "",
            securityContact: isSet$b(object.securityContact) ? String(object.securityContact) : "",
            details: isSet$b(object.details) ? String(object.details) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.moniker !== "") {
            obj.moniker = message.moniker;
        }
        if (message.identity !== "") {
            obj.identity = message.identity;
        }
        if (message.website !== "") {
            obj.website = message.website;
        }
        if (message.securityContact !== "") {
            obj.securityContact = message.securityContact;
        }
        if (message.details !== "") {
            obj.details = message.details;
        }
        return obj;
    },
    create(base) {
        return Description.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDescription();
        message.moniker = object.moniker ?? "";
        message.identity = object.identity ?? "";
        message.website = object.website ?? "";
        message.securityContact = object.securityContact ?? "";
        message.details = object.details ?? "";
        return message;
    },
};
function createBaseValidator() {
    return {
        operatorAddress: "",
        consensusPubkey: undefined,
        jailed: false,
        status: 0,
        tokens: "",
        delegatorShares: "",
        description: undefined,
        unbondingHeight: 0,
        unbondingTime: undefined,
        commission: undefined,
        minSelfDelegation: "",
    };
}
const Validator = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.operatorAddress !== "") {
            writer.uint32(10).string(message.operatorAddress);
        }
        if (message.consensusPubkey !== undefined) {
            Any.encode(message.consensusPubkey, writer.uint32(18).fork()).ldelim();
        }
        if (message.jailed === true) {
            writer.uint32(24).bool(message.jailed);
        }
        if (message.status !== 0) {
            writer.uint32(32).int32(message.status);
        }
        if (message.tokens !== "") {
            writer.uint32(42).string(message.tokens);
        }
        if (message.delegatorShares !== "") {
            writer.uint32(50).string(message.delegatorShares);
        }
        if (message.description !== undefined) {
            Description.encode(message.description, writer.uint32(58).fork()).ldelim();
        }
        if (message.unbondingHeight !== 0) {
            writer.uint32(64).int64(message.unbondingHeight);
        }
        if (message.unbondingTime !== undefined) {
            Timestamp.encode(toTimestamp$1(message.unbondingTime), writer.uint32(74).fork()).ldelim();
        }
        if (message.commission !== undefined) {
            Commission.encode(message.commission, writer.uint32(82).fork()).ldelim();
        }
        if (message.minSelfDelegation !== "") {
            writer.uint32(90).string(message.minSelfDelegation);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValidator();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.operatorAddress = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.consensusPubkey = Any.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.jailed = reader.bool();
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.status = reader.int32();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.tokens = reader.string();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.delegatorShares = reader.string();
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.description = Description.decode(reader, reader.uint32());
                    continue;
                case 8:
                    if (tag !== 64) {
                        break;
                    }
                    message.unbondingHeight = longToNumber$3(reader.int64());
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.unbondingTime = fromTimestamp$1(Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 10:
                    if (tag !== 82) {
                        break;
                    }
                    message.commission = Commission.decode(reader, reader.uint32());
                    continue;
                case 11:
                    if (tag !== 90) {
                        break;
                    }
                    message.minSelfDelegation = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            operatorAddress: isSet$b(object.operatorAddress) ? String(object.operatorAddress) : "",
            consensusPubkey: isSet$b(object.consensusPubkey) ? Any.fromJSON(object.consensusPubkey) : undefined,
            jailed: isSet$b(object.jailed) ? Boolean(object.jailed) : false,
            status: isSet$b(object.status) ? bondStatusFromJSON(object.status) : 0,
            tokens: isSet$b(object.tokens) ? String(object.tokens) : "",
            delegatorShares: isSet$b(object.delegatorShares) ? String(object.delegatorShares) : "",
            description: isSet$b(object.description) ? Description.fromJSON(object.description) : undefined,
            unbondingHeight: isSet$b(object.unbondingHeight) ? Number(object.unbondingHeight) : 0,
            unbondingTime: isSet$b(object.unbondingTime) ? fromJsonTimestamp$1(object.unbondingTime) : undefined,
            commission: isSet$b(object.commission) ? Commission.fromJSON(object.commission) : undefined,
            minSelfDelegation: isSet$b(object.minSelfDelegation) ? String(object.minSelfDelegation) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.operatorAddress !== "") {
            obj.operatorAddress = message.operatorAddress;
        }
        if (message.consensusPubkey !== undefined) {
            obj.consensusPubkey = Any.toJSON(message.consensusPubkey);
        }
        if (message.jailed === true) {
            obj.jailed = message.jailed;
        }
        if (message.status !== 0) {
            obj.status = bondStatusToJSON(message.status);
        }
        if (message.tokens !== "") {
            obj.tokens = message.tokens;
        }
        if (message.delegatorShares !== "") {
            obj.delegatorShares = message.delegatorShares;
        }
        if (message.description !== undefined) {
            obj.description = Description.toJSON(message.description);
        }
        if (message.unbondingHeight !== 0) {
            obj.unbondingHeight = Math.round(message.unbondingHeight);
        }
        if (message.unbondingTime !== undefined) {
            obj.unbondingTime = message.unbondingTime.toISOString();
        }
        if (message.commission !== undefined) {
            obj.commission = Commission.toJSON(message.commission);
        }
        if (message.minSelfDelegation !== "") {
            obj.minSelfDelegation = message.minSelfDelegation;
        }
        return obj;
    },
    create(base) {
        return Validator.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseValidator();
        message.operatorAddress = object.operatorAddress ?? "";
        message.consensusPubkey = (object.consensusPubkey !== undefined && object.consensusPubkey !== null)
            ? Any.fromPartial(object.consensusPubkey)
            : undefined;
        message.jailed = object.jailed ?? false;
        message.status = object.status ?? 0;
        message.tokens = object.tokens ?? "";
        message.delegatorShares = object.delegatorShares ?? "";
        message.description = (object.description !== undefined && object.description !== null)
            ? Description.fromPartial(object.description)
            : undefined;
        message.unbondingHeight = object.unbondingHeight ?? 0;
        message.unbondingTime = object.unbondingTime ?? undefined;
        message.commission = (object.commission !== undefined && object.commission !== null)
            ? Commission.fromPartial(object.commission)
            : undefined;
        message.minSelfDelegation = object.minSelfDelegation ?? "";
        return message;
    },
};
function createBaseValAddresses() {
    return { addresses: [] };
}
const ValAddresses = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.addresses) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseValAddresses();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.addresses.push(reader.string());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { addresses: Array.isArray(object?.addresses) ? object.addresses.map((e) => String(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.addresses?.length) {
            obj.addresses = message.addresses;
        }
        return obj;
    },
    create(base) {
        return ValAddresses.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseValAddresses();
        message.addresses = object.addresses?.map((e) => e) || [];
        return message;
    },
};
function createBaseDVPair() {
    return { delegatorAddress: "", validatorAddress: "" };
}
const DVPair = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.delegatorAddress !== "") {
            writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
            writer.uint32(18).string(message.validatorAddress);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDVPair();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.delegatorAddress = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.validatorAddress = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            delegatorAddress: isSet$b(object.delegatorAddress) ? String(object.delegatorAddress) : "",
            validatorAddress: isSet$b(object.validatorAddress) ? String(object.validatorAddress) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.delegatorAddress !== "") {
            obj.delegatorAddress = message.delegatorAddress;
        }
        if (message.validatorAddress !== "") {
            obj.validatorAddress = message.validatorAddress;
        }
        return obj;
    },
    create(base) {
        return DVPair.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDVPair();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        return message;
    },
};
function createBaseDVPairs() {
    return { pairs: [] };
}
const DVPairs = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.pairs) {
            DVPair.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDVPairs();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.pairs.push(DVPair.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { pairs: Array.isArray(object?.pairs) ? object.pairs.map((e) => DVPair.fromJSON(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.pairs?.length) {
            obj.pairs = message.pairs.map((e) => DVPair.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return DVPairs.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDVPairs();
        message.pairs = object.pairs?.map((e) => DVPair.fromPartial(e)) || [];
        return message;
    },
};
function createBaseDVVTriplet() {
    return { delegatorAddress: "", validatorSrcAddress: "", validatorDstAddress: "" };
}
const DVVTriplet = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.delegatorAddress !== "") {
            writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorSrcAddress !== "") {
            writer.uint32(18).string(message.validatorSrcAddress);
        }
        if (message.validatorDstAddress !== "") {
            writer.uint32(26).string(message.validatorDstAddress);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDVVTriplet();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.delegatorAddress = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.validatorSrcAddress = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.validatorDstAddress = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            delegatorAddress: isSet$b(object.delegatorAddress) ? String(object.delegatorAddress) : "",
            validatorSrcAddress: isSet$b(object.validatorSrcAddress) ? String(object.validatorSrcAddress) : "",
            validatorDstAddress: isSet$b(object.validatorDstAddress) ? String(object.validatorDstAddress) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.delegatorAddress !== "") {
            obj.delegatorAddress = message.delegatorAddress;
        }
        if (message.validatorSrcAddress !== "") {
            obj.validatorSrcAddress = message.validatorSrcAddress;
        }
        if (message.validatorDstAddress !== "") {
            obj.validatorDstAddress = message.validatorDstAddress;
        }
        return obj;
    },
    create(base) {
        return DVVTriplet.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDVVTriplet();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorSrcAddress = object.validatorSrcAddress ?? "";
        message.validatorDstAddress = object.validatorDstAddress ?? "";
        return message;
    },
};
function createBaseDVVTriplets() {
    return { triplets: [] };
}
const DVVTriplets = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.triplets) {
            DVVTriplet.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDVVTriplets();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.triplets.push(DVVTriplet.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { triplets: Array.isArray(object?.triplets) ? object.triplets.map((e) => DVVTriplet.fromJSON(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.triplets?.length) {
            obj.triplets = message.triplets.map((e) => DVVTriplet.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return DVVTriplets.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDVVTriplets();
        message.triplets = object.triplets?.map((e) => DVVTriplet.fromPartial(e)) || [];
        return message;
    },
};
function createBaseDelegation() {
    return { delegatorAddress: "", validatorAddress: "", shares: "" };
}
const Delegation = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.delegatorAddress !== "") {
            writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
            writer.uint32(18).string(message.validatorAddress);
        }
        if (message.shares !== "") {
            writer.uint32(26).string(message.shares);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDelegation();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.delegatorAddress = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.validatorAddress = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.shares = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            delegatorAddress: isSet$b(object.delegatorAddress) ? String(object.delegatorAddress) : "",
            validatorAddress: isSet$b(object.validatorAddress) ? String(object.validatorAddress) : "",
            shares: isSet$b(object.shares) ? String(object.shares) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.delegatorAddress !== "") {
            obj.delegatorAddress = message.delegatorAddress;
        }
        if (message.validatorAddress !== "") {
            obj.validatorAddress = message.validatorAddress;
        }
        if (message.shares !== "") {
            obj.shares = message.shares;
        }
        return obj;
    },
    create(base) {
        return Delegation.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDelegation();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        message.shares = object.shares ?? "";
        return message;
    },
};
function createBaseUnbondingDelegation() {
    return { delegatorAddress: "", validatorAddress: "", entries: [] };
}
const UnbondingDelegation = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.delegatorAddress !== "") {
            writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
            writer.uint32(18).string(message.validatorAddress);
        }
        for (const v of message.entries) {
            UnbondingDelegationEntry.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUnbondingDelegation();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.delegatorAddress = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.validatorAddress = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.entries.push(UnbondingDelegationEntry.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            delegatorAddress: isSet$b(object.delegatorAddress) ? String(object.delegatorAddress) : "",
            validatorAddress: isSet$b(object.validatorAddress) ? String(object.validatorAddress) : "",
            entries: Array.isArray(object?.entries)
                ? object.entries.map((e) => UnbondingDelegationEntry.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.delegatorAddress !== "") {
            obj.delegatorAddress = message.delegatorAddress;
        }
        if (message.validatorAddress !== "") {
            obj.validatorAddress = message.validatorAddress;
        }
        if (message.entries?.length) {
            obj.entries = message.entries.map((e) => UnbondingDelegationEntry.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return UnbondingDelegation.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUnbondingDelegation();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        message.entries = object.entries?.map((e) => UnbondingDelegationEntry.fromPartial(e)) || [];
        return message;
    },
};
function createBaseUnbondingDelegationEntry() {
    return { creationHeight: 0, completionTime: undefined, initialBalance: "", balance: "" };
}
const UnbondingDelegationEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creationHeight !== 0) {
            writer.uint32(8).int64(message.creationHeight);
        }
        if (message.completionTime !== undefined) {
            Timestamp.encode(toTimestamp$1(message.completionTime), writer.uint32(18).fork()).ldelim();
        }
        if (message.initialBalance !== "") {
            writer.uint32(26).string(message.initialBalance);
        }
        if (message.balance !== "") {
            writer.uint32(34).string(message.balance);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseUnbondingDelegationEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.creationHeight = longToNumber$3(reader.int64());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.completionTime = fromTimestamp$1(Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.initialBalance = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.balance = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creationHeight: isSet$b(object.creationHeight) ? Number(object.creationHeight) : 0,
            completionTime: isSet$b(object.completionTime) ? fromJsonTimestamp$1(object.completionTime) : undefined,
            initialBalance: isSet$b(object.initialBalance) ? String(object.initialBalance) : "",
            balance: isSet$b(object.balance) ? String(object.balance) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creationHeight !== 0) {
            obj.creationHeight = Math.round(message.creationHeight);
        }
        if (message.completionTime !== undefined) {
            obj.completionTime = message.completionTime.toISOString();
        }
        if (message.initialBalance !== "") {
            obj.initialBalance = message.initialBalance;
        }
        if (message.balance !== "") {
            obj.balance = message.balance;
        }
        return obj;
    },
    create(base) {
        return UnbondingDelegationEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseUnbondingDelegationEntry();
        message.creationHeight = object.creationHeight ?? 0;
        message.completionTime = object.completionTime ?? undefined;
        message.initialBalance = object.initialBalance ?? "";
        message.balance = object.balance ?? "";
        return message;
    },
};
function createBaseRedelegationEntry() {
    return { creationHeight: 0, completionTime: undefined, initialBalance: "", sharesDst: "" };
}
const RedelegationEntry = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creationHeight !== 0) {
            writer.uint32(8).int64(message.creationHeight);
        }
        if (message.completionTime !== undefined) {
            Timestamp.encode(toTimestamp$1(message.completionTime), writer.uint32(18).fork()).ldelim();
        }
        if (message.initialBalance !== "") {
            writer.uint32(26).string(message.initialBalance);
        }
        if (message.sharesDst !== "") {
            writer.uint32(34).string(message.sharesDst);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRedelegationEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.creationHeight = longToNumber$3(reader.int64());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.completionTime = fromTimestamp$1(Timestamp.decode(reader, reader.uint32()));
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.initialBalance = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.sharesDst = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creationHeight: isSet$b(object.creationHeight) ? Number(object.creationHeight) : 0,
            completionTime: isSet$b(object.completionTime) ? fromJsonTimestamp$1(object.completionTime) : undefined,
            initialBalance: isSet$b(object.initialBalance) ? String(object.initialBalance) : "",
            sharesDst: isSet$b(object.sharesDst) ? String(object.sharesDst) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creationHeight !== 0) {
            obj.creationHeight = Math.round(message.creationHeight);
        }
        if (message.completionTime !== undefined) {
            obj.completionTime = message.completionTime.toISOString();
        }
        if (message.initialBalance !== "") {
            obj.initialBalance = message.initialBalance;
        }
        if (message.sharesDst !== "") {
            obj.sharesDst = message.sharesDst;
        }
        return obj;
    },
    create(base) {
        return RedelegationEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRedelegationEntry();
        message.creationHeight = object.creationHeight ?? 0;
        message.completionTime = object.completionTime ?? undefined;
        message.initialBalance = object.initialBalance ?? "";
        message.sharesDst = object.sharesDst ?? "";
        return message;
    },
};
function createBaseRedelegation() {
    return { delegatorAddress: "", validatorSrcAddress: "", validatorDstAddress: "", entries: [] };
}
const Redelegation = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.delegatorAddress !== "") {
            writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorSrcAddress !== "") {
            writer.uint32(18).string(message.validatorSrcAddress);
        }
        if (message.validatorDstAddress !== "") {
            writer.uint32(26).string(message.validatorDstAddress);
        }
        for (const v of message.entries) {
            RedelegationEntry.encode(v, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRedelegation();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.delegatorAddress = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.validatorSrcAddress = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.validatorDstAddress = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.entries.push(RedelegationEntry.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            delegatorAddress: isSet$b(object.delegatorAddress) ? String(object.delegatorAddress) : "",
            validatorSrcAddress: isSet$b(object.validatorSrcAddress) ? String(object.validatorSrcAddress) : "",
            validatorDstAddress: isSet$b(object.validatorDstAddress) ? String(object.validatorDstAddress) : "",
            entries: Array.isArray(object?.entries) ? object.entries.map((e) => RedelegationEntry.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.delegatorAddress !== "") {
            obj.delegatorAddress = message.delegatorAddress;
        }
        if (message.validatorSrcAddress !== "") {
            obj.validatorSrcAddress = message.validatorSrcAddress;
        }
        if (message.validatorDstAddress !== "") {
            obj.validatorDstAddress = message.validatorDstAddress;
        }
        if (message.entries?.length) {
            obj.entries = message.entries.map((e) => RedelegationEntry.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return Redelegation.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRedelegation();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorSrcAddress = object.validatorSrcAddress ?? "";
        message.validatorDstAddress = object.validatorDstAddress ?? "";
        message.entries = object.entries?.map((e) => RedelegationEntry.fromPartial(e)) || [];
        return message;
    },
};
function createBaseParams() {
    return { unbondingTime: undefined, maxValidators: 0, maxEntries: 0, historicalEntries: 0, bondDenom: "" };
}
const Params = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.unbondingTime !== undefined) {
            Duration.encode(message.unbondingTime, writer.uint32(10).fork()).ldelim();
        }
        if (message.maxValidators !== 0) {
            writer.uint32(16).uint32(message.maxValidators);
        }
        if (message.maxEntries !== 0) {
            writer.uint32(24).uint32(message.maxEntries);
        }
        if (message.historicalEntries !== 0) {
            writer.uint32(32).uint32(message.historicalEntries);
        }
        if (message.bondDenom !== "") {
            writer.uint32(42).string(message.bondDenom);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParams();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.unbondingTime = Duration.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.maxValidators = reader.uint32();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.maxEntries = reader.uint32();
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.historicalEntries = reader.uint32();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.bondDenom = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            unbondingTime: isSet$b(object.unbondingTime) ? Duration.fromJSON(object.unbondingTime) : undefined,
            maxValidators: isSet$b(object.maxValidators) ? Number(object.maxValidators) : 0,
            maxEntries: isSet$b(object.maxEntries) ? Number(object.maxEntries) : 0,
            historicalEntries: isSet$b(object.historicalEntries) ? Number(object.historicalEntries) : 0,
            bondDenom: isSet$b(object.bondDenom) ? String(object.bondDenom) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.unbondingTime !== undefined) {
            obj.unbondingTime = Duration.toJSON(message.unbondingTime);
        }
        if (message.maxValidators !== 0) {
            obj.maxValidators = Math.round(message.maxValidators);
        }
        if (message.maxEntries !== 0) {
            obj.maxEntries = Math.round(message.maxEntries);
        }
        if (message.historicalEntries !== 0) {
            obj.historicalEntries = Math.round(message.historicalEntries);
        }
        if (message.bondDenom !== "") {
            obj.bondDenom = message.bondDenom;
        }
        return obj;
    },
    create(base) {
        return Params.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseParams();
        message.unbondingTime = (object.unbondingTime !== undefined && object.unbondingTime !== null)
            ? Duration.fromPartial(object.unbondingTime)
            : undefined;
        message.maxValidators = object.maxValidators ?? 0;
        message.maxEntries = object.maxEntries ?? 0;
        message.historicalEntries = object.historicalEntries ?? 0;
        message.bondDenom = object.bondDenom ?? "";
        return message;
    },
};
function createBaseDelegationResponse() {
    return { delegation: undefined, balance: undefined };
}
const DelegationResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.delegation !== undefined) {
            Delegation.encode(message.delegation, writer.uint32(10).fork()).ldelim();
        }
        if (message.balance !== undefined) {
            Coin.encode(message.balance, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDelegationResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.delegation = Delegation.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.balance = Coin.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            delegation: isSet$b(object.delegation) ? Delegation.fromJSON(object.delegation) : undefined,
            balance: isSet$b(object.balance) ? Coin.fromJSON(object.balance) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.delegation !== undefined) {
            obj.delegation = Delegation.toJSON(message.delegation);
        }
        if (message.balance !== undefined) {
            obj.balance = Coin.toJSON(message.balance);
        }
        return obj;
    },
    create(base) {
        return DelegationResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDelegationResponse();
        message.delegation = (object.delegation !== undefined && object.delegation !== null)
            ? Delegation.fromPartial(object.delegation)
            : undefined;
        message.balance = (object.balance !== undefined && object.balance !== null)
            ? Coin.fromPartial(object.balance)
            : undefined;
        return message;
    },
};
function createBaseRedelegationEntryResponse() {
    return { redelegationEntry: undefined, balance: "" };
}
const RedelegationEntryResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.redelegationEntry !== undefined) {
            RedelegationEntry.encode(message.redelegationEntry, writer.uint32(10).fork()).ldelim();
        }
        if (message.balance !== "") {
            writer.uint32(34).string(message.balance);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRedelegationEntryResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.redelegationEntry = RedelegationEntry.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.balance = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            redelegationEntry: isSet$b(object.redelegationEntry)
                ? RedelegationEntry.fromJSON(object.redelegationEntry)
                : undefined,
            balance: isSet$b(object.balance) ? String(object.balance) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.redelegationEntry !== undefined) {
            obj.redelegationEntry = RedelegationEntry.toJSON(message.redelegationEntry);
        }
        if (message.balance !== "") {
            obj.balance = message.balance;
        }
        return obj;
    },
    create(base) {
        return RedelegationEntryResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRedelegationEntryResponse();
        message.redelegationEntry = (object.redelegationEntry !== undefined && object.redelegationEntry !== null)
            ? RedelegationEntry.fromPartial(object.redelegationEntry)
            : undefined;
        message.balance = object.balance ?? "";
        return message;
    },
};
function createBaseRedelegationResponse() {
    return { redelegation: undefined, entries: [] };
}
const RedelegationResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.redelegation !== undefined) {
            Redelegation.encode(message.redelegation, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.entries) {
            RedelegationEntryResponse.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRedelegationResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.redelegation = Redelegation.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.entries.push(RedelegationEntryResponse.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            redelegation: isSet$b(object.redelegation) ? Redelegation.fromJSON(object.redelegation) : undefined,
            entries: Array.isArray(object?.entries)
                ? object.entries.map((e) => RedelegationEntryResponse.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.redelegation !== undefined) {
            obj.redelegation = Redelegation.toJSON(message.redelegation);
        }
        if (message.entries?.length) {
            obj.entries = message.entries.map((e) => RedelegationEntryResponse.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return RedelegationResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseRedelegationResponse();
        message.redelegation = (object.redelegation !== undefined && object.redelegation !== null)
            ? Redelegation.fromPartial(object.redelegation)
            : undefined;
        message.entries = object.entries?.map((e) => RedelegationEntryResponse.fromPartial(e)) || [];
        return message;
    },
};
function createBasePool() {
    return { notBondedTokens: "", bondedTokens: "" };
}
const Pool = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.notBondedTokens !== "") {
            writer.uint32(10).string(message.notBondedTokens);
        }
        if (message.bondedTokens !== "") {
            writer.uint32(18).string(message.bondedTokens);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBasePool();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.notBondedTokens = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.bondedTokens = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            notBondedTokens: isSet$b(object.notBondedTokens) ? String(object.notBondedTokens) : "",
            bondedTokens: isSet$b(object.bondedTokens) ? String(object.bondedTokens) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.notBondedTokens !== "") {
            obj.notBondedTokens = message.notBondedTokens;
        }
        if (message.bondedTokens !== "") {
            obj.bondedTokens = message.bondedTokens;
        }
        return obj;
    },
    create(base) {
        return Pool.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBasePool();
        message.notBondedTokens = object.notBondedTokens ?? "";
        message.bondedTokens = object.bondedTokens ?? "";
        return message;
    },
};
const tsProtoGlobalThis$b = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function toTimestamp$1(date) {
    const seconds = date.getTime() / 1_000;
    const nanos = (date.getTime() % 1_000) * 1_000_000;
    return { seconds, nanos };
}
function fromTimestamp$1(t) {
    let millis = (t.seconds || 0) * 1_000;
    millis += (t.nanos || 0) / 1_000_000;
    return new Date(millis);
}
function fromJsonTimestamp$1(o) {
    if (o instanceof Date) {
        return o;
    }
    else if (typeof o === "string") {
        return new Date(o);
    }
    else {
        return fromTimestamp$1(Timestamp.fromJSON(o));
    }
}
function longToNumber$3(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new tsProtoGlobalThis$b.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isSet$b(value) {
    return value !== null && value !== undefined;
}

/* eslint-disable */
const protobufPackage$a = "cosmos.staking.v1beta1";
function createBaseQueryValidatorsRequest() {
    return { status: "", pagination: undefined };
}
const QueryValidatorsRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.status !== "") {
            writer.uint32(10).string(message.status);
        }
        if (message.pagination !== undefined) {
            PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.status = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageRequest.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            status: isSet$a(object.status) ? String(object.status) : "",
            pagination: isSet$a(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.status !== "") {
            obj.status = message.status;
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageRequest.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryValidatorsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryValidatorsRequest();
        message.status = object.status ?? "";
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageRequest.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryValidatorsResponse() {
    return { validators: [], pagination: undefined };
}
const QueryValidatorsResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.validators) {
            Validator.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.validators.push(Validator.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageResponse.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            validators: Array.isArray(object?.validators) ? object.validators.map((e) => Validator.fromJSON(e)) : [],
            pagination: isSet$a(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.validators?.length) {
            obj.validators = message.validators.map((e) => Validator.toJSON(e));
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageResponse.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryValidatorsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryValidatorsResponse();
        message.validators = object.validators?.map((e) => Validator.fromPartial(e)) || [];
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageResponse.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryValidatorRequest() {
    return { validatorAddr: "" };
}
const QueryValidatorRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.validatorAddr !== "") {
            writer.uint32(10).string(message.validatorAddr);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.validatorAddr = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { validatorAddr: isSet$a(object.validatorAddr) ? String(object.validatorAddr) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.validatorAddr !== "") {
            obj.validatorAddr = message.validatorAddr;
        }
        return obj;
    },
    create(base) {
        return QueryValidatorRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryValidatorRequest();
        message.validatorAddr = object.validatorAddr ?? "";
        return message;
    },
};
function createBaseQueryValidatorResponse() {
    return { validator: undefined };
}
const QueryValidatorResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.validator !== undefined) {
            Validator.encode(message.validator, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.validator = Validator.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { validator: isSet$a(object.validator) ? Validator.fromJSON(object.validator) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.validator !== undefined) {
            obj.validator = Validator.toJSON(message.validator);
        }
        return obj;
    },
    create(base) {
        return QueryValidatorResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryValidatorResponse();
        message.validator = (object.validator !== undefined && object.validator !== null)
            ? Validator.fromPartial(object.validator)
            : undefined;
        return message;
    },
};
function createBaseQueryValidatorDelegationsRequest() {
    return { validatorAddr: "", pagination: undefined };
}
const QueryValidatorDelegationsRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.validatorAddr !== "") {
            writer.uint32(10).string(message.validatorAddr);
        }
        if (message.pagination !== undefined) {
            PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorDelegationsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.validatorAddr = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageRequest.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            validatorAddr: isSet$a(object.validatorAddr) ? String(object.validatorAddr) : "",
            pagination: isSet$a(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.validatorAddr !== "") {
            obj.validatorAddr = message.validatorAddr;
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageRequest.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryValidatorDelegationsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryValidatorDelegationsRequest();
        message.validatorAddr = object.validatorAddr ?? "";
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageRequest.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryValidatorDelegationsResponse() {
    return { delegationResponses: [], pagination: undefined };
}
const QueryValidatorDelegationsResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.delegationResponses) {
            DelegationResponse.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorDelegationsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.delegationResponses.push(DelegationResponse.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageResponse.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            delegationResponses: Array.isArray(object?.delegationResponses)
                ? object.delegationResponses.map((e) => DelegationResponse.fromJSON(e))
                : [],
            pagination: isSet$a(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.delegationResponses?.length) {
            obj.delegationResponses = message.delegationResponses.map((e) => DelegationResponse.toJSON(e));
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageResponse.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryValidatorDelegationsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryValidatorDelegationsResponse();
        message.delegationResponses = object.delegationResponses?.map((e) => DelegationResponse.fromPartial(e)) || [];
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageResponse.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryValidatorUnbondingDelegationsRequest() {
    return { validatorAddr: "", pagination: undefined };
}
const QueryValidatorUnbondingDelegationsRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.validatorAddr !== "") {
            writer.uint32(10).string(message.validatorAddr);
        }
        if (message.pagination !== undefined) {
            PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorUnbondingDelegationsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.validatorAddr = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageRequest.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            validatorAddr: isSet$a(object.validatorAddr) ? String(object.validatorAddr) : "",
            pagination: isSet$a(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.validatorAddr !== "") {
            obj.validatorAddr = message.validatorAddr;
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageRequest.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryValidatorUnbondingDelegationsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryValidatorUnbondingDelegationsRequest();
        message.validatorAddr = object.validatorAddr ?? "";
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageRequest.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryValidatorUnbondingDelegationsResponse() {
    return { unbondingResponses: [], pagination: undefined };
}
const QueryValidatorUnbondingDelegationsResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.unbondingResponses) {
            UnbondingDelegation.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryValidatorUnbondingDelegationsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.unbondingResponses.push(UnbondingDelegation.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageResponse.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            unbondingResponses: Array.isArray(object?.unbondingResponses)
                ? object.unbondingResponses.map((e) => UnbondingDelegation.fromJSON(e))
                : [],
            pagination: isSet$a(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.unbondingResponses?.length) {
            obj.unbondingResponses = message.unbondingResponses.map((e) => UnbondingDelegation.toJSON(e));
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageResponse.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryValidatorUnbondingDelegationsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryValidatorUnbondingDelegationsResponse();
        message.unbondingResponses = object.unbondingResponses?.map((e) => UnbondingDelegation.fromPartial(e)) || [];
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageResponse.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryDelegationRequest() {
    return { delegatorAddr: "", validatorAddr: "" };
}
const QueryDelegationRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.delegatorAddr !== "") {
            writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.validatorAddr !== "") {
            writer.uint32(18).string(message.validatorAddr);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegationRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.delegatorAddr = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.validatorAddr = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            delegatorAddr: isSet$a(object.delegatorAddr) ? String(object.delegatorAddr) : "",
            validatorAddr: isSet$a(object.validatorAddr) ? String(object.validatorAddr) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.delegatorAddr !== "") {
            obj.delegatorAddr = message.delegatorAddr;
        }
        if (message.validatorAddr !== "") {
            obj.validatorAddr = message.validatorAddr;
        }
        return obj;
    },
    create(base) {
        return QueryDelegationRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryDelegationRequest();
        message.delegatorAddr = object.delegatorAddr ?? "";
        message.validatorAddr = object.validatorAddr ?? "";
        return message;
    },
};
function createBaseQueryDelegationResponse() {
    return { delegationResponse: undefined };
}
const QueryDelegationResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.delegationResponse !== undefined) {
            DelegationResponse.encode(message.delegationResponse, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegationResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.delegationResponse = DelegationResponse.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            delegationResponse: isSet$a(object.delegationResponse)
                ? DelegationResponse.fromJSON(object.delegationResponse)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.delegationResponse !== undefined) {
            obj.delegationResponse = DelegationResponse.toJSON(message.delegationResponse);
        }
        return obj;
    },
    create(base) {
        return QueryDelegationResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryDelegationResponse();
        message.delegationResponse = (object.delegationResponse !== undefined && object.delegationResponse !== null)
            ? DelegationResponse.fromPartial(object.delegationResponse)
            : undefined;
        return message;
    },
};
function createBaseQueryUnbondingDelegationRequest() {
    return { delegatorAddr: "", validatorAddr: "" };
}
const QueryUnbondingDelegationRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.delegatorAddr !== "") {
            writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.validatorAddr !== "") {
            writer.uint32(18).string(message.validatorAddr);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryUnbondingDelegationRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.delegatorAddr = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.validatorAddr = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            delegatorAddr: isSet$a(object.delegatorAddr) ? String(object.delegatorAddr) : "",
            validatorAddr: isSet$a(object.validatorAddr) ? String(object.validatorAddr) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.delegatorAddr !== "") {
            obj.delegatorAddr = message.delegatorAddr;
        }
        if (message.validatorAddr !== "") {
            obj.validatorAddr = message.validatorAddr;
        }
        return obj;
    },
    create(base) {
        return QueryUnbondingDelegationRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryUnbondingDelegationRequest();
        message.delegatorAddr = object.delegatorAddr ?? "";
        message.validatorAddr = object.validatorAddr ?? "";
        return message;
    },
};
function createBaseQueryUnbondingDelegationResponse() {
    return { unbond: undefined };
}
const QueryUnbondingDelegationResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.unbond !== undefined) {
            UnbondingDelegation.encode(message.unbond, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryUnbondingDelegationResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.unbond = UnbondingDelegation.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { unbond: isSet$a(object.unbond) ? UnbondingDelegation.fromJSON(object.unbond) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.unbond !== undefined) {
            obj.unbond = UnbondingDelegation.toJSON(message.unbond);
        }
        return obj;
    },
    create(base) {
        return QueryUnbondingDelegationResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryUnbondingDelegationResponse();
        message.unbond = (object.unbond !== undefined && object.unbond !== null)
            ? UnbondingDelegation.fromPartial(object.unbond)
            : undefined;
        return message;
    },
};
function createBaseQueryDelegatorDelegationsRequest() {
    return { delegatorAddr: "", pagination: undefined };
}
const QueryDelegatorDelegationsRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.delegatorAddr !== "") {
            writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.pagination !== undefined) {
            PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorDelegationsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.delegatorAddr = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageRequest.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            delegatorAddr: isSet$a(object.delegatorAddr) ? String(object.delegatorAddr) : "",
            pagination: isSet$a(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.delegatorAddr !== "") {
            obj.delegatorAddr = message.delegatorAddr;
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageRequest.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryDelegatorDelegationsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryDelegatorDelegationsRequest();
        message.delegatorAddr = object.delegatorAddr ?? "";
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageRequest.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryDelegatorDelegationsResponse() {
    return { delegationResponses: [], pagination: undefined };
}
const QueryDelegatorDelegationsResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.delegationResponses) {
            DelegationResponse.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorDelegationsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.delegationResponses.push(DelegationResponse.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageResponse.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            delegationResponses: Array.isArray(object?.delegationResponses)
                ? object.delegationResponses.map((e) => DelegationResponse.fromJSON(e))
                : [],
            pagination: isSet$a(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.delegationResponses?.length) {
            obj.delegationResponses = message.delegationResponses.map((e) => DelegationResponse.toJSON(e));
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageResponse.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryDelegatorDelegationsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryDelegatorDelegationsResponse();
        message.delegationResponses = object.delegationResponses?.map((e) => DelegationResponse.fromPartial(e)) || [];
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageResponse.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryDelegatorUnbondingDelegationsRequest() {
    return { delegatorAddr: "", pagination: undefined };
}
const QueryDelegatorUnbondingDelegationsRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.delegatorAddr !== "") {
            writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.pagination !== undefined) {
            PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorUnbondingDelegationsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.delegatorAddr = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageRequest.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            delegatorAddr: isSet$a(object.delegatorAddr) ? String(object.delegatorAddr) : "",
            pagination: isSet$a(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.delegatorAddr !== "") {
            obj.delegatorAddr = message.delegatorAddr;
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageRequest.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryDelegatorUnbondingDelegationsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryDelegatorUnbondingDelegationsRequest();
        message.delegatorAddr = object.delegatorAddr ?? "";
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageRequest.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryDelegatorUnbondingDelegationsResponse() {
    return { unbondingResponses: [], pagination: undefined };
}
const QueryDelegatorUnbondingDelegationsResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.unbondingResponses) {
            UnbondingDelegation.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorUnbondingDelegationsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.unbondingResponses.push(UnbondingDelegation.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageResponse.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            unbondingResponses: Array.isArray(object?.unbondingResponses)
                ? object.unbondingResponses.map((e) => UnbondingDelegation.fromJSON(e))
                : [],
            pagination: isSet$a(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.unbondingResponses?.length) {
            obj.unbondingResponses = message.unbondingResponses.map((e) => UnbondingDelegation.toJSON(e));
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageResponse.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryDelegatorUnbondingDelegationsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryDelegatorUnbondingDelegationsResponse();
        message.unbondingResponses = object.unbondingResponses?.map((e) => UnbondingDelegation.fromPartial(e)) || [];
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageResponse.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryRedelegationsRequest() {
    return { delegatorAddr: "", srcValidatorAddr: "", dstValidatorAddr: "", pagination: undefined };
}
const QueryRedelegationsRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.delegatorAddr !== "") {
            writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.srcValidatorAddr !== "") {
            writer.uint32(18).string(message.srcValidatorAddr);
        }
        if (message.dstValidatorAddr !== "") {
            writer.uint32(26).string(message.dstValidatorAddr);
        }
        if (message.pagination !== undefined) {
            PageRequest.encode(message.pagination, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryRedelegationsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.delegatorAddr = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.srcValidatorAddr = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.dstValidatorAddr = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.pagination = PageRequest.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            delegatorAddr: isSet$a(object.delegatorAddr) ? String(object.delegatorAddr) : "",
            srcValidatorAddr: isSet$a(object.srcValidatorAddr) ? String(object.srcValidatorAddr) : "",
            dstValidatorAddr: isSet$a(object.dstValidatorAddr) ? String(object.dstValidatorAddr) : "",
            pagination: isSet$a(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.delegatorAddr !== "") {
            obj.delegatorAddr = message.delegatorAddr;
        }
        if (message.srcValidatorAddr !== "") {
            obj.srcValidatorAddr = message.srcValidatorAddr;
        }
        if (message.dstValidatorAddr !== "") {
            obj.dstValidatorAddr = message.dstValidatorAddr;
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageRequest.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryRedelegationsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryRedelegationsRequest();
        message.delegatorAddr = object.delegatorAddr ?? "";
        message.srcValidatorAddr = object.srcValidatorAddr ?? "";
        message.dstValidatorAddr = object.dstValidatorAddr ?? "";
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageRequest.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryRedelegationsResponse() {
    return { redelegationResponses: [], pagination: undefined };
}
const QueryRedelegationsResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.redelegationResponses) {
            RedelegationResponse.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryRedelegationsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.redelegationResponses.push(RedelegationResponse.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageResponse.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            redelegationResponses: Array.isArray(object?.redelegationResponses)
                ? object.redelegationResponses.map((e) => RedelegationResponse.fromJSON(e))
                : [],
            pagination: isSet$a(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.redelegationResponses?.length) {
            obj.redelegationResponses = message.redelegationResponses.map((e) => RedelegationResponse.toJSON(e));
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageResponse.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryRedelegationsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryRedelegationsResponse();
        message.redelegationResponses = object.redelegationResponses?.map((e) => RedelegationResponse.fromPartial(e)) || [];
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageResponse.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryDelegatorValidatorsRequest() {
    return { delegatorAddr: "", pagination: undefined };
}
const QueryDelegatorValidatorsRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.delegatorAddr !== "") {
            writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.pagination !== undefined) {
            PageRequest.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorValidatorsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.delegatorAddr = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageRequest.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            delegatorAddr: isSet$a(object.delegatorAddr) ? String(object.delegatorAddr) : "",
            pagination: isSet$a(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.delegatorAddr !== "") {
            obj.delegatorAddr = message.delegatorAddr;
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageRequest.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryDelegatorValidatorsRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryDelegatorValidatorsRequest();
        message.delegatorAddr = object.delegatorAddr ?? "";
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageRequest.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryDelegatorValidatorsResponse() {
    return { validators: [], pagination: undefined };
}
const QueryDelegatorValidatorsResponse = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.validators) {
            Validator.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.pagination !== undefined) {
            PageResponse.encode(message.pagination, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorValidatorsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.validators.push(Validator.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.pagination = PageResponse.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            validators: Array.isArray(object?.validators) ? object.validators.map((e) => Validator.fromJSON(e)) : [],
            pagination: isSet$a(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.validators?.length) {
            obj.validators = message.validators.map((e) => Validator.toJSON(e));
        }
        if (message.pagination !== undefined) {
            obj.pagination = PageResponse.toJSON(message.pagination);
        }
        return obj;
    },
    create(base) {
        return QueryDelegatorValidatorsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryDelegatorValidatorsResponse();
        message.validators = object.validators?.map((e) => Validator.fromPartial(e)) || [];
        message.pagination = (object.pagination !== undefined && object.pagination !== null)
            ? PageResponse.fromPartial(object.pagination)
            : undefined;
        return message;
    },
};
function createBaseQueryDelegatorValidatorRequest() {
    return { delegatorAddr: "", validatorAddr: "" };
}
const QueryDelegatorValidatorRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.delegatorAddr !== "") {
            writer.uint32(10).string(message.delegatorAddr);
        }
        if (message.validatorAddr !== "") {
            writer.uint32(18).string(message.validatorAddr);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorValidatorRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.delegatorAddr = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.validatorAddr = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            delegatorAddr: isSet$a(object.delegatorAddr) ? String(object.delegatorAddr) : "",
            validatorAddr: isSet$a(object.validatorAddr) ? String(object.validatorAddr) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.delegatorAddr !== "") {
            obj.delegatorAddr = message.delegatorAddr;
        }
        if (message.validatorAddr !== "") {
            obj.validatorAddr = message.validatorAddr;
        }
        return obj;
    },
    create(base) {
        return QueryDelegatorValidatorRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryDelegatorValidatorRequest();
        message.delegatorAddr = object.delegatorAddr ?? "";
        message.validatorAddr = object.validatorAddr ?? "";
        return message;
    },
};
function createBaseQueryDelegatorValidatorResponse() {
    return { validator: undefined };
}
const QueryDelegatorValidatorResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.validator !== undefined) {
            Validator.encode(message.validator, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryDelegatorValidatorResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.validator = Validator.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { validator: isSet$a(object.validator) ? Validator.fromJSON(object.validator) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.validator !== undefined) {
            obj.validator = Validator.toJSON(message.validator);
        }
        return obj;
    },
    create(base) {
        return QueryDelegatorValidatorResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryDelegatorValidatorResponse();
        message.validator = (object.validator !== undefined && object.validator !== null)
            ? Validator.fromPartial(object.validator)
            : undefined;
        return message;
    },
};
function createBaseQueryHistoricalInfoRequest() {
    return { height: 0 };
}
const QueryHistoricalInfoRequest = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.height !== 0) {
            writer.uint32(8).int64(message.height);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryHistoricalInfoRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.height = longToNumber$2(reader.int64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { height: isSet$a(object.height) ? Number(object.height) : 0 };
    },
    toJSON(message) {
        const obj = {};
        if (message.height !== 0) {
            obj.height = Math.round(message.height);
        }
        return obj;
    },
    create(base) {
        return QueryHistoricalInfoRequest.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryHistoricalInfoRequest();
        message.height = object.height ?? 0;
        return message;
    },
};
function createBaseQueryHistoricalInfoResponse() {
    return { hist: undefined };
}
const QueryHistoricalInfoResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.hist !== undefined) {
            HistoricalInfo.encode(message.hist, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryHistoricalInfoResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.hist = HistoricalInfo.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { hist: isSet$a(object.hist) ? HistoricalInfo.fromJSON(object.hist) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.hist !== undefined) {
            obj.hist = HistoricalInfo.toJSON(message.hist);
        }
        return obj;
    },
    create(base) {
        return QueryHistoricalInfoResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryHistoricalInfoResponse();
        message.hist = (object.hist !== undefined && object.hist !== null)
            ? HistoricalInfo.fromPartial(object.hist)
            : undefined;
        return message;
    },
};
function createBaseQueryPoolRequest() {
    return {};
}
const QueryPoolRequest = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryPoolRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return QueryPoolRequest.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseQueryPoolRequest();
        return message;
    },
};
function createBaseQueryPoolResponse() {
    return { pool: undefined };
}
const QueryPoolResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.pool !== undefined) {
            Pool.encode(message.pool, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryPoolResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.pool = Pool.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { pool: isSet$a(object.pool) ? Pool.fromJSON(object.pool) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.pool !== undefined) {
            obj.pool = Pool.toJSON(message.pool);
        }
        return obj;
    },
    create(base) {
        return QueryPoolResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryPoolResponse();
        message.pool = (object.pool !== undefined && object.pool !== null) ? Pool.fromPartial(object.pool) : undefined;
        return message;
    },
};
function createBaseQueryParamsRequest() {
    return {};
}
const QueryParamsRequest = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return QueryParamsRequest.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseQueryParamsRequest();
        return message;
    },
};
function createBaseQueryParamsResponse() {
    return { params: undefined };
}
const QueryParamsResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.params !== undefined) {
            Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseQueryParamsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.params = Params.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { params: isSet$a(object.params) ? Params.fromJSON(object.params) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.params !== undefined) {
            obj.params = Params.toJSON(message.params);
        }
        return obj;
    },
    create(base) {
        return QueryParamsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseQueryParamsResponse();
        message.params = (object.params !== undefined && object.params !== null)
            ? Params.fromPartial(object.params)
            : undefined;
        return message;
    },
};
class QueryClientImpl {
    rpc;
    constructor(rpc) {
        this.rpc = rpc;
        this.Validators = this.Validators.bind(this);
        this.Validator = this.Validator.bind(this);
        this.ValidatorDelegations = this.ValidatorDelegations.bind(this);
        this.ValidatorUnbondingDelegations = this.ValidatorUnbondingDelegations.bind(this);
        this.Delegation = this.Delegation.bind(this);
        this.UnbondingDelegation = this.UnbondingDelegation.bind(this);
        this.DelegatorDelegations = this.DelegatorDelegations.bind(this);
        this.DelegatorUnbondingDelegations = this.DelegatorUnbondingDelegations.bind(this);
        this.Redelegations = this.Redelegations.bind(this);
        this.DelegatorValidators = this.DelegatorValidators.bind(this);
        this.DelegatorValidator = this.DelegatorValidator.bind(this);
        this.HistoricalInfo = this.HistoricalInfo.bind(this);
        this.Pool = this.Pool.bind(this);
        this.Params = this.Params.bind(this);
    }
    Validators(request, metadata) {
        return this.rpc.unary(QueryValidatorsDesc, QueryValidatorsRequest.fromPartial(request), metadata);
    }
    Validator(request, metadata) {
        return this.rpc.unary(QueryValidatorDesc, QueryValidatorRequest.fromPartial(request), metadata);
    }
    ValidatorDelegations(request, metadata) {
        return this.rpc.unary(QueryValidatorDelegationsDesc, QueryValidatorDelegationsRequest.fromPartial(request), metadata);
    }
    ValidatorUnbondingDelegations(request, metadata) {
        return this.rpc.unary(QueryValidatorUnbondingDelegationsDesc, QueryValidatorUnbondingDelegationsRequest.fromPartial(request), metadata);
    }
    Delegation(request, metadata) {
        return this.rpc.unary(QueryDelegationDesc, QueryDelegationRequest.fromPartial(request), metadata);
    }
    UnbondingDelegation(request, metadata) {
        return this.rpc.unary(QueryUnbondingDelegationDesc, QueryUnbondingDelegationRequest.fromPartial(request), metadata);
    }
    DelegatorDelegations(request, metadata) {
        return this.rpc.unary(QueryDelegatorDelegationsDesc, QueryDelegatorDelegationsRequest.fromPartial(request), metadata);
    }
    DelegatorUnbondingDelegations(request, metadata) {
        return this.rpc.unary(QueryDelegatorUnbondingDelegationsDesc, QueryDelegatorUnbondingDelegationsRequest.fromPartial(request), metadata);
    }
    Redelegations(request, metadata) {
        return this.rpc.unary(QueryRedelegationsDesc, QueryRedelegationsRequest.fromPartial(request), metadata);
    }
    DelegatorValidators(request, metadata) {
        return this.rpc.unary(QueryDelegatorValidatorsDesc, QueryDelegatorValidatorsRequest.fromPartial(request), metadata);
    }
    DelegatorValidator(request, metadata) {
        return this.rpc.unary(QueryDelegatorValidatorDesc, QueryDelegatorValidatorRequest.fromPartial(request), metadata);
    }
    HistoricalInfo(request, metadata) {
        return this.rpc.unary(QueryHistoricalInfoDesc, QueryHistoricalInfoRequest.fromPartial(request), metadata);
    }
    Pool(request, metadata) {
        return this.rpc.unary(QueryPoolDesc, QueryPoolRequest.fromPartial(request), metadata);
    }
    Params(request, metadata) {
        return this.rpc.unary(QueryParamsDesc, QueryParamsRequest.fromPartial(request), metadata);
    }
}
const QueryDesc = { serviceName: "cosmos.staking.v1beta1.Query" };
const QueryValidatorsDesc = {
    methodName: "Validators",
    service: QueryDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryValidatorsRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryValidatorsResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryValidatorDesc = {
    methodName: "Validator",
    service: QueryDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryValidatorRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryValidatorResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryValidatorDelegationsDesc = {
    methodName: "ValidatorDelegations",
    service: QueryDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryValidatorDelegationsRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryValidatorDelegationsResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryValidatorUnbondingDelegationsDesc = {
    methodName: "ValidatorUnbondingDelegations",
    service: QueryDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryValidatorUnbondingDelegationsRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryValidatorUnbondingDelegationsResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryDelegationDesc = {
    methodName: "Delegation",
    service: QueryDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryDelegationRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryDelegationResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryUnbondingDelegationDesc = {
    methodName: "UnbondingDelegation",
    service: QueryDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryUnbondingDelegationRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryUnbondingDelegationResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryDelegatorDelegationsDesc = {
    methodName: "DelegatorDelegations",
    service: QueryDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryDelegatorDelegationsRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryDelegatorDelegationsResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryDelegatorUnbondingDelegationsDesc = {
    methodName: "DelegatorUnbondingDelegations",
    service: QueryDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryDelegatorUnbondingDelegationsRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryDelegatorUnbondingDelegationsResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryRedelegationsDesc = {
    methodName: "Redelegations",
    service: QueryDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryRedelegationsRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryRedelegationsResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryDelegatorValidatorsDesc = {
    methodName: "DelegatorValidators",
    service: QueryDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryDelegatorValidatorsRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryDelegatorValidatorsResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryDelegatorValidatorDesc = {
    methodName: "DelegatorValidator",
    service: QueryDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryDelegatorValidatorRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryDelegatorValidatorResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryHistoricalInfoDesc = {
    methodName: "HistoricalInfo",
    service: QueryDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryHistoricalInfoRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryHistoricalInfoResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryPoolDesc = {
    methodName: "Pool",
    service: QueryDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryPoolRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryPoolResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const QueryParamsDesc = {
    methodName: "Params",
    service: QueryDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return QueryParamsRequest.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = QueryParamsResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
let GrpcWebImpl$a = class GrpcWebImpl {
    host;
    options;
    constructor(host, options) {
        this.host = host;
        this.options = options;
    }
    unary(methodDesc, _request, metadata) {
        const request = { ..._request, ...methodDesc.requestType };
        const maybeCombinedMetadata = metadata && this.options.metadata
            ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
            : metadata ?? this.options.metadata;
        return new Promise((resolve, reject) => {
            grpc.unary(methodDesc, {
                request,
                host: this.host,
                metadata: maybeCombinedMetadata ?? {},
                ...(this.options.transport !== undefined ? { transport: this.options.transport } : {}),
                debug: this.options.debug ?? false,
                onEnd: function (response) {
                    if (response.status === grpc.Code.OK) {
                        resolve(response.message.toObject());
                    }
                    else {
                        const err = new GrpcWebError$a(response.statusMessage, response.status, response.trailers);
                        reject(err);
                    }
                },
            });
        });
    }
};
const tsProtoGlobalThis$a = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function longToNumber$2(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new tsProtoGlobalThis$a.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isSet$a(value) {
    return value !== null && value !== undefined;
}
let GrpcWebError$a = class GrpcWebError extends tsProtoGlobalThis$a.Error {
    code;
    metadata;
    constructor(message, code, metadata) {
        super(message);
        this.code = code;
        this.metadata = metadata;
    }
};

/* eslint-disable */
const protobufPackage$9 = "canine_chain.filetree";
function createBaseMsgPostFile() {
    return {
        creator: "",
        account: "",
        hashParent: "",
        hashChild: "",
        contents: "",
        viewers: "",
        editors: "",
        trackingNumber: "",
    };
}
const MsgPostFile = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.account !== "") {
            writer.uint32(18).string(message.account);
        }
        if (message.hashParent !== "") {
            writer.uint32(26).string(message.hashParent);
        }
        if (message.hashChild !== "") {
            writer.uint32(34).string(message.hashChild);
        }
        if (message.contents !== "") {
            writer.uint32(42).string(message.contents);
        }
        if (message.viewers !== "") {
            writer.uint32(50).string(message.viewers);
        }
        if (message.editors !== "") {
            writer.uint32(58).string(message.editors);
        }
        if (message.trackingNumber !== "") {
            writer.uint32(66).string(message.trackingNumber);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgPostFile();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.account = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.hashParent = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.hashChild = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.contents = reader.string();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.viewers = reader.string();
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.editors = reader.string();
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.trackingNumber = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet$9(object.creator) ? String(object.creator) : "",
            account: isSet$9(object.account) ? String(object.account) : "",
            hashParent: isSet$9(object.hashParent) ? String(object.hashParent) : "",
            hashChild: isSet$9(object.hashChild) ? String(object.hashChild) : "",
            contents: isSet$9(object.contents) ? String(object.contents) : "",
            viewers: isSet$9(object.viewers) ? String(object.viewers) : "",
            editors: isSet$9(object.editors) ? String(object.editors) : "",
            trackingNumber: isSet$9(object.trackingNumber) ? String(object.trackingNumber) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.account !== "") {
            obj.account = message.account;
        }
        if (message.hashParent !== "") {
            obj.hashParent = message.hashParent;
        }
        if (message.hashChild !== "") {
            obj.hashChild = message.hashChild;
        }
        if (message.contents !== "") {
            obj.contents = message.contents;
        }
        if (message.viewers !== "") {
            obj.viewers = message.viewers;
        }
        if (message.editors !== "") {
            obj.editors = message.editors;
        }
        if (message.trackingNumber !== "") {
            obj.trackingNumber = message.trackingNumber;
        }
        return obj;
    },
    create(base) {
        return MsgPostFile.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgPostFile();
        message.creator = object.creator ?? "";
        message.account = object.account ?? "";
        message.hashParent = object.hashParent ?? "";
        message.hashChild = object.hashChild ?? "";
        message.contents = object.contents ?? "";
        message.viewers = object.viewers ?? "";
        message.editors = object.editors ?? "";
        message.trackingNumber = object.trackingNumber ?? "";
        return message;
    },
};
function createBaseMsgPostFileResponse() {
    return { path: "" };
}
const MsgPostFileResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.path !== "") {
            writer.uint32(10).string(message.path);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgPostFileResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.path = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { path: isSet$9(object.path) ? String(object.path) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.path !== "") {
            obj.path = message.path;
        }
        return obj;
    },
    create(base) {
        return MsgPostFileResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgPostFileResponse();
        message.path = object.path ?? "";
        return message;
    },
};
function createBaseMsgAddViewers() {
    return { creator: "", viewerIds: "", viewerKeys: "", address: "", fileowner: "" };
}
const MsgAddViewers = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.viewerIds !== "") {
            writer.uint32(18).string(message.viewerIds);
        }
        if (message.viewerKeys !== "") {
            writer.uint32(26).string(message.viewerKeys);
        }
        if (message.address !== "") {
            writer.uint32(34).string(message.address);
        }
        if (message.fileowner !== "") {
            writer.uint32(42).string(message.fileowner);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgAddViewers();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.viewerIds = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.viewerKeys = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.fileowner = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet$9(object.creator) ? String(object.creator) : "",
            viewerIds: isSet$9(object.viewerIds) ? String(object.viewerIds) : "",
            viewerKeys: isSet$9(object.viewerKeys) ? String(object.viewerKeys) : "",
            address: isSet$9(object.address) ? String(object.address) : "",
            fileowner: isSet$9(object.fileowner) ? String(object.fileowner) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.viewerIds !== "") {
            obj.viewerIds = message.viewerIds;
        }
        if (message.viewerKeys !== "") {
            obj.viewerKeys = message.viewerKeys;
        }
        if (message.address !== "") {
            obj.address = message.address;
        }
        if (message.fileowner !== "") {
            obj.fileowner = message.fileowner;
        }
        return obj;
    },
    create(base) {
        return MsgAddViewers.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgAddViewers();
        message.creator = object.creator ?? "";
        message.viewerIds = object.viewerIds ?? "";
        message.viewerKeys = object.viewerKeys ?? "";
        message.address = object.address ?? "";
        message.fileowner = object.fileowner ?? "";
        return message;
    },
};
function createBaseMsgAddViewersResponse() {
    return {};
}
const MsgAddViewersResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgAddViewersResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgAddViewersResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgAddViewersResponse();
        return message;
    },
};
function createBaseMsgPostkey() {
    return { creator: "", key: "" };
}
const MsgPostkey = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.key !== "") {
            writer.uint32(18).string(message.key);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgPostkey();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet$9(object.creator) ? String(object.creator) : "",
            key: isSet$9(object.key) ? String(object.key) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.key !== "") {
            obj.key = message.key;
        }
        return obj;
    },
    create(base) {
        return MsgPostkey.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgPostkey();
        message.creator = object.creator ?? "";
        message.key = object.key ?? "";
        return message;
    },
};
function createBaseMsgPostkeyResponse() {
    return {};
}
const MsgPostkeyResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgPostkeyResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgPostkeyResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgPostkeyResponse();
        return message;
    },
};
function createBaseMsgDeleteFile() {
    return { creator: "", hashPath: "", account: "" };
}
const MsgDeleteFile = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.hashPath !== "") {
            writer.uint32(18).string(message.hashPath);
        }
        if (message.account !== "") {
            writer.uint32(26).string(message.account);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgDeleteFile();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.hashPath = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.account = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet$9(object.creator) ? String(object.creator) : "",
            hashPath: isSet$9(object.hashPath) ? String(object.hashPath) : "",
            account: isSet$9(object.account) ? String(object.account) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.hashPath !== "") {
            obj.hashPath = message.hashPath;
        }
        if (message.account !== "") {
            obj.account = message.account;
        }
        return obj;
    },
    create(base) {
        return MsgDeleteFile.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgDeleteFile();
        message.creator = object.creator ?? "";
        message.hashPath = object.hashPath ?? "";
        message.account = object.account ?? "";
        return message;
    },
};
function createBaseMsgDeleteFileResponse() {
    return {};
}
const MsgDeleteFileResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgDeleteFileResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgDeleteFileResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgDeleteFileResponse();
        return message;
    },
};
function createBaseMsgRemoveViewers() {
    return { creator: "", viewerIds: "", address: "", fileowner: "" };
}
const MsgRemoveViewers = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.viewerIds !== "") {
            writer.uint32(18).string(message.viewerIds);
        }
        if (message.address !== "") {
            writer.uint32(26).string(message.address);
        }
        if (message.fileowner !== "") {
            writer.uint32(34).string(message.fileowner);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRemoveViewers();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.viewerIds = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.fileowner = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet$9(object.creator) ? String(object.creator) : "",
            viewerIds: isSet$9(object.viewerIds) ? String(object.viewerIds) : "",
            address: isSet$9(object.address) ? String(object.address) : "",
            fileowner: isSet$9(object.fileowner) ? String(object.fileowner) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.viewerIds !== "") {
            obj.viewerIds = message.viewerIds;
        }
        if (message.address !== "") {
            obj.address = message.address;
        }
        if (message.fileowner !== "") {
            obj.fileowner = message.fileowner;
        }
        return obj;
    },
    create(base) {
        return MsgRemoveViewers.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgRemoveViewers();
        message.creator = object.creator ?? "";
        message.viewerIds = object.viewerIds ?? "";
        message.address = object.address ?? "";
        message.fileowner = object.fileowner ?? "";
        return message;
    },
};
function createBaseMsgRemoveViewersResponse() {
    return {};
}
const MsgRemoveViewersResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRemoveViewersResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgRemoveViewersResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgRemoveViewersResponse();
        return message;
    },
};
function createBaseMsgMakeRoot() {
    return { creator: "", account: "", rootHashPath: "", contents: "", editors: "", viewers: "", trackingNumber: "" };
}
const MsgMakeRoot = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.account !== "") {
            writer.uint32(18).string(message.account);
        }
        if (message.rootHashPath !== "") {
            writer.uint32(26).string(message.rootHashPath);
        }
        if (message.contents !== "") {
            writer.uint32(34).string(message.contents);
        }
        if (message.editors !== "") {
            writer.uint32(42).string(message.editors);
        }
        if (message.viewers !== "") {
            writer.uint32(50).string(message.viewers);
        }
        if (message.trackingNumber !== "") {
            writer.uint32(58).string(message.trackingNumber);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgMakeRoot();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.account = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.rootHashPath = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.contents = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.editors = reader.string();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.viewers = reader.string();
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.trackingNumber = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet$9(object.creator) ? String(object.creator) : "",
            account: isSet$9(object.account) ? String(object.account) : "",
            rootHashPath: isSet$9(object.rootHashPath) ? String(object.rootHashPath) : "",
            contents: isSet$9(object.contents) ? String(object.contents) : "",
            editors: isSet$9(object.editors) ? String(object.editors) : "",
            viewers: isSet$9(object.viewers) ? String(object.viewers) : "",
            trackingNumber: isSet$9(object.trackingNumber) ? String(object.trackingNumber) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.account !== "") {
            obj.account = message.account;
        }
        if (message.rootHashPath !== "") {
            obj.rootHashPath = message.rootHashPath;
        }
        if (message.contents !== "") {
            obj.contents = message.contents;
        }
        if (message.editors !== "") {
            obj.editors = message.editors;
        }
        if (message.viewers !== "") {
            obj.viewers = message.viewers;
        }
        if (message.trackingNumber !== "") {
            obj.trackingNumber = message.trackingNumber;
        }
        return obj;
    },
    create(base) {
        return MsgMakeRoot.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgMakeRoot();
        message.creator = object.creator ?? "";
        message.account = object.account ?? "";
        message.rootHashPath = object.rootHashPath ?? "";
        message.contents = object.contents ?? "";
        message.editors = object.editors ?? "";
        message.viewers = object.viewers ?? "";
        message.trackingNumber = object.trackingNumber ?? "";
        return message;
    },
};
function createBaseMsgMakeRootResponse() {
    return {};
}
const MsgMakeRootResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgMakeRootResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgMakeRootResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgMakeRootResponse();
        return message;
    },
};
function createBaseMsgMakeRootV2() {
    return { creator: "", editors: "", viewers: "", trackingNumber: "" };
}
const MsgMakeRootV2 = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.editors !== "") {
            writer.uint32(18).string(message.editors);
        }
        if (message.viewers !== "") {
            writer.uint32(26).string(message.viewers);
        }
        if (message.trackingNumber !== "") {
            writer.uint32(34).string(message.trackingNumber);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgMakeRootV2();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.editors = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.viewers = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.trackingNumber = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet$9(object.creator) ? String(object.creator) : "",
            editors: isSet$9(object.editors) ? String(object.editors) : "",
            viewers: isSet$9(object.viewers) ? String(object.viewers) : "",
            trackingNumber: isSet$9(object.trackingNumber) ? String(object.trackingNumber) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.editors !== "") {
            obj.editors = message.editors;
        }
        if (message.viewers !== "") {
            obj.viewers = message.viewers;
        }
        if (message.trackingNumber !== "") {
            obj.trackingNumber = message.trackingNumber;
        }
        return obj;
    },
    create(base) {
        return MsgMakeRootV2.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgMakeRootV2();
        message.creator = object.creator ?? "";
        message.editors = object.editors ?? "";
        message.viewers = object.viewers ?? "";
        message.trackingNumber = object.trackingNumber ?? "";
        return message;
    },
};
function createBaseMsgAddEditors() {
    return { creator: "", editorIds: "", editorKeys: "", address: "", fileowner: "" };
}
const MsgAddEditors = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.editorIds !== "") {
            writer.uint32(18).string(message.editorIds);
        }
        if (message.editorKeys !== "") {
            writer.uint32(26).string(message.editorKeys);
        }
        if (message.address !== "") {
            writer.uint32(34).string(message.address);
        }
        if (message.fileowner !== "") {
            writer.uint32(42).string(message.fileowner);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgAddEditors();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.editorIds = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.editorKeys = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.fileowner = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet$9(object.creator) ? String(object.creator) : "",
            editorIds: isSet$9(object.editorIds) ? String(object.editorIds) : "",
            editorKeys: isSet$9(object.editorKeys) ? String(object.editorKeys) : "",
            address: isSet$9(object.address) ? String(object.address) : "",
            fileowner: isSet$9(object.fileowner) ? String(object.fileowner) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.editorIds !== "") {
            obj.editorIds = message.editorIds;
        }
        if (message.editorKeys !== "") {
            obj.editorKeys = message.editorKeys;
        }
        if (message.address !== "") {
            obj.address = message.address;
        }
        if (message.fileowner !== "") {
            obj.fileowner = message.fileowner;
        }
        return obj;
    },
    create(base) {
        return MsgAddEditors.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgAddEditors();
        message.creator = object.creator ?? "";
        message.editorIds = object.editorIds ?? "";
        message.editorKeys = object.editorKeys ?? "";
        message.address = object.address ?? "";
        message.fileowner = object.fileowner ?? "";
        return message;
    },
};
function createBaseMsgAddEditorsResponse() {
    return {};
}
const MsgAddEditorsResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgAddEditorsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgAddEditorsResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgAddEditorsResponse();
        return message;
    },
};
function createBaseMsgRemoveEditors() {
    return { creator: "", editorIds: "", address: "", fileowner: "" };
}
const MsgRemoveEditors = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.editorIds !== "") {
            writer.uint32(18).string(message.editorIds);
        }
        if (message.address !== "") {
            writer.uint32(26).string(message.address);
        }
        if (message.fileowner !== "") {
            writer.uint32(34).string(message.fileowner);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRemoveEditors();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.editorIds = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.fileowner = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet$9(object.creator) ? String(object.creator) : "",
            editorIds: isSet$9(object.editorIds) ? String(object.editorIds) : "",
            address: isSet$9(object.address) ? String(object.address) : "",
            fileowner: isSet$9(object.fileowner) ? String(object.fileowner) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.editorIds !== "") {
            obj.editorIds = message.editorIds;
        }
        if (message.address !== "") {
            obj.address = message.address;
        }
        if (message.fileowner !== "") {
            obj.fileowner = message.fileowner;
        }
        return obj;
    },
    create(base) {
        return MsgRemoveEditors.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgRemoveEditors();
        message.creator = object.creator ?? "";
        message.editorIds = object.editorIds ?? "";
        message.address = object.address ?? "";
        message.fileowner = object.fileowner ?? "";
        return message;
    },
};
function createBaseMsgRemoveEditorsResponse() {
    return {};
}
const MsgRemoveEditorsResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRemoveEditorsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgRemoveEditorsResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgRemoveEditorsResponse();
        return message;
    },
};
function createBaseMsgResetEditors() {
    return { creator: "", address: "", fileowner: "" };
}
const MsgResetEditors = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.address !== "") {
            writer.uint32(18).string(message.address);
        }
        if (message.fileowner !== "") {
            writer.uint32(26).string(message.fileowner);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgResetEditors();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.fileowner = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet$9(object.creator) ? String(object.creator) : "",
            address: isSet$9(object.address) ? String(object.address) : "",
            fileowner: isSet$9(object.fileowner) ? String(object.fileowner) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.address !== "") {
            obj.address = message.address;
        }
        if (message.fileowner !== "") {
            obj.fileowner = message.fileowner;
        }
        return obj;
    },
    create(base) {
        return MsgResetEditors.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgResetEditors();
        message.creator = object.creator ?? "";
        message.address = object.address ?? "";
        message.fileowner = object.fileowner ?? "";
        return message;
    },
};
function createBaseMsgResetEditorsResponse() {
    return {};
}
const MsgResetEditorsResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgResetEditorsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgResetEditorsResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgResetEditorsResponse();
        return message;
    },
};
function createBaseMsgResetViewers() {
    return { creator: "", address: "", fileowner: "" };
}
const MsgResetViewers = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.address !== "") {
            writer.uint32(18).string(message.address);
        }
        if (message.fileowner !== "") {
            writer.uint32(26).string(message.fileowner);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgResetViewers();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.fileowner = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet$9(object.creator) ? String(object.creator) : "",
            address: isSet$9(object.address) ? String(object.address) : "",
            fileowner: isSet$9(object.fileowner) ? String(object.fileowner) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.address !== "") {
            obj.address = message.address;
        }
        if (message.fileowner !== "") {
            obj.fileowner = message.fileowner;
        }
        return obj;
    },
    create(base) {
        return MsgResetViewers.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgResetViewers();
        message.creator = object.creator ?? "";
        message.address = object.address ?? "";
        message.fileowner = object.fileowner ?? "";
        return message;
    },
};
function createBaseMsgResetViewersResponse() {
    return {};
}
const MsgResetViewersResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgResetViewersResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgResetViewersResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgResetViewersResponse();
        return message;
    },
};
function createBaseMsgChangeOwner() {
    return { creator: "", address: "", fileOwner: "", newOwner: "" };
}
const MsgChangeOwner = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.address !== "") {
            writer.uint32(18).string(message.address);
        }
        if (message.fileOwner !== "") {
            writer.uint32(26).string(message.fileOwner);
        }
        if (message.newOwner !== "") {
            writer.uint32(34).string(message.newOwner);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChangeOwner();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.fileOwner = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.newOwner = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet$9(object.creator) ? String(object.creator) : "",
            address: isSet$9(object.address) ? String(object.address) : "",
            fileOwner: isSet$9(object.fileOwner) ? String(object.fileOwner) : "",
            newOwner: isSet$9(object.newOwner) ? String(object.newOwner) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.address !== "") {
            obj.address = message.address;
        }
        if (message.fileOwner !== "") {
            obj.fileOwner = message.fileOwner;
        }
        if (message.newOwner !== "") {
            obj.newOwner = message.newOwner;
        }
        return obj;
    },
    create(base) {
        return MsgChangeOwner.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgChangeOwner();
        message.creator = object.creator ?? "";
        message.address = object.address ?? "";
        message.fileOwner = object.fileOwner ?? "";
        message.newOwner = object.newOwner ?? "";
        return message;
    },
};
function createBaseMsgChangeOwnerResponse() {
    return {};
}
const MsgChangeOwnerResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgChangeOwnerResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgChangeOwnerResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgChangeOwnerResponse();
        return message;
    },
};
let MsgClientImpl$9 = class MsgClientImpl {
    rpc;
    constructor(rpc) {
        this.rpc = rpc;
        this.PostFile = this.PostFile.bind(this);
        this.AddViewers = this.AddViewers.bind(this);
        this.Postkey = this.Postkey.bind(this);
        this.DeleteFile = this.DeleteFile.bind(this);
        this.RemoveViewers = this.RemoveViewers.bind(this);
        this.MakeRoot = this.MakeRoot.bind(this);
        this.MakeRootV2 = this.MakeRootV2.bind(this);
        this.AddEditors = this.AddEditors.bind(this);
        this.RemoveEditors = this.RemoveEditors.bind(this);
        this.ResetEditors = this.ResetEditors.bind(this);
        this.ResetViewers = this.ResetViewers.bind(this);
        this.ChangeOwner = this.ChangeOwner.bind(this);
    }
    PostFile(request, metadata) {
        return this.rpc.unary(MsgPostFileDesc, MsgPostFile.fromPartial(request), metadata);
    }
    AddViewers(request, metadata) {
        return this.rpc.unary(MsgAddViewersDesc, MsgAddViewers.fromPartial(request), metadata);
    }
    Postkey(request, metadata) {
        return this.rpc.unary(MsgPostkeyDesc, MsgPostkey.fromPartial(request), metadata);
    }
    DeleteFile(request, metadata) {
        return this.rpc.unary(MsgDeleteFileDesc, MsgDeleteFile.fromPartial(request), metadata);
    }
    RemoveViewers(request, metadata) {
        return this.rpc.unary(MsgRemoveViewersDesc, MsgRemoveViewers.fromPartial(request), metadata);
    }
    MakeRoot(request, metadata) {
        return this.rpc.unary(MsgMakeRootDesc, MsgMakeRoot.fromPartial(request), metadata);
    }
    MakeRootV2(request, metadata) {
        return this.rpc.unary(MsgMakeRootV2Desc, MsgMakeRootV2.fromPartial(request), metadata);
    }
    AddEditors(request, metadata) {
        return this.rpc.unary(MsgAddEditorsDesc, MsgAddEditors.fromPartial(request), metadata);
    }
    RemoveEditors(request, metadata) {
        return this.rpc.unary(MsgRemoveEditorsDesc, MsgRemoveEditors.fromPartial(request), metadata);
    }
    ResetEditors(request, metadata) {
        return this.rpc.unary(MsgResetEditorsDesc, MsgResetEditors.fromPartial(request), metadata);
    }
    ResetViewers(request, metadata) {
        return this.rpc.unary(MsgResetViewersDesc, MsgResetViewers.fromPartial(request), metadata);
    }
    ChangeOwner(request, metadata) {
        return this.rpc.unary(MsgChangeOwnerDesc, MsgChangeOwner.fromPartial(request), metadata);
    }
};
const MsgDesc$9 = { serviceName: "canine_chain.filetree.Msg" };
const MsgPostFileDesc = {
    methodName: "PostFile",
    service: MsgDesc$9,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgPostFile.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgPostFileResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgAddViewersDesc = {
    methodName: "AddViewers",
    service: MsgDesc$9,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgAddViewers.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgAddViewersResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgPostkeyDesc = {
    methodName: "Postkey",
    service: MsgDesc$9,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgPostkey.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgPostkeyResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgDeleteFileDesc = {
    methodName: "DeleteFile",
    service: MsgDesc$9,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgDeleteFile.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgDeleteFileResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgRemoveViewersDesc = {
    methodName: "RemoveViewers",
    service: MsgDesc$9,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgRemoveViewers.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgRemoveViewersResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgMakeRootDesc = {
    methodName: "MakeRoot",
    service: MsgDesc$9,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgMakeRoot.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgMakeRootResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgMakeRootV2Desc = {
    methodName: "MakeRootV2",
    service: MsgDesc$9,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgMakeRootV2.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgMakeRootResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgAddEditorsDesc = {
    methodName: "AddEditors",
    service: MsgDesc$9,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgAddEditors.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgAddEditorsResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgRemoveEditorsDesc = {
    methodName: "RemoveEditors",
    service: MsgDesc$9,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgRemoveEditors.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgRemoveEditorsResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgResetEditorsDesc = {
    methodName: "ResetEditors",
    service: MsgDesc$9,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgResetEditors.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgResetEditorsResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgResetViewersDesc = {
    methodName: "ResetViewers",
    service: MsgDesc$9,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgResetViewers.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgResetViewersResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgChangeOwnerDesc = {
    methodName: "ChangeOwner",
    service: MsgDesc$9,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgChangeOwner.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgChangeOwnerResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
let GrpcWebImpl$9 = class GrpcWebImpl {
    host;
    options;
    constructor(host, options) {
        this.host = host;
        this.options = options;
    }
    unary(methodDesc, _request, metadata) {
        const request = { ..._request, ...methodDesc.requestType };
        const maybeCombinedMetadata = metadata && this.options.metadata
            ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
            : metadata ?? this.options.metadata;
        return new Promise((resolve, reject) => {
            grpc.unary(methodDesc, {
                request,
                host: this.host,
                metadata: maybeCombinedMetadata ?? {},
                ...(this.options.transport !== undefined ? { transport: this.options.transport } : {}),
                debug: this.options.debug ?? false,
                onEnd: function (response) {
                    if (response.status === grpc.Code.OK) {
                        resolve(response.message.toObject());
                    }
                    else {
                        const err = new GrpcWebError$9(response.statusMessage, response.status, response.trailers);
                        reject(err);
                    }
                },
            });
        });
    }
};
const tsProtoGlobalThis$9 = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function isSet$9(value) {
    return value !== null && value !== undefined;
}
let GrpcWebError$9 = class GrpcWebError extends tsProtoGlobalThis$9.Error {
    code;
    metadata;
    constructor(message, code, metadata) {
        super(message);
        this.code = code;
        this.metadata = metadata;
    }
};

function deprecated(thing, version, opts) {
    let notice = `jackal.js-protos | ${thing} is deprecated as of: ${version}`;
    if (opts?.replacement) {
        notice += ` - Please use ${opts.replacement} instead`;
    }
    console.error(notice);
    if (opts?.aggressive)
        alert(notice);
}

const fileTreeTypes = {
    postFile: ['/canine_chain.filetree.MsgPostFile', MsgPostFile],
    addViewers: ['/canine_chain.filetree.MsgAddViewers', MsgAddViewers],
    postkey: ['/canine_chain.filetree.MsgPostkey', MsgPostkey],
    deleteFile: ['/canine_chain.filetree.MsgDeleteFile', MsgDeleteFile],
    removeViewers: ['/canine_chain.filetree.MsgRemoveViewers', MsgRemoveViewers],
    makeRoot: ['/canine_chain.filetree.MsgMakeRoot', MsgMakeRoot],
    makeRootV2: ['/canine_chain.filetree.MsgMakeRootV2', MsgMakeRootV2],
    addEditors: ['/canine_chain.filetree.MsgAddEditors', MsgAddEditors],
    removeEditors: ['/canine_chain.filetree.MsgRemoveEditors', MsgRemoveEditors],
    resetEditors: ['/canine_chain.filetree.MsgResetEditors', MsgResetEditors],
    resetViewers: ['/canine_chain.filetree.MsgResetViewers', MsgResetViewers],
    changeOwner: ['/canine_chain.filetree.MsgChangeOwner', MsgChangeOwner]
};
class TxFileTree {
    msgPostFile(data) {
        return {
            typeUrl: fileTreeTypes.postFile[0],
            value: fileTreeTypes.postFile[1].fromPartial(data)
        };
    }
    msgAddViewers(data) {
        return {
            typeUrl: fileTreeTypes.addViewers[0],
            value: fileTreeTypes.addViewers[1].fromPartial(data)
        };
    }
    msgPostkey(data) {
        return {
            typeUrl: fileTreeTypes.postkey[0],
            value: fileTreeTypes.postkey[1].fromPartial(data)
        };
    }
    msgDeleteFile(data) {
        return {
            typeUrl: fileTreeTypes.deleteFile[0],
            value: fileTreeTypes.deleteFile[1].fromPartial(data)
        };
    }
    msgRemoveViewers(data) {
        return {
            typeUrl: fileTreeTypes.removeViewers[0],
            value: fileTreeTypes.removeViewers[1].fromPartial(data)
        };
    }
    msgMakeRoot(data) {
        deprecated('[FileTree] msgMakeRoot', 'v1.3.0', {
            replacement: 'msgMakeRootV2'
        });
        return {
            typeUrl: fileTreeTypes.makeRoot[0],
            value: fileTreeTypes.makeRoot[1].fromPartial(data)
        };
    }
    msgMakeRootV2(data) {
        return {
            typeUrl: fileTreeTypes.makeRootV2[0],
            value: fileTreeTypes.makeRootV2[1].fromPartial(data)
        };
    }
    msgAddEditors(data) {
        return {
            typeUrl: fileTreeTypes.addEditors[0],
            value: fileTreeTypes.addEditors[1].fromPartial(data)
        };
    }
    msgRemoveEditors(data) {
        return {
            typeUrl: fileTreeTypes.removeEditors[0],
            value: fileTreeTypes.removeEditors[1].fromPartial(data)
        };
    }
    msgResetEditors(data) {
        return {
            typeUrl: fileTreeTypes.resetEditors[0],
            value: fileTreeTypes.resetEditors[1].fromPartial(data)
        };
    }
    msgResetViewers(data) {
        return {
            typeUrl: fileTreeTypes.resetViewers[0],
            value: fileTreeTypes.resetViewers[1].fromPartial(data)
        };
    }
    msgChangeOwner(data) {
        return {
            typeUrl: fileTreeTypes.changeOwner[0],
            value: fileTreeTypes.changeOwner[1].fromPartial(data)
        };
    }
}

/* eslint-disable */
const protobufPackage$8 = "canine_chain.notifications";
function createBaseMsgCreateNotifications() {
    return { creator: "", notification: "", address: "" };
}
const MsgCreateNotifications = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.notification !== "") {
            writer.uint32(18).string(message.notification);
        }
        if (message.address !== "") {
            writer.uint32(26).string(message.address);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateNotifications();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.notification = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet$8(object.creator) ? String(object.creator) : "",
            notification: isSet$8(object.notification) ? String(object.notification) : "",
            address: isSet$8(object.address) ? String(object.address) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.notification !== "") {
            obj.notification = message.notification;
        }
        if (message.address !== "") {
            obj.address = message.address;
        }
        return obj;
    },
    create(base) {
        return MsgCreateNotifications.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgCreateNotifications();
        message.creator = object.creator ?? "";
        message.notification = object.notification ?? "";
        message.address = object.address ?? "";
        return message;
    },
};
function createBaseMsgCreateNotificationsResponse() {
    return { notiCounter: 0 };
}
const MsgCreateNotificationsResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.notiCounter !== 0) {
            writer.uint32(8).uint64(message.notiCounter);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateNotificationsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.notiCounter = longToNumber$1(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { notiCounter: isSet$8(object.notiCounter) ? Number(object.notiCounter) : 0 };
    },
    toJSON(message) {
        const obj = {};
        if (message.notiCounter !== 0) {
            obj.notiCounter = Math.round(message.notiCounter);
        }
        return obj;
    },
    create(base) {
        return MsgCreateNotificationsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgCreateNotificationsResponse();
        message.notiCounter = object.notiCounter ?? 0;
        return message;
    },
};
function createBaseMsgUpdateNotifications() {
    return { creator: "", count: 0, notification: "", address: "" };
}
const MsgUpdateNotifications = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.count !== 0) {
            writer.uint32(16).uint64(message.count);
        }
        if (message.notification !== "") {
            writer.uint32(26).string(message.notification);
        }
        if (message.address !== "") {
            writer.uint32(34).string(message.address);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateNotifications();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.count = longToNumber$1(reader.uint64());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.notification = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.address = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet$8(object.creator) ? String(object.creator) : "",
            count: isSet$8(object.count) ? Number(object.count) : 0,
            notification: isSet$8(object.notification) ? String(object.notification) : "",
            address: isSet$8(object.address) ? String(object.address) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.count !== 0) {
            obj.count = Math.round(message.count);
        }
        if (message.notification !== "") {
            obj.notification = message.notification;
        }
        if (message.address !== "") {
            obj.address = message.address;
        }
        return obj;
    },
    create(base) {
        return MsgUpdateNotifications.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgUpdateNotifications();
        message.creator = object.creator ?? "";
        message.count = object.count ?? 0;
        message.notification = object.notification ?? "";
        message.address = object.address ?? "";
        return message;
    },
};
function createBaseMsgUpdateNotificationsResponse() {
    return {};
}
const MsgUpdateNotificationsResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateNotificationsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgUpdateNotificationsResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgUpdateNotificationsResponse();
        return message;
    },
};
function createBaseMsgDeleteNotifications() {
    return { creator: "" };
}
const MsgDeleteNotifications = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgDeleteNotifications();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { creator: isSet$8(object.creator) ? String(object.creator) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        return obj;
    },
    create(base) {
        return MsgDeleteNotifications.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgDeleteNotifications();
        message.creator = object.creator ?? "";
        return message;
    },
};
function createBaseMsgDeleteNotificationsResponse() {
    return { notiCounter: 0 };
}
const MsgDeleteNotificationsResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.notiCounter !== 0) {
            writer.uint32(8).uint64(message.notiCounter);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgDeleteNotificationsResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.notiCounter = longToNumber$1(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { notiCounter: isSet$8(object.notiCounter) ? Number(object.notiCounter) : 0 };
    },
    toJSON(message) {
        const obj = {};
        if (message.notiCounter !== 0) {
            obj.notiCounter = Math.round(message.notiCounter);
        }
        return obj;
    },
    create(base) {
        return MsgDeleteNotificationsResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgDeleteNotificationsResponse();
        message.notiCounter = object.notiCounter ?? 0;
        return message;
    },
};
function createBaseMsgSetCounter() {
    return { creator: "" };
}
const MsgSetCounter = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSetCounter();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { creator: isSet$8(object.creator) ? String(object.creator) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        return obj;
    },
    create(base) {
        return MsgSetCounter.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgSetCounter();
        message.creator = object.creator ?? "";
        return message;
    },
};
function createBaseMsgSetCounterResponse() {
    return { notiCounter: 0 };
}
const MsgSetCounterResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.notiCounter !== 0) {
            writer.uint32(8).uint64(message.notiCounter);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSetCounterResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.notiCounter = longToNumber$1(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { notiCounter: isSet$8(object.notiCounter) ? Number(object.notiCounter) : 0 };
    },
    toJSON(message) {
        const obj = {};
        if (message.notiCounter !== 0) {
            obj.notiCounter = Math.round(message.notiCounter);
        }
        return obj;
    },
    create(base) {
        return MsgSetCounterResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgSetCounterResponse();
        message.notiCounter = object.notiCounter ?? 0;
        return message;
    },
};
function createBaseMsgBlockSenders() {
    return { creator: "", senderIds: "" };
}
const MsgBlockSenders = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.senderIds !== "") {
            writer.uint32(18).string(message.senderIds);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgBlockSenders();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.senderIds = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet$8(object.creator) ? String(object.creator) : "",
            senderIds: isSet$8(object.senderIds) ? String(object.senderIds) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.senderIds !== "") {
            obj.senderIds = message.senderIds;
        }
        return obj;
    },
    create(base) {
        return MsgBlockSenders.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgBlockSenders();
        message.creator = object.creator ?? "";
        message.senderIds = object.senderIds ?? "";
        return message;
    },
};
function createBaseMsgBlockSendersResponse() {
    return {};
}
const MsgBlockSendersResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgBlockSendersResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgBlockSendersResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgBlockSendersResponse();
        return message;
    },
};
let MsgClientImpl$8 = class MsgClientImpl {
    rpc;
    constructor(rpc) {
        this.rpc = rpc;
        this.CreateNotifications = this.CreateNotifications.bind(this);
        this.UpdateNotifications = this.UpdateNotifications.bind(this);
        this.DeleteNotifications = this.DeleteNotifications.bind(this);
        this.SetCounter = this.SetCounter.bind(this);
        this.BlockSenders = this.BlockSenders.bind(this);
    }
    CreateNotifications(request, metadata) {
        return this.rpc.unary(MsgCreateNotificationsDesc, MsgCreateNotifications.fromPartial(request), metadata);
    }
    UpdateNotifications(request, metadata) {
        return this.rpc.unary(MsgUpdateNotificationsDesc, MsgUpdateNotifications.fromPartial(request), metadata);
    }
    DeleteNotifications(request, metadata) {
        return this.rpc.unary(MsgDeleteNotificationsDesc, MsgDeleteNotifications.fromPartial(request), metadata);
    }
    SetCounter(request, metadata) {
        return this.rpc.unary(MsgSetCounterDesc, MsgSetCounter.fromPartial(request), metadata);
    }
    BlockSenders(request, metadata) {
        return this.rpc.unary(MsgBlockSendersDesc, MsgBlockSenders.fromPartial(request), metadata);
    }
};
const MsgDesc$8 = { serviceName: "canine_chain.notifications.Msg" };
const MsgCreateNotificationsDesc = {
    methodName: "CreateNotifications",
    service: MsgDesc$8,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgCreateNotifications.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgCreateNotificationsResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgUpdateNotificationsDesc = {
    methodName: "UpdateNotifications",
    service: MsgDesc$8,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgUpdateNotifications.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgUpdateNotificationsResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgDeleteNotificationsDesc = {
    methodName: "DeleteNotifications",
    service: MsgDesc$8,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgDeleteNotifications.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgDeleteNotificationsResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgSetCounterDesc = {
    methodName: "SetCounter",
    service: MsgDesc$8,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgSetCounter.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgSetCounterResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgBlockSendersDesc = {
    methodName: "BlockSenders",
    service: MsgDesc$8,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgBlockSenders.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgBlockSendersResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
let GrpcWebImpl$8 = class GrpcWebImpl {
    host;
    options;
    constructor(host, options) {
        this.host = host;
        this.options = options;
    }
    unary(methodDesc, _request, metadata) {
        const request = { ..._request, ...methodDesc.requestType };
        const maybeCombinedMetadata = metadata && this.options.metadata
            ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
            : metadata ?? this.options.metadata;
        return new Promise((resolve, reject) => {
            grpc.unary(methodDesc, {
                request,
                host: this.host,
                metadata: maybeCombinedMetadata ?? {},
                ...(this.options.transport !== undefined ? { transport: this.options.transport } : {}),
                debug: this.options.debug ?? false,
                onEnd: function (response) {
                    if (response.status === grpc.Code.OK) {
                        resolve(response.message.toObject());
                    }
                    else {
                        const err = new GrpcWebError$8(response.statusMessage, response.status, response.trailers);
                        reject(err);
                    }
                },
            });
        });
    }
};
const tsProtoGlobalThis$8 = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function longToNumber$1(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new tsProtoGlobalThis$8.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isSet$8(value) {
    return value !== null && value !== undefined;
}
let GrpcWebError$8 = class GrpcWebError extends tsProtoGlobalThis$8.Error {
    code;
    metadata;
    constructor(message, code, metadata) {
        super(message);
        this.code = code;
        this.metadata = metadata;
    }
};

const notificationsTypes = {
    createNotifications: [
        '/canine_chain.notifications.MsgCreateNotifications',
        MsgCreateNotifications
    ],
    updateNotifications: [
        '/canine_chain.notifications.MsgUpdateNotifications',
        MsgUpdateNotifications
    ],
    deleteNotifications: [
        '/canine_chain.notifications.MsgDeleteNotifications',
        MsgDeleteNotifications
    ],
    setCounter: ['/canine_chain.notifications.MsgSetCounter', MsgSetCounter],
    blockSenders: ['/canine_chain.notifications.MsgBlockSenders', MsgBlockSenders]
};
class TxNotifications {
    msgCreateNotifications(data) {
        return {
            typeUrl: notificationsTypes.createNotifications[0],
            value: notificationsTypes.createNotifications[1].fromPartial(data)
        };
    }
    msgUpdateNotifications(data) {
        return {
            typeUrl: notificationsTypes.updateNotifications[0],
            value: notificationsTypes.updateNotifications[1].fromPartial(data)
        };
    }
    msgDeleteNotifications(data) {
        return {
            typeUrl: notificationsTypes.deleteNotifications[0],
            value: notificationsTypes.deleteNotifications[1].fromPartial(data)
        };
    }
    msgSetCounter(data) {
        return {
            typeUrl: notificationsTypes.setCounter[0],
            value: notificationsTypes.setCounter[1].fromPartial(data)
        };
    }
    msgBlockSenders(data) {
        return {
            typeUrl: notificationsTypes.blockSenders[0],
            value: notificationsTypes.blockSenders[1].fromPartial(data)
        };
    }
}

/* eslint-disable */
const protobufPackage$7 = "canine_chain.oracle";
function createBaseMsgCreateFeed() {
    return { creator: "", name: "" };
}
const MsgCreateFeed = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateFeed();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet$7(object.creator) ? String(object.creator) : "",
            name: isSet$7(object.name) ? String(object.name) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        return obj;
    },
    create(base) {
        return MsgCreateFeed.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgCreateFeed();
        message.creator = object.creator ?? "";
        message.name = object.name ?? "";
        return message;
    },
};
function createBaseMsgCreateFeedResponse() {
    return {};
}
const MsgCreateFeedResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateFeedResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgCreateFeedResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgCreateFeedResponse();
        return message;
    },
};
function createBaseMsgUpdateFeed() {
    return { creator: "", name: "", data: "" };
}
const MsgUpdateFeed = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        if (message.data !== "") {
            writer.uint32(26).string(message.data);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateFeed();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.data = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet$7(object.creator) ? String(object.creator) : "",
            name: isSet$7(object.name) ? String(object.name) : "",
            data: isSet$7(object.data) ? String(object.data) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.data !== "") {
            obj.data = message.data;
        }
        return obj;
    },
    create(base) {
        return MsgUpdateFeed.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgUpdateFeed();
        message.creator = object.creator ?? "";
        message.name = object.name ?? "";
        message.data = object.data ?? "";
        return message;
    },
};
function createBaseMsgUpdateFeedResponse() {
    return {};
}
const MsgUpdateFeedResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateFeedResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgUpdateFeedResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgUpdateFeedResponse();
        return message;
    },
};
let MsgClientImpl$7 = class MsgClientImpl {
    rpc;
    constructor(rpc) {
        this.rpc = rpc;
        this.CreateFeed = this.CreateFeed.bind(this);
        this.UpdateFeed = this.UpdateFeed.bind(this);
    }
    CreateFeed(request, metadata) {
        return this.rpc.unary(MsgCreateFeedDesc, MsgCreateFeed.fromPartial(request), metadata);
    }
    UpdateFeed(request, metadata) {
        return this.rpc.unary(MsgUpdateFeedDesc, MsgUpdateFeed.fromPartial(request), metadata);
    }
};
const MsgDesc$7 = { serviceName: "canine_chain.oracle.Msg" };
const MsgCreateFeedDesc = {
    methodName: "CreateFeed",
    service: MsgDesc$7,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgCreateFeed.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgCreateFeedResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgUpdateFeedDesc = {
    methodName: "UpdateFeed",
    service: MsgDesc$7,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgUpdateFeed.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgUpdateFeedResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
let GrpcWebImpl$7 = class GrpcWebImpl {
    host;
    options;
    constructor(host, options) {
        this.host = host;
        this.options = options;
    }
    unary(methodDesc, _request, metadata) {
        const request = { ..._request, ...methodDesc.requestType };
        const maybeCombinedMetadata = metadata && this.options.metadata
            ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
            : metadata ?? this.options.metadata;
        return new Promise((resolve, reject) => {
            grpc.unary(methodDesc, {
                request,
                host: this.host,
                metadata: maybeCombinedMetadata ?? {},
                ...(this.options.transport !== undefined ? { transport: this.options.transport } : {}),
                debug: this.options.debug ?? false,
                onEnd: function (response) {
                    if (response.status === grpc.Code.OK) {
                        resolve(response.message.toObject());
                    }
                    else {
                        const err = new GrpcWebError$7(response.statusMessage, response.status, response.trailers);
                        reject(err);
                    }
                },
            });
        });
    }
};
const tsProtoGlobalThis$7 = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function isSet$7(value) {
    return value !== null && value !== undefined;
}
let GrpcWebError$7 = class GrpcWebError extends tsProtoGlobalThis$7.Error {
    code;
    metadata;
    constructor(message, code, metadata) {
        super(message);
        this.code = code;
        this.metadata = metadata;
    }
};

const oracleTypes = {
    createFeed: ['/canine_chain.oracle.MsgCreateFeed', MsgCreateFeed],
    updateFeed: ['/canine_chain.oracle.MsgUpdateFeed', MsgUpdateFeed]
};
class TxOracle {
    msgCreateFeed(data) {
        return {
            typeUrl: oracleTypes.createFeed[0],
            value: oracleTypes.createFeed[1].fromPartial(data)
        };
    }
    msgUpdateFeed(data) {
        return {
            typeUrl: oracleTypes.updateFeed[0],
            value: oracleTypes.updateFeed[1].fromPartial(data)
        };
    }
}

/* eslint-disable */
const protobufPackage$6 = "canine_chain.rns";
function createBaseMsgRegister() {
    return { creator: "", name: "", years: "", data: "" };
}
const MsgRegister = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        if (message.years !== "") {
            writer.uint32(26).string(message.years);
        }
        if (message.data !== "") {
            writer.uint32(34).string(message.data);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRegister();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.years = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.data = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet$6(object.creator) ? String(object.creator) : "",
            name: isSet$6(object.name) ? String(object.name) : "",
            years: isSet$6(object.years) ? String(object.years) : "",
            data: isSet$6(object.data) ? String(object.data) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.years !== "") {
            obj.years = message.years;
        }
        if (message.data !== "") {
            obj.data = message.data;
        }
        return obj;
    },
    create(base) {
        return MsgRegister.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgRegister();
        message.creator = object.creator ?? "";
        message.name = object.name ?? "";
        message.years = object.years ?? "";
        message.data = object.data ?? "";
        return message;
    },
};
function createBaseMsgRegisterResponse() {
    return {};
}
const MsgRegisterResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRegisterResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgRegisterResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgRegisterResponse();
        return message;
    },
};
function createBaseMsgUpdate() {
    return { creator: "", name: "", data: "" };
}
const MsgUpdate = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        if (message.data !== "") {
            writer.uint32(26).string(message.data);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdate();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.data = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet$6(object.creator) ? String(object.creator) : "",
            name: isSet$6(object.name) ? String(object.name) : "",
            data: isSet$6(object.data) ? String(object.data) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.data !== "") {
            obj.data = message.data;
        }
        return obj;
    },
    create(base) {
        return MsgUpdate.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgUpdate();
        message.creator = object.creator ?? "";
        message.name = object.name ?? "";
        message.data = object.data ?? "";
        return message;
    },
};
function createBaseMsgUpdateResponse() {
    return {};
}
const MsgUpdateResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpdateResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgUpdateResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgUpdateResponse();
        return message;
    },
};
function createBaseMsgBid() {
    return { creator: "", name: "", bid: "" };
}
const MsgBid = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        if (message.bid !== "") {
            writer.uint32(26).string(message.bid);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgBid();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.bid = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet$6(object.creator) ? String(object.creator) : "",
            name: isSet$6(object.name) ? String(object.name) : "",
            bid: isSet$6(object.bid) ? String(object.bid) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.bid !== "") {
            obj.bid = message.bid;
        }
        return obj;
    },
    create(base) {
        return MsgBid.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgBid();
        message.creator = object.creator ?? "";
        message.name = object.name ?? "";
        message.bid = object.bid ?? "";
        return message;
    },
};
function createBaseMsgBidResponse() {
    return {};
}
const MsgBidResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgBidResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgBidResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgBidResponse();
        return message;
    },
};
function createBaseMsgAcceptBid() {
    return { creator: "", name: "", from: "" };
}
const MsgAcceptBid = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        if (message.from !== "") {
            writer.uint32(26).string(message.from);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgAcceptBid();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.from = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet$6(object.creator) ? String(object.creator) : "",
            name: isSet$6(object.name) ? String(object.name) : "",
            from: isSet$6(object.from) ? String(object.from) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.from !== "") {
            obj.from = message.from;
        }
        return obj;
    },
    create(base) {
        return MsgAcceptBid.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgAcceptBid();
        message.creator = object.creator ?? "";
        message.name = object.name ?? "";
        message.from = object.from ?? "";
        return message;
    },
};
function createBaseMsgAcceptBidResponse() {
    return {};
}
const MsgAcceptBidResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgAcceptBidResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgAcceptBidResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgAcceptBidResponse();
        return message;
    },
};
function createBaseMsgCancelBid() {
    return { creator: "", name: "" };
}
const MsgCancelBid = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCancelBid();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet$6(object.creator) ? String(object.creator) : "",
            name: isSet$6(object.name) ? String(object.name) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        return obj;
    },
    create(base) {
        return MsgCancelBid.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgCancelBid();
        message.creator = object.creator ?? "";
        message.name = object.name ?? "";
        return message;
    },
};
function createBaseMsgCancelBidResponse() {
    return {};
}
const MsgCancelBidResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCancelBidResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgCancelBidResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgCancelBidResponse();
        return message;
    },
};
function createBaseMsgList() {
    return { creator: "", name: "", price: "" };
}
const MsgList = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        if (message.price !== "") {
            writer.uint32(26).string(message.price);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgList();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.price = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet$6(object.creator) ? String(object.creator) : "",
            name: isSet$6(object.name) ? String(object.name) : "",
            price: isSet$6(object.price) ? String(object.price) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.price !== "") {
            obj.price = message.price;
        }
        return obj;
    },
    create(base) {
        return MsgList.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgList();
        message.creator = object.creator ?? "";
        message.name = object.name ?? "";
        message.price = object.price ?? "";
        return message;
    },
};
function createBaseMsgListResponse() {
    return {};
}
const MsgListResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgListResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgListResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgListResponse();
        return message;
    },
};
function createBaseMsgBuy() {
    return { creator: "", name: "" };
}
const MsgBuy = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgBuy();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet$6(object.creator) ? String(object.creator) : "",
            name: isSet$6(object.name) ? String(object.name) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        return obj;
    },
    create(base) {
        return MsgBuy.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgBuy();
        message.creator = object.creator ?? "";
        message.name = object.name ?? "";
        return message;
    },
};
function createBaseMsgBuyResponse() {
    return {};
}
const MsgBuyResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgBuyResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgBuyResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgBuyResponse();
        return message;
    },
};
function createBaseMsgDelist() {
    return { creator: "", name: "" };
}
const MsgDelist = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgDelist();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet$6(object.creator) ? String(object.creator) : "",
            name: isSet$6(object.name) ? String(object.name) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        return obj;
    },
    create(base) {
        return MsgDelist.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgDelist();
        message.creator = object.creator ?? "";
        message.name = object.name ?? "";
        return message;
    },
};
function createBaseMsgDelistResponse() {
    return {};
}
const MsgDelistResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgDelistResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgDelistResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgDelistResponse();
        return message;
    },
};
function createBaseMsgTransfer() {
    return { creator: "", name: "", receiver: "" };
}
const MsgTransfer = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        if (message.receiver !== "") {
            writer.uint32(26).string(message.receiver);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgTransfer();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.receiver = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet$6(object.creator) ? String(object.creator) : "",
            name: isSet$6(object.name) ? String(object.name) : "",
            receiver: isSet$6(object.receiver) ? String(object.receiver) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.receiver !== "") {
            obj.receiver = message.receiver;
        }
        return obj;
    },
    create(base) {
        return MsgTransfer.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgTransfer();
        message.creator = object.creator ?? "";
        message.name = object.name ?? "";
        message.receiver = object.receiver ?? "";
        return message;
    },
};
function createBaseMsgTransferResponse() {
    return {};
}
const MsgTransferResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgTransferResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgTransferResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgTransferResponse();
        return message;
    },
};
function createBaseMsgAddRecord() {
    return { creator: "", name: "", value: "", data: "", record: "" };
}
const MsgAddRecord = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        if (message.value !== "") {
            writer.uint32(26).string(message.value);
        }
        if (message.data !== "") {
            writer.uint32(34).string(message.data);
        }
        if (message.record !== "") {
            writer.uint32(42).string(message.record);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgAddRecord();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.data = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.record = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet$6(object.creator) ? String(object.creator) : "",
            name: isSet$6(object.name) ? String(object.name) : "",
            value: isSet$6(object.value) ? String(object.value) : "",
            data: isSet$6(object.data) ? String(object.data) : "",
            record: isSet$6(object.record) ? String(object.record) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        if (message.data !== "") {
            obj.data = message.data;
        }
        if (message.record !== "") {
            obj.record = message.record;
        }
        return obj;
    },
    create(base) {
        return MsgAddRecord.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgAddRecord();
        message.creator = object.creator ?? "";
        message.name = object.name ?? "";
        message.value = object.value ?? "";
        message.data = object.data ?? "";
        message.record = object.record ?? "";
        return message;
    },
};
function createBaseMsgAddRecordResponse() {
    return {};
}
const MsgAddRecordResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgAddRecordResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgAddRecordResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgAddRecordResponse();
        return message;
    },
};
function createBaseMsgDelRecord() {
    return { creator: "", name: "" };
}
const MsgDelRecord = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.name !== "") {
            writer.uint32(18).string(message.name);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgDelRecord();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet$6(object.creator) ? String(object.creator) : "",
            name: isSet$6(object.name) ? String(object.name) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        return obj;
    },
    create(base) {
        return MsgDelRecord.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgDelRecord();
        message.creator = object.creator ?? "";
        message.name = object.name ?? "";
        return message;
    },
};
function createBaseMsgDelRecordResponse() {
    return {};
}
const MsgDelRecordResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgDelRecordResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgDelRecordResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgDelRecordResponse();
        return message;
    },
};
function createBaseMsgInit() {
    return { creator: "" };
}
const MsgInit = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgInit();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { creator: isSet$6(object.creator) ? String(object.creator) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        return obj;
    },
    create(base) {
        return MsgInit.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgInit();
        message.creator = object.creator ?? "";
        return message;
    },
};
function createBaseMsgInitResponse() {
    return {};
}
const MsgInitResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgInitResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgInitResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgInitResponse();
        return message;
    },
};
let MsgClientImpl$6 = class MsgClientImpl {
    rpc;
    constructor(rpc) {
        this.rpc = rpc;
        this.Register = this.Register.bind(this);
        this.Bid = this.Bid.bind(this);
        this.AcceptBid = this.AcceptBid.bind(this);
        this.CancelBid = this.CancelBid.bind(this);
        this.List = this.List.bind(this);
        this.Buy = this.Buy.bind(this);
        this.Delist = this.Delist.bind(this);
        this.Transfer = this.Transfer.bind(this);
        this.AddRecord = this.AddRecord.bind(this);
        this.DelRecord = this.DelRecord.bind(this);
        this.Init = this.Init.bind(this);
        this.Update = this.Update.bind(this);
    }
    Register(request, metadata) {
        return this.rpc.unary(MsgRegisterDesc, MsgRegister.fromPartial(request), metadata);
    }
    Bid(request, metadata) {
        return this.rpc.unary(MsgBidDesc, MsgBid.fromPartial(request), metadata);
    }
    AcceptBid(request, metadata) {
        return this.rpc.unary(MsgAcceptBidDesc, MsgAcceptBid.fromPartial(request), metadata);
    }
    CancelBid(request, metadata) {
        return this.rpc.unary(MsgCancelBidDesc, MsgCancelBid.fromPartial(request), metadata);
    }
    List(request, metadata) {
        return this.rpc.unary(MsgListDesc, MsgList.fromPartial(request), metadata);
    }
    Buy(request, metadata) {
        return this.rpc.unary(MsgBuyDesc, MsgBuy.fromPartial(request), metadata);
    }
    Delist(request, metadata) {
        return this.rpc.unary(MsgDelistDesc, MsgDelist.fromPartial(request), metadata);
    }
    Transfer(request, metadata) {
        return this.rpc.unary(MsgTransferDesc, MsgTransfer.fromPartial(request), metadata);
    }
    AddRecord(request, metadata) {
        return this.rpc.unary(MsgAddRecordDesc, MsgAddRecord.fromPartial(request), metadata);
    }
    DelRecord(request, metadata) {
        return this.rpc.unary(MsgDelRecordDesc, MsgDelRecord.fromPartial(request), metadata);
    }
    Init(request, metadata) {
        return this.rpc.unary(MsgInitDesc, MsgInit.fromPartial(request), metadata);
    }
    Update(request, metadata) {
        return this.rpc.unary(MsgUpdateDesc, MsgUpdate.fromPartial(request), metadata);
    }
};
const MsgDesc$6 = { serviceName: "canine_chain.rns.Msg" };
const MsgRegisterDesc = {
    methodName: "Register",
    service: MsgDesc$6,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgRegister.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgRegisterResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgBidDesc = {
    methodName: "Bid",
    service: MsgDesc$6,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgBid.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgBidResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgAcceptBidDesc = {
    methodName: "AcceptBid",
    service: MsgDesc$6,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgAcceptBid.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgAcceptBidResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgCancelBidDesc = {
    methodName: "CancelBid",
    service: MsgDesc$6,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgCancelBid.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgCancelBidResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgListDesc = {
    methodName: "List",
    service: MsgDesc$6,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgList.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgListResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgBuyDesc = {
    methodName: "Buy",
    service: MsgDesc$6,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgBuy.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgBuyResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgDelistDesc = {
    methodName: "Delist",
    service: MsgDesc$6,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgDelist.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgDelistResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgTransferDesc = {
    methodName: "Transfer",
    service: MsgDesc$6,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgTransfer.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgTransferResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgAddRecordDesc = {
    methodName: "AddRecord",
    service: MsgDesc$6,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgAddRecord.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgAddRecordResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgDelRecordDesc = {
    methodName: "DelRecord",
    service: MsgDesc$6,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgDelRecord.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgDelRecordResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgInitDesc = {
    methodName: "Init",
    service: MsgDesc$6,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgInit.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgInitResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgUpdateDesc = {
    methodName: "Update",
    service: MsgDesc$6,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgUpdate.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgUpdateResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
let GrpcWebImpl$6 = class GrpcWebImpl {
    host;
    options;
    constructor(host, options) {
        this.host = host;
        this.options = options;
    }
    unary(methodDesc, _request, metadata) {
        const request = { ..._request, ...methodDesc.requestType };
        const maybeCombinedMetadata = metadata && this.options.metadata
            ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
            : metadata ?? this.options.metadata;
        return new Promise((resolve, reject) => {
            grpc.unary(methodDesc, {
                request,
                host: this.host,
                metadata: maybeCombinedMetadata ?? {},
                ...(this.options.transport !== undefined ? { transport: this.options.transport } : {}),
                debug: this.options.debug ?? false,
                onEnd: function (response) {
                    if (response.status === grpc.Code.OK) {
                        resolve(response.message.toObject());
                    }
                    else {
                        const err = new GrpcWebError$6(response.statusMessage, response.status, response.trailers);
                        reject(err);
                    }
                },
            });
        });
    }
};
const tsProtoGlobalThis$6 = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function isSet$6(value) {
    return value !== null && value !== undefined;
}
let GrpcWebError$6 = class GrpcWebError extends tsProtoGlobalThis$6.Error {
    code;
    metadata;
    constructor(message, code, metadata) {
        super(message);
        this.code = code;
        this.metadata = metadata;
    }
};

const rnsTypes = {
    acceptBid: ['/canine_chain.rns.MsgAcceptBid', MsgAcceptBid],
    addRecord: ['/canine_chain.rns.MsgAddRecord', MsgAddRecord],
    bid: ['/canine_chain.rns.MsgBid', MsgBid],
    buy: ['/canine_chain.rns.MsgBuy', MsgBuy],
    cancelBid: ['/canine_chain.rns.MsgCancelBid', MsgCancelBid],
    delist: ['/canine_chain.rns.MsgDelist', MsgDelist],
    delRecord: ['/canine_chain.rns.MsgDelRecord', MsgDelRecord],
    init: ['/canine_chain.rns.MsgInit', MsgInit],
    list: ['/canine_chain.rns.MsgList', MsgList],
    register: ['/canine_chain.rns.MsgRegister', MsgRegister],
    transfer: ['/canine_chain.rns.MsgTransfer', MsgTransfer],
    update: ['/canine_chain.rns.MsgUpdate', MsgUpdate]
};
class TxRns {
    msgAcceptBid(data) {
        return {
            typeUrl: rnsTypes.acceptBid[0],
            value: rnsTypes.acceptBid[1].fromPartial(data)
        };
    }
    msgAddRecord(data) {
        return {
            typeUrl: rnsTypes.addRecord[0],
            value: rnsTypes.addRecord[1].fromPartial(data)
        };
    }
    msgBid(data) {
        return {
            typeUrl: rnsTypes.bid[0],
            value: rnsTypes.bid[1].fromPartial(data)
        };
    }
    msgBuy(data) {
        return {
            typeUrl: rnsTypes.buy[0],
            value: rnsTypes.buy[1].fromPartial(data)
        };
    }
    msgCancelBid(data) {
        return {
            typeUrl: rnsTypes.cancelBid[0],
            value: rnsTypes.cancelBid[1].fromPartial(data)
        };
    }
    msgDelist(data) {
        return {
            typeUrl: rnsTypes.delist[0],
            value: rnsTypes.delist[1].fromPartial(data)
        };
    }
    msgDelRecord(data) {
        return {
            typeUrl: rnsTypes.delRecord[0],
            value: rnsTypes.delRecord[1].fromPartial(data)
        };
    }
    msgInit(data) {
        return {
            typeUrl: rnsTypes.init[0],
            value: rnsTypes.init[1].fromPartial(data)
        };
    }
    msgList(data) {
        return {
            typeUrl: rnsTypes.list[0],
            value: rnsTypes.list[1].fromPartial(data)
        };
    }
    msgRegister(data) {
        return {
            typeUrl: rnsTypes.register[0],
            value: rnsTypes.register[1].fromPartial(data)
        };
    }
    msgTransfer(data) {
        return {
            typeUrl: rnsTypes.transfer[0],
            value: rnsTypes.transfer[1].fromPartial(data)
        };
    }
    msgUpdate(data) {
        return {
            typeUrl: rnsTypes.update[0],
            value: rnsTypes.update[1].fromPartial(data)
        };
    }
}

/* eslint-disable */
const protobufPackage$5 = "canine_chain.storage";
function createBaseMsgPostContract() {
    return { creator: "", merkle: "", signee: "", filesize: "", fid: "" };
}
const MsgPostContract = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.merkle !== "") {
            writer.uint32(18).string(message.merkle);
        }
        if (message.signee !== "") {
            writer.uint32(26).string(message.signee);
        }
        if (message.filesize !== "") {
            writer.uint32(34).string(message.filesize);
        }
        if (message.fid !== "") {
            writer.uint32(42).string(message.fid);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgPostContract();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.merkle = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.signee = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.filesize = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.fid = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet$5(object.creator) ? String(object.creator) : "",
            merkle: isSet$5(object.merkle) ? String(object.merkle) : "",
            signee: isSet$5(object.signee) ? String(object.signee) : "",
            filesize: isSet$5(object.filesize) ? String(object.filesize) : "",
            fid: isSet$5(object.fid) ? String(object.fid) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.merkle !== "") {
            obj.merkle = message.merkle;
        }
        if (message.signee !== "") {
            obj.signee = message.signee;
        }
        if (message.filesize !== "") {
            obj.filesize = message.filesize;
        }
        if (message.fid !== "") {
            obj.fid = message.fid;
        }
        return obj;
    },
    create(base) {
        return MsgPostContract.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgPostContract();
        message.creator = object.creator ?? "";
        message.merkle = object.merkle ?? "";
        message.signee = object.signee ?? "";
        message.filesize = object.filesize ?? "";
        message.fid = object.fid ?? "";
        return message;
    },
};
function createBaseMsgPostContractResponse() {
    return {};
}
const MsgPostContractResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgPostContractResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgPostContractResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgPostContractResponse();
        return message;
    },
};
function createBaseMsgPostproof() {
    return { creator: "", item: "", hashlist: "", cid: "" };
}
const MsgPostproof = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.item !== "") {
            writer.uint32(18).string(message.item);
        }
        if (message.hashlist !== "") {
            writer.uint32(26).string(message.hashlist);
        }
        if (message.cid !== "") {
            writer.uint32(34).string(message.cid);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgPostproof();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.item = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.hashlist = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.cid = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet$5(object.creator) ? String(object.creator) : "",
            item: isSet$5(object.item) ? String(object.item) : "",
            hashlist: isSet$5(object.hashlist) ? String(object.hashlist) : "",
            cid: isSet$5(object.cid) ? String(object.cid) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.item !== "") {
            obj.item = message.item;
        }
        if (message.hashlist !== "") {
            obj.hashlist = message.hashlist;
        }
        if (message.cid !== "") {
            obj.cid = message.cid;
        }
        return obj;
    },
    create(base) {
        return MsgPostproof.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgPostproof();
        message.creator = object.creator ?? "";
        message.item = object.item ?? "";
        message.hashlist = object.hashlist ?? "";
        message.cid = object.cid ?? "";
        return message;
    },
};
function createBaseMsgPostproofResponse() {
    return { success: false, errorMessage: "" };
}
const MsgPostproofResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.success === true) {
            writer.uint32(8).bool(message.success);
        }
        if (message.errorMessage !== "") {
            writer.uint32(18).string(message.errorMessage);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgPostproofResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.success = reader.bool();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.errorMessage = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            success: isSet$5(object.success) ? Boolean(object.success) : false,
            errorMessage: isSet$5(object.errorMessage) ? String(object.errorMessage) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.success === true) {
            obj.success = message.success;
        }
        if (message.errorMessage !== "") {
            obj.errorMessage = message.errorMessage;
        }
        return obj;
    },
    create(base) {
        return MsgPostproofResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgPostproofResponse();
        message.success = object.success ?? false;
        message.errorMessage = object.errorMessage ?? "";
        return message;
    },
};
function createBaseMsgSignContract() {
    return { creator: "", cid: "", payOnce: false };
}
const MsgSignContract = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.cid !== "") {
            writer.uint32(18).string(message.cid);
        }
        if (message.payOnce === true) {
            writer.uint32(24).bool(message.payOnce);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSignContract();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.cid = reader.string();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.payOnce = reader.bool();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet$5(object.creator) ? String(object.creator) : "",
            cid: isSet$5(object.cid) ? String(object.cid) : "",
            payOnce: isSet$5(object.payOnce) ? Boolean(object.payOnce) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.cid !== "") {
            obj.cid = message.cid;
        }
        if (message.payOnce === true) {
            obj.payOnce = message.payOnce;
        }
        return obj;
    },
    create(base) {
        return MsgSignContract.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgSignContract();
        message.creator = object.creator ?? "";
        message.cid = object.cid ?? "";
        message.payOnce = object.payOnce ?? false;
        return message;
    },
};
function createBaseMsgSignContractResponse() {
    return {};
}
const MsgSignContractResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSignContractResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgSignContractResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgSignContractResponse();
        return message;
    },
};
function createBaseMsgSetProviderIP() {
    return { creator: "", ip: "" };
}
const MsgSetProviderIP = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.ip !== "") {
            writer.uint32(18).string(message.ip);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSetProviderIP();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.ip = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet$5(object.creator) ? String(object.creator) : "",
            ip: isSet$5(object.ip) ? String(object.ip) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.ip !== "") {
            obj.ip = message.ip;
        }
        return obj;
    },
    create(base) {
        return MsgSetProviderIP.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgSetProviderIP();
        message.creator = object.creator ?? "";
        message.ip = object.ip ?? "";
        return message;
    },
};
function createBaseMsgSetProviderIPResponse() {
    return {};
}
const MsgSetProviderIPResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSetProviderIPResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgSetProviderIPResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgSetProviderIPResponse();
        return message;
    },
};
function createBaseMsgSetProviderKeybase() {
    return { creator: "", keybase: "" };
}
const MsgSetProviderKeybase = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.keybase !== "") {
            writer.uint32(18).string(message.keybase);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSetProviderKeybase();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.keybase = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet$5(object.creator) ? String(object.creator) : "",
            keybase: isSet$5(object.keybase) ? String(object.keybase) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.keybase !== "") {
            obj.keybase = message.keybase;
        }
        return obj;
    },
    create(base) {
        return MsgSetProviderKeybase.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgSetProviderKeybase();
        message.creator = object.creator ?? "";
        message.keybase = object.keybase ?? "";
        return message;
    },
};
function createBaseMsgSetProviderKeybaseResponse() {
    return {};
}
const MsgSetProviderKeybaseResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSetProviderKeybaseResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgSetProviderKeybaseResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgSetProviderKeybaseResponse();
        return message;
    },
};
function createBaseMsgSetProviderTotalspace() {
    return { creator: "", space: "" };
}
const MsgSetProviderTotalspace = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.space !== "") {
            writer.uint32(18).string(message.space);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSetProviderTotalspace();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.space = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet$5(object.creator) ? String(object.creator) : "",
            space: isSet$5(object.space) ? String(object.space) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.space !== "") {
            obj.space = message.space;
        }
        return obj;
    },
    create(base) {
        return MsgSetProviderTotalspace.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgSetProviderTotalspace();
        message.creator = object.creator ?? "";
        message.space = object.space ?? "";
        return message;
    },
};
function createBaseMsgSetProviderTotalspaceResponse() {
    return {};
}
const MsgSetProviderTotalspaceResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSetProviderTotalspaceResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgSetProviderTotalspaceResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgSetProviderTotalspaceResponse();
        return message;
    },
};
function createBaseMsgAddClaimer() {
    return { creator: "", claimAddress: "" };
}
const MsgAddClaimer = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.claimAddress !== "") {
            writer.uint32(18).string(message.claimAddress);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgAddClaimer();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.claimAddress = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet$5(object.creator) ? String(object.creator) : "",
            claimAddress: isSet$5(object.claimAddress) ? String(object.claimAddress) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.claimAddress !== "") {
            obj.claimAddress = message.claimAddress;
        }
        return obj;
    },
    create(base) {
        return MsgAddClaimer.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgAddClaimer();
        message.creator = object.creator ?? "";
        message.claimAddress = object.claimAddress ?? "";
        return message;
    },
};
function createBaseMsgAddClaimerResponse() {
    return {};
}
const MsgAddClaimerResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgAddClaimerResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgAddClaimerResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgAddClaimerResponse();
        return message;
    },
};
function createBaseMsgRemoveClaimer() {
    return { creator: "", claimAddress: "" };
}
const MsgRemoveClaimer = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.claimAddress !== "") {
            writer.uint32(18).string(message.claimAddress);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRemoveClaimer();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.claimAddress = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet$5(object.creator) ? String(object.creator) : "",
            claimAddress: isSet$5(object.claimAddress) ? String(object.claimAddress) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.claimAddress !== "") {
            obj.claimAddress = message.claimAddress;
        }
        return obj;
    },
    create(base) {
        return MsgRemoveClaimer.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgRemoveClaimer();
        message.creator = object.creator ?? "";
        message.claimAddress = object.claimAddress ?? "";
        return message;
    },
};
function createBaseMsgRemoveClaimerResponse() {
    return {};
}
const MsgRemoveClaimerResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgRemoveClaimerResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgRemoveClaimerResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgRemoveClaimerResponse();
        return message;
    },
};
function createBaseMsgInitProvider() {
    return { creator: "", ip: "", keybase: "", totalspace: "" };
}
const MsgInitProvider = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.ip !== "") {
            writer.uint32(18).string(message.ip);
        }
        if (message.keybase !== "") {
            writer.uint32(26).string(message.keybase);
        }
        if (message.totalspace !== "") {
            writer.uint32(34).string(message.totalspace);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgInitProvider();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.ip = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.keybase = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.totalspace = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet$5(object.creator) ? String(object.creator) : "",
            ip: isSet$5(object.ip) ? String(object.ip) : "",
            keybase: isSet$5(object.keybase) ? String(object.keybase) : "",
            totalspace: isSet$5(object.totalspace) ? String(object.totalspace) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.ip !== "") {
            obj.ip = message.ip;
        }
        if (message.keybase !== "") {
            obj.keybase = message.keybase;
        }
        if (message.totalspace !== "") {
            obj.totalspace = message.totalspace;
        }
        return obj;
    },
    create(base) {
        return MsgInitProvider.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgInitProvider();
        message.creator = object.creator ?? "";
        message.ip = object.ip ?? "";
        message.keybase = object.keybase ?? "";
        message.totalspace = object.totalspace ?? "";
        return message;
    },
};
function createBaseMsgInitProviderResponse() {
    return {};
}
const MsgInitProviderResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgInitProviderResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgInitProviderResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgInitProviderResponse();
        return message;
    },
};
function createBaseMsgCancelContract() {
    return { creator: "", cid: "" };
}
const MsgCancelContract = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.cid !== "") {
            writer.uint32(18).string(message.cid);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCancelContract();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.cid = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet$5(object.creator) ? String(object.creator) : "",
            cid: isSet$5(object.cid) ? String(object.cid) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.cid !== "") {
            obj.cid = message.cid;
        }
        return obj;
    },
    create(base) {
        return MsgCancelContract.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgCancelContract();
        message.creator = object.creator ?? "";
        message.cid = object.cid ?? "";
        return message;
    },
};
function createBaseMsgCancelContractResponse() {
    return {};
}
const MsgCancelContractResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCancelContractResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgCancelContractResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgCancelContractResponse();
        return message;
    },
};
function createBaseMsgBuyStorage() {
    return { creator: "", forAddress: "", duration: "", bytes: "", paymentDenom: "" };
}
const MsgBuyStorage = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.forAddress !== "") {
            writer.uint32(18).string(message.forAddress);
        }
        if (message.duration !== "") {
            writer.uint32(26).string(message.duration);
        }
        if (message.bytes !== "") {
            writer.uint32(34).string(message.bytes);
        }
        if (message.paymentDenom !== "") {
            writer.uint32(42).string(message.paymentDenom);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgBuyStorage();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.forAddress = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.duration = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.bytes = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.paymentDenom = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet$5(object.creator) ? String(object.creator) : "",
            forAddress: isSet$5(object.forAddress) ? String(object.forAddress) : "",
            duration: isSet$5(object.duration) ? String(object.duration) : "",
            bytes: isSet$5(object.bytes) ? String(object.bytes) : "",
            paymentDenom: isSet$5(object.paymentDenom) ? String(object.paymentDenom) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.forAddress !== "") {
            obj.forAddress = message.forAddress;
        }
        if (message.duration !== "") {
            obj.duration = message.duration;
        }
        if (message.bytes !== "") {
            obj.bytes = message.bytes;
        }
        if (message.paymentDenom !== "") {
            obj.paymentDenom = message.paymentDenom;
        }
        return obj;
    },
    create(base) {
        return MsgBuyStorage.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgBuyStorage();
        message.creator = object.creator ?? "";
        message.forAddress = object.forAddress ?? "";
        message.duration = object.duration ?? "";
        message.bytes = object.bytes ?? "";
        message.paymentDenom = object.paymentDenom ?? "";
        return message;
    },
};
function createBaseMsgBuyStorageResponse() {
    return {};
}
const MsgBuyStorageResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgBuyStorageResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgBuyStorageResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgBuyStorageResponse();
        return message;
    },
};
function createBaseMsgClaimStray() {
    return { creator: "", cid: "", forAddress: "" };
}
const MsgClaimStray = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.cid !== "") {
            writer.uint32(18).string(message.cid);
        }
        if (message.forAddress !== "") {
            writer.uint32(26).string(message.forAddress);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgClaimStray();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.cid = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.forAddress = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet$5(object.creator) ? String(object.creator) : "",
            cid: isSet$5(object.cid) ? String(object.cid) : "",
            forAddress: isSet$5(object.forAddress) ? String(object.forAddress) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.cid !== "") {
            obj.cid = message.cid;
        }
        if (message.forAddress !== "") {
            obj.forAddress = message.forAddress;
        }
        return obj;
    },
    create(base) {
        return MsgClaimStray.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgClaimStray();
        message.creator = object.creator ?? "";
        message.cid = object.cid ?? "";
        message.forAddress = object.forAddress ?? "";
        return message;
    },
};
function createBaseMsgClaimStrayResponse() {
    return {};
}
const MsgClaimStrayResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgClaimStrayResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgClaimStrayResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgClaimStrayResponse();
        return message;
    },
};
function createBaseMsgUpgradeStorage() {
    return { creator: "", forAddress: "", duration: "", bytes: "", paymentDenom: "" };
}
const MsgUpgradeStorage = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.creator !== "") {
            writer.uint32(10).string(message.creator);
        }
        if (message.forAddress !== "") {
            writer.uint32(18).string(message.forAddress);
        }
        if (message.duration !== "") {
            writer.uint32(26).string(message.duration);
        }
        if (message.bytes !== "") {
            writer.uint32(34).string(message.bytes);
        }
        if (message.paymentDenom !== "") {
            writer.uint32(42).string(message.paymentDenom);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpgradeStorage();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.creator = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.forAddress = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.duration = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.bytes = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.paymentDenom = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            creator: isSet$5(object.creator) ? String(object.creator) : "",
            forAddress: isSet$5(object.forAddress) ? String(object.forAddress) : "",
            duration: isSet$5(object.duration) ? String(object.duration) : "",
            bytes: isSet$5(object.bytes) ? String(object.bytes) : "",
            paymentDenom: isSet$5(object.paymentDenom) ? String(object.paymentDenom) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.creator !== "") {
            obj.creator = message.creator;
        }
        if (message.forAddress !== "") {
            obj.forAddress = message.forAddress;
        }
        if (message.duration !== "") {
            obj.duration = message.duration;
        }
        if (message.bytes !== "") {
            obj.bytes = message.bytes;
        }
        if (message.paymentDenom !== "") {
            obj.paymentDenom = message.paymentDenom;
        }
        return obj;
    },
    create(base) {
        return MsgUpgradeStorage.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgUpgradeStorage();
        message.creator = object.creator ?? "";
        message.forAddress = object.forAddress ?? "";
        message.duration = object.duration ?? "";
        message.bytes = object.bytes ?? "";
        message.paymentDenom = object.paymentDenom ?? "";
        return message;
    },
};
function createBaseMsgUpgradeStorageResponse() {
    return {};
}
const MsgUpgradeStorageResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUpgradeStorageResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgUpgradeStorageResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgUpgradeStorageResponse();
        return message;
    },
};
let MsgClientImpl$5 = class MsgClientImpl {
    rpc;
    constructor(rpc) {
        this.rpc = rpc;
        this.PostContract = this.PostContract.bind(this);
        this.Postproof = this.Postproof.bind(this);
        this.SignContract = this.SignContract.bind(this);
        this.SetProviderIP = this.SetProviderIP.bind(this);
        this.SetProviderKeybase = this.SetProviderKeybase.bind(this);
        this.SetProviderTotalspace = this.SetProviderTotalspace.bind(this);
        this.InitProvider = this.InitProvider.bind(this);
        this.CancelContract = this.CancelContract.bind(this);
        this.BuyStorage = this.BuyStorage.bind(this);
        this.ClaimStray = this.ClaimStray.bind(this);
        this.UpgradeStorage = this.UpgradeStorage.bind(this);
        this.AddProviderClaimer = this.AddProviderClaimer.bind(this);
        this.RemoveProviderClaimer = this.RemoveProviderClaimer.bind(this);
    }
    PostContract(request, metadata) {
        return this.rpc.unary(MsgPostContractDesc, MsgPostContract.fromPartial(request), metadata);
    }
    Postproof(request, metadata) {
        return this.rpc.unary(MsgPostproofDesc, MsgPostproof.fromPartial(request), metadata);
    }
    SignContract(request, metadata) {
        return this.rpc.unary(MsgSignContractDesc, MsgSignContract.fromPartial(request), metadata);
    }
    SetProviderIP(request, metadata) {
        return this.rpc.unary(MsgSetProviderIPDesc, MsgSetProviderIP.fromPartial(request), metadata);
    }
    SetProviderKeybase(request, metadata) {
        return this.rpc.unary(MsgSetProviderKeybaseDesc, MsgSetProviderKeybase.fromPartial(request), metadata);
    }
    SetProviderTotalspace(request, metadata) {
        return this.rpc.unary(MsgSetProviderTotalspaceDesc, MsgSetProviderTotalspace.fromPartial(request), metadata);
    }
    InitProvider(request, metadata) {
        return this.rpc.unary(MsgInitProviderDesc, MsgInitProvider.fromPartial(request), metadata);
    }
    CancelContract(request, metadata) {
        return this.rpc.unary(MsgCancelContractDesc, MsgCancelContract.fromPartial(request), metadata);
    }
    BuyStorage(request, metadata) {
        return this.rpc.unary(MsgBuyStorageDesc, MsgBuyStorage.fromPartial(request), metadata);
    }
    ClaimStray(request, metadata) {
        return this.rpc.unary(MsgClaimStrayDesc, MsgClaimStray.fromPartial(request), metadata);
    }
    UpgradeStorage(request, metadata) {
        return this.rpc.unary(MsgUpgradeStorageDesc, MsgUpgradeStorage.fromPartial(request), metadata);
    }
    AddProviderClaimer(request, metadata) {
        return this.rpc.unary(MsgAddProviderClaimerDesc, MsgAddClaimer.fromPartial(request), metadata);
    }
    RemoveProviderClaimer(request, metadata) {
        return this.rpc.unary(MsgRemoveProviderClaimerDesc, MsgRemoveClaimer.fromPartial(request), metadata);
    }
};
const MsgDesc$5 = { serviceName: "canine_chain.storage.Msg" };
const MsgPostContractDesc = {
    methodName: "PostContract",
    service: MsgDesc$5,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgPostContract.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgPostContractResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgPostproofDesc = {
    methodName: "Postproof",
    service: MsgDesc$5,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgPostproof.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgPostproofResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgSignContractDesc = {
    methodName: "SignContract",
    service: MsgDesc$5,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgSignContract.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgSignContractResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgSetProviderIPDesc = {
    methodName: "SetProviderIP",
    service: MsgDesc$5,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgSetProviderIP.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgSetProviderIPResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgSetProviderKeybaseDesc = {
    methodName: "SetProviderKeybase",
    service: MsgDesc$5,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgSetProviderKeybase.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgSetProviderKeybaseResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgSetProviderTotalspaceDesc = {
    methodName: "SetProviderTotalspace",
    service: MsgDesc$5,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgSetProviderTotalspace.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgSetProviderTotalspaceResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgInitProviderDesc = {
    methodName: "InitProvider",
    service: MsgDesc$5,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgInitProvider.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgInitProviderResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgCancelContractDesc = {
    methodName: "CancelContract",
    service: MsgDesc$5,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgCancelContract.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgCancelContractResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgBuyStorageDesc = {
    methodName: "BuyStorage",
    service: MsgDesc$5,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgBuyStorage.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgBuyStorageResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgClaimStrayDesc = {
    methodName: "ClaimStray",
    service: MsgDesc$5,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgClaimStray.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgClaimStrayResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgUpgradeStorageDesc = {
    methodName: "UpgradeStorage",
    service: MsgDesc$5,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgUpgradeStorage.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgUpgradeStorageResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgAddProviderClaimerDesc = {
    methodName: "AddProviderClaimer",
    service: MsgDesc$5,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgAddClaimer.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgAddClaimerResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgRemoveProviderClaimerDesc = {
    methodName: "RemoveProviderClaimer",
    service: MsgDesc$5,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgRemoveClaimer.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgRemoveClaimerResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
let GrpcWebImpl$5 = class GrpcWebImpl {
    host;
    options;
    constructor(host, options) {
        this.host = host;
        this.options = options;
    }
    unary(methodDesc, _request, metadata) {
        const request = { ..._request, ...methodDesc.requestType };
        const maybeCombinedMetadata = metadata && this.options.metadata
            ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
            : metadata ?? this.options.metadata;
        return new Promise((resolve, reject) => {
            grpc.unary(methodDesc, {
                request,
                host: this.host,
                metadata: maybeCombinedMetadata ?? {},
                ...(this.options.transport !== undefined ? { transport: this.options.transport } : {}),
                debug: this.options.debug ?? false,
                onEnd: function (response) {
                    if (response.status === grpc.Code.OK) {
                        resolve(response.message.toObject());
                    }
                    else {
                        const err = new GrpcWebError$5(response.statusMessage, response.status, response.trailers);
                        reject(err);
                    }
                },
            });
        });
    }
};
const tsProtoGlobalThis$5 = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function isSet$5(value) {
    return value !== null && value !== undefined;
}
let GrpcWebError$5 = class GrpcWebError extends tsProtoGlobalThis$5.Error {
    code;
    metadata;
    constructor(message, code, metadata) {
        super(message);
        this.code = code;
        this.metadata = metadata;
    }
};

const storageTypes = {
    postContract: ['/canine_chain.storage.MsgPostContract', MsgPostContract],
    postproof: ['/canine_chain.storage.MsgPostproof', MsgPostproof],
    signContract: ['/canine_chain.storage.MsgSignContract', MsgSignContract],
    setProviderIP: ['/canine_chain.storage.MsgSetProviderIP', MsgSetProviderIP],
    setProviderKeybase: [
        '/canine_chain.storage.MsgSetProviderKeybase',
        MsgSetProviderKeybase
    ],
    setProviderTotalspace: [
        '/canine_chain.storage.MsgSetProviderTotalspace',
        MsgSetProviderTotalspace
    ],
    initProvider: ['/canine_chain.storage.MsgInitProvider', MsgInitProvider],
    addClaimer: ['/canine_chain.storage.MsgAddClaimer', MsgAddClaimer],
    removeClaimer: ['/canine_chain.storage.MsgRemoveClaimer', MsgRemoveClaimer],
    cancelContract: [
        '/canine_chain.storage.MsgCancelContract',
        MsgCancelContract
    ],
    buyStorage: ['/canine_chain.storage.MsgBuyStorage', MsgBuyStorage],
    claimStray: ['/canine_chain.storage.MsgClaimStray', MsgClaimStray],
    upgradeStorage: ['/canine_chain.storage.MsgUpgradeStorage', MsgUpgradeStorage]
};
class TxStorage {
    msgPostContract(data) {
        return {
            typeUrl: storageTypes.postContract[0],
            value: storageTypes.postContract[1].fromPartial(data)
        };
    }
    msgPostproof(data) {
        return {
            typeUrl: storageTypes.postproof[0],
            value: storageTypes.postproof[1].fromPartial(data)
        };
    }
    msgSignContract(data) {
        return {
            typeUrl: storageTypes.signContract[0],
            value: storageTypes.signContract[1].fromPartial(data)
        };
    }
    msgSetProviderIP(data) {
        return {
            typeUrl: storageTypes.setProviderIP[0],
            value: storageTypes.setProviderIP[1].fromPartial(data)
        };
    }
    msgSetProviderKeybase(data) {
        return {
            typeUrl: storageTypes.setProviderKeybase[0],
            value: storageTypes.setProviderKeybase[1].fromPartial(data)
        };
    }
    msgSetProviderTotalspace(data) {
        return {
            typeUrl: storageTypes.setProviderTotalspace[0],
            value: storageTypes.setProviderTotalspace[1].fromPartial(data)
        };
    }
    msgInitProvider(data) {
        return {
            typeUrl: storageTypes.initProvider[0],
            value: storageTypes.initProvider[1].fromPartial(data)
        };
    }
    msgAddClaimer(data) {
        return {
            typeUrl: storageTypes.addClaimer[0],
            value: storageTypes.addClaimer[1].fromPartial(data)
        };
    }
    msgRemoveClaimer(data) {
        return {
            typeUrl: storageTypes.removeClaimer[0],
            value: storageTypes.removeClaimer[1].fromPartial(data)
        };
    }
    msgCancelContract(data) {
        return {
            typeUrl: storageTypes.cancelContract[0],
            value: storageTypes.cancelContract[1].fromPartial(data)
        };
    }
    msgBuyStorage(data) {
        return {
            typeUrl: storageTypes.buyStorage[0],
            value: storageTypes.buyStorage[1].fromPartial(data)
        };
    }
    msgClaimStray(data) {
        return {
            typeUrl: storageTypes.claimStray[0],
            value: storageTypes.claimStray[1].fromPartial(data)
        };
    }
    msgUpgradeStorage(data) {
        return {
            typeUrl: storageTypes.upgradeStorage[0],
            value: storageTypes.upgradeStorage[1].fromPartial(data)
        };
    }
}

/* eslint-disable */
const protobufPackage$4 = "cosmos.bank.v1beta1";
function createBaseMsgSend() {
    return { fromAddress: "", toAddress: "", amount: [] };
}
const MsgSend = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.fromAddress !== "") {
            writer.uint32(10).string(message.fromAddress);
        }
        if (message.toAddress !== "") {
            writer.uint32(18).string(message.toAddress);
        }
        for (const v of message.amount) {
            Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSend();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.fromAddress = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.toAddress = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.amount.push(Coin.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            fromAddress: isSet$4(object.fromAddress) ? String(object.fromAddress) : "",
            toAddress: isSet$4(object.toAddress) ? String(object.toAddress) : "",
            amount: Array.isArray(object?.amount) ? object.amount.map((e) => Coin.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.fromAddress !== "") {
            obj.fromAddress = message.fromAddress;
        }
        if (message.toAddress !== "") {
            obj.toAddress = message.toAddress;
        }
        if (message.amount?.length) {
            obj.amount = message.amount.map((e) => Coin.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return MsgSend.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgSend();
        message.fromAddress = object.fromAddress ?? "";
        message.toAddress = object.toAddress ?? "";
        message.amount = object.amount?.map((e) => Coin.fromPartial(e)) || [];
        return message;
    },
};
function createBaseMsgSendResponse() {
    return {};
}
const MsgSendResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSendResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgSendResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgSendResponse();
        return message;
    },
};
function createBaseMsgMultiSend() {
    return { inputs: [], outputs: [] };
}
const MsgMultiSend = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.inputs) {
            Input.encode(v, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.outputs) {
            Output.encode(v, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgMultiSend();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.inputs.push(Input.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.outputs.push(Output.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            inputs: Array.isArray(object?.inputs) ? object.inputs.map((e) => Input.fromJSON(e)) : [],
            outputs: Array.isArray(object?.outputs) ? object.outputs.map((e) => Output.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.inputs?.length) {
            obj.inputs = message.inputs.map((e) => Input.toJSON(e));
        }
        if (message.outputs?.length) {
            obj.outputs = message.outputs.map((e) => Output.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return MsgMultiSend.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgMultiSend();
        message.inputs = object.inputs?.map((e) => Input.fromPartial(e)) || [];
        message.outputs = object.outputs?.map((e) => Output.fromPartial(e)) || [];
        return message;
    },
};
function createBaseMsgMultiSendResponse() {
    return {};
}
const MsgMultiSendResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgMultiSendResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgMultiSendResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgMultiSendResponse();
        return message;
    },
};
let MsgClientImpl$4 = class MsgClientImpl {
    rpc;
    constructor(rpc) {
        this.rpc = rpc;
        this.Send = this.Send.bind(this);
        this.MultiSend = this.MultiSend.bind(this);
    }
    Send(request, metadata) {
        return this.rpc.unary(MsgSendDesc, MsgSend.fromPartial(request), metadata);
    }
    MultiSend(request, metadata) {
        return this.rpc.unary(MsgMultiSendDesc, MsgMultiSend.fromPartial(request), metadata);
    }
};
const MsgDesc$4 = { serviceName: "cosmos.bank.v1beta1.Msg" };
const MsgSendDesc = {
    methodName: "Send",
    service: MsgDesc$4,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgSend.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgSendResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgMultiSendDesc = {
    methodName: "MultiSend",
    service: MsgDesc$4,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgMultiSend.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgMultiSendResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
let GrpcWebImpl$4 = class GrpcWebImpl {
    host;
    options;
    constructor(host, options) {
        this.host = host;
        this.options = options;
    }
    unary(methodDesc, _request, metadata) {
        const request = { ..._request, ...methodDesc.requestType };
        const maybeCombinedMetadata = metadata && this.options.metadata
            ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
            : metadata ?? this.options.metadata;
        return new Promise((resolve, reject) => {
            grpc.unary(methodDesc, {
                request,
                host: this.host,
                metadata: maybeCombinedMetadata ?? {},
                ...(this.options.transport !== undefined ? { transport: this.options.transport } : {}),
                debug: this.options.debug ?? false,
                onEnd: function (response) {
                    if (response.status === grpc.Code.OK) {
                        resolve(response.message.toObject());
                    }
                    else {
                        const err = new GrpcWebError$4(response.statusMessage, response.status, response.trailers);
                        reject(err);
                    }
                },
            });
        });
    }
};
const tsProtoGlobalThis$4 = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function isSet$4(value) {
    return value !== null && value !== undefined;
}
let GrpcWebError$4 = class GrpcWebError extends tsProtoGlobalThis$4.Error {
    code;
    metadata;
    constructor(message, code, metadata) {
        super(message);
        this.code = code;
        this.metadata = metadata;
    }
};

const bankTypes = {
    multiSend: ['/cosmos.bank.v1beta1.MsgMultiSend', MsgMultiSend],
    send: ['/cosmos.bank.v1beta1.MsgSend', MsgSend]
};
class TxBank {
    msgMultiSend(data) {
        return {
            typeUrl: bankTypes.multiSend[0],
            value: bankTypes.multiSend[1].fromPartial(data)
        };
    }
    msgSend(data) {
        return {
            typeUrl: bankTypes.send[0],
            value: bankTypes.send[1].fromPartial(data)
        };
    }
}

/* eslint-disable */
const protobufPackage$3 = "cosmos.distribution.v1beta1";
function createBaseMsgSetWithdrawAddress() {
    return { delegatorAddress: "", withdrawAddress: "" };
}
const MsgSetWithdrawAddress = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.delegatorAddress !== "") {
            writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.withdrawAddress !== "") {
            writer.uint32(18).string(message.withdrawAddress);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSetWithdrawAddress();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.delegatorAddress = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.withdrawAddress = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            delegatorAddress: isSet$3(object.delegatorAddress) ? String(object.delegatorAddress) : "",
            withdrawAddress: isSet$3(object.withdrawAddress) ? String(object.withdrawAddress) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.delegatorAddress !== "") {
            obj.delegatorAddress = message.delegatorAddress;
        }
        if (message.withdrawAddress !== "") {
            obj.withdrawAddress = message.withdrawAddress;
        }
        return obj;
    },
    create(base) {
        return MsgSetWithdrawAddress.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgSetWithdrawAddress();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.withdrawAddress = object.withdrawAddress ?? "";
        return message;
    },
};
function createBaseMsgSetWithdrawAddressResponse() {
    return {};
}
const MsgSetWithdrawAddressResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSetWithdrawAddressResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgSetWithdrawAddressResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgSetWithdrawAddressResponse();
        return message;
    },
};
function createBaseMsgWithdrawDelegatorReward() {
    return { delegatorAddress: "", validatorAddress: "" };
}
const MsgWithdrawDelegatorReward = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.delegatorAddress !== "") {
            writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
            writer.uint32(18).string(message.validatorAddress);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawDelegatorReward();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.delegatorAddress = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.validatorAddress = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            delegatorAddress: isSet$3(object.delegatorAddress) ? String(object.delegatorAddress) : "",
            validatorAddress: isSet$3(object.validatorAddress) ? String(object.validatorAddress) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.delegatorAddress !== "") {
            obj.delegatorAddress = message.delegatorAddress;
        }
        if (message.validatorAddress !== "") {
            obj.validatorAddress = message.validatorAddress;
        }
        return obj;
    },
    create(base) {
        return MsgWithdrawDelegatorReward.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgWithdrawDelegatorReward();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        return message;
    },
};
function createBaseMsgWithdrawDelegatorRewardResponse() {
    return {};
}
const MsgWithdrawDelegatorRewardResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawDelegatorRewardResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgWithdrawDelegatorRewardResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgWithdrawDelegatorRewardResponse();
        return message;
    },
};
function createBaseMsgWithdrawValidatorCommission() {
    return { validatorAddress: "" };
}
const MsgWithdrawValidatorCommission = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.validatorAddress !== "") {
            writer.uint32(10).string(message.validatorAddress);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawValidatorCommission();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.validatorAddress = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { validatorAddress: isSet$3(object.validatorAddress) ? String(object.validatorAddress) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.validatorAddress !== "") {
            obj.validatorAddress = message.validatorAddress;
        }
        return obj;
    },
    create(base) {
        return MsgWithdrawValidatorCommission.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgWithdrawValidatorCommission();
        message.validatorAddress = object.validatorAddress ?? "";
        return message;
    },
};
function createBaseMsgWithdrawValidatorCommissionResponse() {
    return {};
}
const MsgWithdrawValidatorCommissionResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgWithdrawValidatorCommissionResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgWithdrawValidatorCommissionResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgWithdrawValidatorCommissionResponse();
        return message;
    },
};
function createBaseMsgFundCommunityPool() {
    return { amount: [], depositor: "" };
}
const MsgFundCommunityPool = {
    encode(message, writer = _m0.Writer.create()) {
        for (const v of message.amount) {
            Coin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        if (message.depositor !== "") {
            writer.uint32(18).string(message.depositor);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgFundCommunityPool();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.amount.push(Coin.decode(reader, reader.uint32()));
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.depositor = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            amount: Array.isArray(object?.amount) ? object.amount.map((e) => Coin.fromJSON(e)) : [],
            depositor: isSet$3(object.depositor) ? String(object.depositor) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.amount?.length) {
            obj.amount = message.amount.map((e) => Coin.toJSON(e));
        }
        if (message.depositor !== "") {
            obj.depositor = message.depositor;
        }
        return obj;
    },
    create(base) {
        return MsgFundCommunityPool.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgFundCommunityPool();
        message.amount = object.amount?.map((e) => Coin.fromPartial(e)) || [];
        message.depositor = object.depositor ?? "";
        return message;
    },
};
function createBaseMsgFundCommunityPoolResponse() {
    return {};
}
const MsgFundCommunityPoolResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgFundCommunityPoolResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgFundCommunityPoolResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgFundCommunityPoolResponse();
        return message;
    },
};
let MsgClientImpl$3 = class MsgClientImpl {
    rpc;
    constructor(rpc) {
        this.rpc = rpc;
        this.SetWithdrawAddress = this.SetWithdrawAddress.bind(this);
        this.WithdrawDelegatorReward = this.WithdrawDelegatorReward.bind(this);
        this.WithdrawValidatorCommission = this.WithdrawValidatorCommission.bind(this);
        this.FundCommunityPool = this.FundCommunityPool.bind(this);
    }
    SetWithdrawAddress(request, metadata) {
        return this.rpc.unary(MsgSetWithdrawAddressDesc, MsgSetWithdrawAddress.fromPartial(request), metadata);
    }
    WithdrawDelegatorReward(request, metadata) {
        return this.rpc.unary(MsgWithdrawDelegatorRewardDesc, MsgWithdrawDelegatorReward.fromPartial(request), metadata);
    }
    WithdrawValidatorCommission(request, metadata) {
        return this.rpc.unary(MsgWithdrawValidatorCommissionDesc, MsgWithdrawValidatorCommission.fromPartial(request), metadata);
    }
    FundCommunityPool(request, metadata) {
        return this.rpc.unary(MsgFundCommunityPoolDesc, MsgFundCommunityPool.fromPartial(request), metadata);
    }
};
const MsgDesc$3 = { serviceName: "cosmos.distribution.v1beta1.Msg" };
const MsgSetWithdrawAddressDesc = {
    methodName: "SetWithdrawAddress",
    service: MsgDesc$3,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgSetWithdrawAddress.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgSetWithdrawAddressResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgWithdrawDelegatorRewardDesc = {
    methodName: "WithdrawDelegatorReward",
    service: MsgDesc$3,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgWithdrawDelegatorReward.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgWithdrawDelegatorRewardResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgWithdrawValidatorCommissionDesc = {
    methodName: "WithdrawValidatorCommission",
    service: MsgDesc$3,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgWithdrawValidatorCommission.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgWithdrawValidatorCommissionResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgFundCommunityPoolDesc = {
    methodName: "FundCommunityPool",
    service: MsgDesc$3,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgFundCommunityPool.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgFundCommunityPoolResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
let GrpcWebImpl$3 = class GrpcWebImpl {
    host;
    options;
    constructor(host, options) {
        this.host = host;
        this.options = options;
    }
    unary(methodDesc, _request, metadata) {
        const request = { ..._request, ...methodDesc.requestType };
        const maybeCombinedMetadata = metadata && this.options.metadata
            ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
            : metadata ?? this.options.metadata;
        return new Promise((resolve, reject) => {
            grpc.unary(methodDesc, {
                request,
                host: this.host,
                metadata: maybeCombinedMetadata ?? {},
                ...(this.options.transport !== undefined ? { transport: this.options.transport } : {}),
                debug: this.options.debug ?? false,
                onEnd: function (response) {
                    if (response.status === grpc.Code.OK) {
                        resolve(response.message.toObject());
                    }
                    else {
                        const err = new GrpcWebError$3(response.statusMessage, response.status, response.trailers);
                        reject(err);
                    }
                },
            });
        });
    }
};
const tsProtoGlobalThis$3 = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function isSet$3(value) {
    return value !== null && value !== undefined;
}
let GrpcWebError$3 = class GrpcWebError extends tsProtoGlobalThis$3.Error {
    code;
    metadata;
    constructor(message, code, metadata) {
        super(message);
        this.code = code;
        this.metadata = metadata;
    }
};

const distibutionTypes = {
    fundCommunityPool: [
        '/cosmos.distribution.v1beta1.MsgFundCommunityPool',
        MsgFundCommunityPool
    ],
    setWithdrawAddress: [
        '/cosmos.distribution.v1beta1.MsgSetWithdrawAddress',
        MsgSetWithdrawAddress
    ],
    withdrawDelegatorReward: [
        '/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward',
        MsgWithdrawDelegatorReward
    ],
    withdrawValidatorCommission: [
        '/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission',
        MsgWithdrawValidatorCommission
    ]
};
class TxDistribution {
    msgFundCommunityPool(data) {
        return {
            typeUrl: distibutionTypes.fundCommunityPool[0],
            value: distibutionTypes.fundCommunityPool[1].fromPartial(data)
        };
    }
    msgSetWithdrawAddress(data) {
        return {
            typeUrl: distibutionTypes.setWithdrawAddress[0],
            value: distibutionTypes.setWithdrawAddress[1].fromPartial(data)
        };
    }
    msgWithdrawDelegatorReward(data) {
        return {
            typeUrl: distibutionTypes.withdrawDelegatorReward[0],
            value: distibutionTypes.withdrawDelegatorReward[1].fromPartial(data)
        };
    }
    msgWithdrawValidatorCommission(data) {
        return {
            typeUrl: distibutionTypes.withdrawValidatorCommission[0],
            value: distibutionTypes.withdrawValidatorCommission[1].fromPartial(data)
        };
    }
}

/* eslint-disable */
const protobufPackage$2 = "cosmos.gov.v1beta1";
function createBaseMsgSubmitProposal() {
    return { content: undefined, initialDeposit: [], proposer: "" };
}
const MsgSubmitProposal = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.content !== undefined) {
            Any.encode(message.content, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.initialDeposit) {
            Coin.encode(v, writer.uint32(18).fork()).ldelim();
        }
        if (message.proposer !== "") {
            writer.uint32(26).string(message.proposer);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitProposal();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.content = Any.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.initialDeposit.push(Coin.decode(reader, reader.uint32()));
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.proposer = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            content: isSet$2(object.content) ? Any.fromJSON(object.content) : undefined,
            initialDeposit: Array.isArray(object?.initialDeposit)
                ? object.initialDeposit.map((e) => Coin.fromJSON(e))
                : [],
            proposer: isSet$2(object.proposer) ? String(object.proposer) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.content !== undefined) {
            obj.content = Any.toJSON(message.content);
        }
        if (message.initialDeposit?.length) {
            obj.initialDeposit = message.initialDeposit.map((e) => Coin.toJSON(e));
        }
        if (message.proposer !== "") {
            obj.proposer = message.proposer;
        }
        return obj;
    },
    create(base) {
        return MsgSubmitProposal.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgSubmitProposal();
        message.content = (object.content !== undefined && object.content !== null)
            ? Any.fromPartial(object.content)
            : undefined;
        message.initialDeposit = object.initialDeposit?.map((e) => Coin.fromPartial(e)) || [];
        message.proposer = object.proposer ?? "";
        return message;
    },
};
function createBaseMsgSubmitProposalResponse() {
    return { proposalId: 0 };
}
const MsgSubmitProposalResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.proposalId !== 0) {
            writer.uint32(8).uint64(message.proposalId);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgSubmitProposalResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.proposalId = longToNumber(reader.uint64());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { proposalId: isSet$2(object.proposalId) ? Number(object.proposalId) : 0 };
    },
    toJSON(message) {
        const obj = {};
        if (message.proposalId !== 0) {
            obj.proposalId = Math.round(message.proposalId);
        }
        return obj;
    },
    create(base) {
        return MsgSubmitProposalResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgSubmitProposalResponse();
        message.proposalId = object.proposalId ?? 0;
        return message;
    },
};
function createBaseMsgVote() {
    return { proposalId: 0, voter: "", option: 0 };
}
const MsgVote = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.proposalId !== 0) {
            writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
            writer.uint32(18).string(message.voter);
        }
        if (message.option !== 0) {
            writer.uint32(24).int32(message.option);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgVote();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.proposalId = longToNumber(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.voter = reader.string();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.option = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            proposalId: isSet$2(object.proposalId) ? Number(object.proposalId) : 0,
            voter: isSet$2(object.voter) ? String(object.voter) : "",
            option: isSet$2(object.option) ? voteOptionFromJSON(object.option) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.proposalId !== 0) {
            obj.proposalId = Math.round(message.proposalId);
        }
        if (message.voter !== "") {
            obj.voter = message.voter;
        }
        if (message.option !== 0) {
            obj.option = voteOptionToJSON(message.option);
        }
        return obj;
    },
    create(base) {
        return MsgVote.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgVote();
        message.proposalId = object.proposalId ?? 0;
        message.voter = object.voter ?? "";
        message.option = object.option ?? 0;
        return message;
    },
};
function createBaseMsgVoteResponse() {
    return {};
}
const MsgVoteResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgVoteResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgVoteResponse();
        return message;
    },
};
function createBaseMsgVoteWeighted() {
    return { proposalId: 0, voter: "", options: [] };
}
const MsgVoteWeighted = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.proposalId !== 0) {
            writer.uint32(8).uint64(message.proposalId);
        }
        if (message.voter !== "") {
            writer.uint32(18).string(message.voter);
        }
        for (const v of message.options) {
            WeightedVoteOption.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteWeighted();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.proposalId = longToNumber(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.voter = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.options.push(WeightedVoteOption.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            proposalId: isSet$2(object.proposalId) ? Number(object.proposalId) : 0,
            voter: isSet$2(object.voter) ? String(object.voter) : "",
            options: Array.isArray(object?.options) ? object.options.map((e) => WeightedVoteOption.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.proposalId !== 0) {
            obj.proposalId = Math.round(message.proposalId);
        }
        if (message.voter !== "") {
            obj.voter = message.voter;
        }
        if (message.options?.length) {
            obj.options = message.options.map((e) => WeightedVoteOption.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return MsgVoteWeighted.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgVoteWeighted();
        message.proposalId = object.proposalId ?? 0;
        message.voter = object.voter ?? "";
        message.options = object.options?.map((e) => WeightedVoteOption.fromPartial(e)) || [];
        return message;
    },
};
function createBaseMsgVoteWeightedResponse() {
    return {};
}
const MsgVoteWeightedResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgVoteWeightedResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgVoteWeightedResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgVoteWeightedResponse();
        return message;
    },
};
function createBaseMsgDeposit() {
    return { proposalId: 0, depositor: "", amount: [] };
}
const MsgDeposit = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.proposalId !== 0) {
            writer.uint32(8).uint64(message.proposalId);
        }
        if (message.depositor !== "") {
            writer.uint32(18).string(message.depositor);
        }
        for (const v of message.amount) {
            Coin.encode(v, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgDeposit();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.proposalId = longToNumber(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.depositor = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.amount.push(Coin.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            proposalId: isSet$2(object.proposalId) ? Number(object.proposalId) : 0,
            depositor: isSet$2(object.depositor) ? String(object.depositor) : "",
            amount: Array.isArray(object?.amount) ? object.amount.map((e) => Coin.fromJSON(e)) : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.proposalId !== 0) {
            obj.proposalId = Math.round(message.proposalId);
        }
        if (message.depositor !== "") {
            obj.depositor = message.depositor;
        }
        if (message.amount?.length) {
            obj.amount = message.amount.map((e) => Coin.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return MsgDeposit.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgDeposit();
        message.proposalId = object.proposalId ?? 0;
        message.depositor = object.depositor ?? "";
        message.amount = object.amount?.map((e) => Coin.fromPartial(e)) || [];
        return message;
    },
};
function createBaseMsgDepositResponse() {
    return {};
}
const MsgDepositResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgDepositResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgDepositResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgDepositResponse();
        return message;
    },
};
let MsgClientImpl$2 = class MsgClientImpl {
    rpc;
    constructor(rpc) {
        this.rpc = rpc;
        this.SubmitProposal = this.SubmitProposal.bind(this);
        this.Vote = this.Vote.bind(this);
        this.VoteWeighted = this.VoteWeighted.bind(this);
        this.Deposit = this.Deposit.bind(this);
    }
    SubmitProposal(request, metadata) {
        return this.rpc.unary(MsgSubmitProposalDesc, MsgSubmitProposal.fromPartial(request), metadata);
    }
    Vote(request, metadata) {
        return this.rpc.unary(MsgVoteDesc, MsgVote.fromPartial(request), metadata);
    }
    VoteWeighted(request, metadata) {
        return this.rpc.unary(MsgVoteWeightedDesc, MsgVoteWeighted.fromPartial(request), metadata);
    }
    Deposit(request, metadata) {
        return this.rpc.unary(MsgDepositDesc, MsgDeposit.fromPartial(request), metadata);
    }
};
const MsgDesc$2 = { serviceName: "cosmos.gov.v1beta1.Msg" };
const MsgSubmitProposalDesc = {
    methodName: "SubmitProposal",
    service: MsgDesc$2,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgSubmitProposal.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgSubmitProposalResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgVoteDesc = {
    methodName: "Vote",
    service: MsgDesc$2,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgVote.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgVoteResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgVoteWeightedDesc = {
    methodName: "VoteWeighted",
    service: MsgDesc$2,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgVoteWeighted.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgVoteWeightedResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgDepositDesc = {
    methodName: "Deposit",
    service: MsgDesc$2,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgDeposit.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgDepositResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
let GrpcWebImpl$2 = class GrpcWebImpl {
    host;
    options;
    constructor(host, options) {
        this.host = host;
        this.options = options;
    }
    unary(methodDesc, _request, metadata) {
        const request = { ..._request, ...methodDesc.requestType };
        const maybeCombinedMetadata = metadata && this.options.metadata
            ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
            : metadata ?? this.options.metadata;
        return new Promise((resolve, reject) => {
            grpc.unary(methodDesc, {
                request,
                host: this.host,
                metadata: maybeCombinedMetadata ?? {},
                ...(this.options.transport !== undefined ? { transport: this.options.transport } : {}),
                debug: this.options.debug ?? false,
                onEnd: function (response) {
                    if (response.status === grpc.Code.OK) {
                        resolve(response.message.toObject());
                    }
                    else {
                        const err = new GrpcWebError$2(response.statusMessage, response.status, response.trailers);
                        reject(err);
                    }
                },
            });
        });
    }
};
const tsProtoGlobalThis$2 = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function longToNumber(long) {
    if (long.gt(Number.MAX_SAFE_INTEGER)) {
        throw new tsProtoGlobalThis$2.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (_m0.util.Long !== Long) {
    _m0.util.Long = Long;
    _m0.configure();
}
function isSet$2(value) {
    return value !== null && value !== undefined;
}
let GrpcWebError$2 = class GrpcWebError extends tsProtoGlobalThis$2.Error {
    code;
    metadata;
    constructor(message, code, metadata) {
        super(message);
        this.code = code;
        this.metadata = metadata;
    }
};

const govTypes = {
    deposit: ['/cosmos.gov.v1beta1.MsgDeposit', MsgDeposit],
    submitProposal: ['/cosmos.gov.v1beta1.MsgSubmitProposal', MsgSubmitProposal],
    vote: ['/cosmos.gov.v1beta1.MsgVote', MsgVote],
    voteWeighted: ['/cosmos.gov.v1beta1.MsgVoteWeighted', MsgVoteWeighted]
};
class TxGov {
    msgDeposit(data) {
        return {
            typeUrl: govTypes.deposit[0],
            value: govTypes.deposit[1].fromPartial(data)
        };
    }
    msgSubmitProposal(data) {
        return {
            typeUrl: govTypes.submitProposal[0],
            value: govTypes.submitProposal[1].fromPartial(data)
        };
    }
    msgVote(data) {
        return {
            typeUrl: govTypes.vote[0],
            value: govTypes.vote[1].fromPartial(data)
        };
    }
    msgVoteWeighted(data) {
        return {
            typeUrl: govTypes.voteWeighted[0],
            value: govTypes.voteWeighted[1].fromPartial(data)
        };
    }
}

/* eslint-disable */
const protobufPackage$1 = "cosmos.slashing.v1beta1";
function createBaseMsgUnjail() {
    return { validatorAddr: "" };
}
const MsgUnjail = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.validatorAddr !== "") {
            writer.uint32(10).string(message.validatorAddr);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUnjail();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.validatorAddr = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { validatorAddr: isSet$1(object.validatorAddr) ? String(object.validatorAddr) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.validatorAddr !== "") {
            obj.validatorAddr = message.validatorAddr;
        }
        return obj;
    },
    create(base) {
        return MsgUnjail.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgUnjail();
        message.validatorAddr = object.validatorAddr ?? "";
        return message;
    },
};
function createBaseMsgUnjailResponse() {
    return {};
}
const MsgUnjailResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUnjailResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgUnjailResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgUnjailResponse();
        return message;
    },
};
let MsgClientImpl$1 = class MsgClientImpl {
    rpc;
    constructor(rpc) {
        this.rpc = rpc;
        this.Unjail = this.Unjail.bind(this);
    }
    Unjail(request, metadata) {
        return this.rpc.unary(MsgUnjailDesc, MsgUnjail.fromPartial(request), metadata);
    }
};
const MsgDesc$1 = { serviceName: "cosmos.slashing.v1beta1.Msg" };
const MsgUnjailDesc = {
    methodName: "Unjail",
    service: MsgDesc$1,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgUnjail.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgUnjailResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
let GrpcWebImpl$1 = class GrpcWebImpl {
    host;
    options;
    constructor(host, options) {
        this.host = host;
        this.options = options;
    }
    unary(methodDesc, _request, metadata) {
        const request = { ..._request, ...methodDesc.requestType };
        const maybeCombinedMetadata = metadata && this.options.metadata
            ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
            : metadata ?? this.options.metadata;
        return new Promise((resolve, reject) => {
            grpc.unary(methodDesc, {
                request,
                host: this.host,
                metadata: maybeCombinedMetadata ?? {},
                ...(this.options.transport !== undefined ? { transport: this.options.transport } : {}),
                debug: this.options.debug ?? false,
                onEnd: function (response) {
                    if (response.status === grpc.Code.OK) {
                        resolve(response.message.toObject());
                    }
                    else {
                        const err = new GrpcWebError$1(response.statusMessage, response.status, response.trailers);
                        reject(err);
                    }
                },
            });
        });
    }
};
const tsProtoGlobalThis$1 = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function isSet$1(value) {
    return value !== null && value !== undefined;
}
let GrpcWebError$1 = class GrpcWebError extends tsProtoGlobalThis$1.Error {
    code;
    metadata;
    constructor(message, code, metadata) {
        super(message);
        this.code = code;
        this.metadata = metadata;
    }
};

const slashingTypes = {
    unjail: ['/cosmos.slashing.v1beta1.MsgUnjail', MsgUnjail]
};
class TxSlashing {
    msgUnjail(data) {
        return {
            typeUrl: slashingTypes.unjail[0],
            value: slashingTypes.unjail[1].fromPartial(data)
        };
    }
}

/* eslint-disable */
const protobufPackage = "cosmos.staking.v1beta1";
function createBaseMsgCreateValidator() {
    return {
        description: undefined,
        commission: undefined,
        minSelfDelegation: "",
        delegatorAddress: "",
        validatorAddress: "",
        pubkey: undefined,
        value: undefined,
    };
}
const MsgCreateValidator = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.description !== undefined) {
            Description.encode(message.description, writer.uint32(10).fork()).ldelim();
        }
        if (message.commission !== undefined) {
            CommissionRates.encode(message.commission, writer.uint32(18).fork()).ldelim();
        }
        if (message.minSelfDelegation !== "") {
            writer.uint32(26).string(message.minSelfDelegation);
        }
        if (message.delegatorAddress !== "") {
            writer.uint32(34).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
            writer.uint32(42).string(message.validatorAddress);
        }
        if (message.pubkey !== undefined) {
            Any.encode(message.pubkey, writer.uint32(50).fork()).ldelim();
        }
        if (message.value !== undefined) {
            Coin.encode(message.value, writer.uint32(58).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateValidator();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.description = Description.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.commission = CommissionRates.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.minSelfDelegation = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.delegatorAddress = reader.string();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.validatorAddress = reader.string();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.pubkey = Any.decode(reader, reader.uint32());
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.value = Coin.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            description: isSet(object.description) ? Description.fromJSON(object.description) : undefined,
            commission: isSet(object.commission) ? CommissionRates.fromJSON(object.commission) : undefined,
            minSelfDelegation: isSet(object.minSelfDelegation) ? String(object.minSelfDelegation) : "",
            delegatorAddress: isSet(object.delegatorAddress) ? String(object.delegatorAddress) : "",
            validatorAddress: isSet(object.validatorAddress) ? String(object.validatorAddress) : "",
            pubkey: isSet(object.pubkey) ? Any.fromJSON(object.pubkey) : undefined,
            value: isSet(object.value) ? Coin.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.description !== undefined) {
            obj.description = Description.toJSON(message.description);
        }
        if (message.commission !== undefined) {
            obj.commission = CommissionRates.toJSON(message.commission);
        }
        if (message.minSelfDelegation !== "") {
            obj.minSelfDelegation = message.minSelfDelegation;
        }
        if (message.delegatorAddress !== "") {
            obj.delegatorAddress = message.delegatorAddress;
        }
        if (message.validatorAddress !== "") {
            obj.validatorAddress = message.validatorAddress;
        }
        if (message.pubkey !== undefined) {
            obj.pubkey = Any.toJSON(message.pubkey);
        }
        if (message.value !== undefined) {
            obj.value = Coin.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return MsgCreateValidator.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgCreateValidator();
        message.description = (object.description !== undefined && object.description !== null)
            ? Description.fromPartial(object.description)
            : undefined;
        message.commission = (object.commission !== undefined && object.commission !== null)
            ? CommissionRates.fromPartial(object.commission)
            : undefined;
        message.minSelfDelegation = object.minSelfDelegation ?? "";
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        message.pubkey = (object.pubkey !== undefined && object.pubkey !== null)
            ? Any.fromPartial(object.pubkey)
            : undefined;
        message.value = (object.value !== undefined && object.value !== null) ? Coin.fromPartial(object.value) : undefined;
        return message;
    },
};
function createBaseMsgCreateValidatorResponse() {
    return {};
}
const MsgCreateValidatorResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgCreateValidatorResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgCreateValidatorResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgCreateValidatorResponse();
        return message;
    },
};
function createBaseMsgEditValidator() {
    return { description: undefined, validatorAddress: "", commissionRate: "", minSelfDelegation: "" };
}
const MsgEditValidator = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.description !== undefined) {
            Description.encode(message.description, writer.uint32(10).fork()).ldelim();
        }
        if (message.validatorAddress !== "") {
            writer.uint32(18).string(message.validatorAddress);
        }
        if (message.commissionRate !== "") {
            writer.uint32(26).string(message.commissionRate);
        }
        if (message.minSelfDelegation !== "") {
            writer.uint32(34).string(message.minSelfDelegation);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgEditValidator();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.description = Description.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.validatorAddress = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.commissionRate = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.minSelfDelegation = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            description: isSet(object.description) ? Description.fromJSON(object.description) : undefined,
            validatorAddress: isSet(object.validatorAddress) ? String(object.validatorAddress) : "",
            commissionRate: isSet(object.commissionRate) ? String(object.commissionRate) : "",
            minSelfDelegation: isSet(object.minSelfDelegation) ? String(object.minSelfDelegation) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.description !== undefined) {
            obj.description = Description.toJSON(message.description);
        }
        if (message.validatorAddress !== "") {
            obj.validatorAddress = message.validatorAddress;
        }
        if (message.commissionRate !== "") {
            obj.commissionRate = message.commissionRate;
        }
        if (message.minSelfDelegation !== "") {
            obj.minSelfDelegation = message.minSelfDelegation;
        }
        return obj;
    },
    create(base) {
        return MsgEditValidator.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgEditValidator();
        message.description = (object.description !== undefined && object.description !== null)
            ? Description.fromPartial(object.description)
            : undefined;
        message.validatorAddress = object.validatorAddress ?? "";
        message.commissionRate = object.commissionRate ?? "";
        message.minSelfDelegation = object.minSelfDelegation ?? "";
        return message;
    },
};
function createBaseMsgEditValidatorResponse() {
    return {};
}
const MsgEditValidatorResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgEditValidatorResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgEditValidatorResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgEditValidatorResponse();
        return message;
    },
};
function createBaseMsgDelegate() {
    return { delegatorAddress: "", validatorAddress: "", amount: undefined };
}
const MsgDelegate = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.delegatorAddress !== "") {
            writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
            writer.uint32(18).string(message.validatorAddress);
        }
        if (message.amount !== undefined) {
            Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgDelegate();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.delegatorAddress = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.validatorAddress = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.amount = Coin.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            delegatorAddress: isSet(object.delegatorAddress) ? String(object.delegatorAddress) : "",
            validatorAddress: isSet(object.validatorAddress) ? String(object.validatorAddress) : "",
            amount: isSet(object.amount) ? Coin.fromJSON(object.amount) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.delegatorAddress !== "") {
            obj.delegatorAddress = message.delegatorAddress;
        }
        if (message.validatorAddress !== "") {
            obj.validatorAddress = message.validatorAddress;
        }
        if (message.amount !== undefined) {
            obj.amount = Coin.toJSON(message.amount);
        }
        return obj;
    },
    create(base) {
        return MsgDelegate.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgDelegate();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        message.amount = (object.amount !== undefined && object.amount !== null)
            ? Coin.fromPartial(object.amount)
            : undefined;
        return message;
    },
};
function createBaseMsgDelegateResponse() {
    return {};
}
const MsgDelegateResponse = {
    encode(_, writer = _m0.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgDelegateResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return MsgDelegateResponse.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseMsgDelegateResponse();
        return message;
    },
};
function createBaseMsgBeginRedelegate() {
    return { delegatorAddress: "", validatorSrcAddress: "", validatorDstAddress: "", amount: undefined };
}
const MsgBeginRedelegate = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.delegatorAddress !== "") {
            writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorSrcAddress !== "") {
            writer.uint32(18).string(message.validatorSrcAddress);
        }
        if (message.validatorDstAddress !== "") {
            writer.uint32(26).string(message.validatorDstAddress);
        }
        if (message.amount !== undefined) {
            Coin.encode(message.amount, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgBeginRedelegate();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.delegatorAddress = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.validatorSrcAddress = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.validatorDstAddress = reader.string();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.amount = Coin.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            delegatorAddress: isSet(object.delegatorAddress) ? String(object.delegatorAddress) : "",
            validatorSrcAddress: isSet(object.validatorSrcAddress) ? String(object.validatorSrcAddress) : "",
            validatorDstAddress: isSet(object.validatorDstAddress) ? String(object.validatorDstAddress) : "",
            amount: isSet(object.amount) ? Coin.fromJSON(object.amount) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.delegatorAddress !== "") {
            obj.delegatorAddress = message.delegatorAddress;
        }
        if (message.validatorSrcAddress !== "") {
            obj.validatorSrcAddress = message.validatorSrcAddress;
        }
        if (message.validatorDstAddress !== "") {
            obj.validatorDstAddress = message.validatorDstAddress;
        }
        if (message.amount !== undefined) {
            obj.amount = Coin.toJSON(message.amount);
        }
        return obj;
    },
    create(base) {
        return MsgBeginRedelegate.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgBeginRedelegate();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorSrcAddress = object.validatorSrcAddress ?? "";
        message.validatorDstAddress = object.validatorDstAddress ?? "";
        message.amount = (object.amount !== undefined && object.amount !== null)
            ? Coin.fromPartial(object.amount)
            : undefined;
        return message;
    },
};
function createBaseMsgBeginRedelegateResponse() {
    return { completionTime: undefined };
}
const MsgBeginRedelegateResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.completionTime !== undefined) {
            Timestamp.encode(toTimestamp(message.completionTime), writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgBeginRedelegateResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.completionTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { completionTime: isSet(object.completionTime) ? fromJsonTimestamp(object.completionTime) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.completionTime !== undefined) {
            obj.completionTime = message.completionTime.toISOString();
        }
        return obj;
    },
    create(base) {
        return MsgBeginRedelegateResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgBeginRedelegateResponse();
        message.completionTime = object.completionTime ?? undefined;
        return message;
    },
};
function createBaseMsgUndelegate() {
    return { delegatorAddress: "", validatorAddress: "", amount: undefined };
}
const MsgUndelegate = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.delegatorAddress !== "") {
            writer.uint32(10).string(message.delegatorAddress);
        }
        if (message.validatorAddress !== "") {
            writer.uint32(18).string(message.validatorAddress);
        }
        if (message.amount !== undefined) {
            Coin.encode(message.amount, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUndelegate();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.delegatorAddress = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.validatorAddress = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.amount = Coin.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            delegatorAddress: isSet(object.delegatorAddress) ? String(object.delegatorAddress) : "",
            validatorAddress: isSet(object.validatorAddress) ? String(object.validatorAddress) : "",
            amount: isSet(object.amount) ? Coin.fromJSON(object.amount) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.delegatorAddress !== "") {
            obj.delegatorAddress = message.delegatorAddress;
        }
        if (message.validatorAddress !== "") {
            obj.validatorAddress = message.validatorAddress;
        }
        if (message.amount !== undefined) {
            obj.amount = Coin.toJSON(message.amount);
        }
        return obj;
    },
    create(base) {
        return MsgUndelegate.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgUndelegate();
        message.delegatorAddress = object.delegatorAddress ?? "";
        message.validatorAddress = object.validatorAddress ?? "";
        message.amount = (object.amount !== undefined && object.amount !== null)
            ? Coin.fromPartial(object.amount)
            : undefined;
        return message;
    },
};
function createBaseMsgUndelegateResponse() {
    return { completionTime: undefined };
}
const MsgUndelegateResponse = {
    encode(message, writer = _m0.Writer.create()) {
        if (message.completionTime !== undefined) {
            Timestamp.encode(toTimestamp(message.completionTime), writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMsgUndelegateResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.completionTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { completionTime: isSet(object.completionTime) ? fromJsonTimestamp(object.completionTime) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.completionTime !== undefined) {
            obj.completionTime = message.completionTime.toISOString();
        }
        return obj;
    },
    create(base) {
        return MsgUndelegateResponse.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseMsgUndelegateResponse();
        message.completionTime = object.completionTime ?? undefined;
        return message;
    },
};
class MsgClientImpl {
    rpc;
    constructor(rpc) {
        this.rpc = rpc;
        this.CreateValidator = this.CreateValidator.bind(this);
        this.EditValidator = this.EditValidator.bind(this);
        this.Delegate = this.Delegate.bind(this);
        this.BeginRedelegate = this.BeginRedelegate.bind(this);
        this.Undelegate = this.Undelegate.bind(this);
    }
    CreateValidator(request, metadata) {
        return this.rpc.unary(MsgCreateValidatorDesc, MsgCreateValidator.fromPartial(request), metadata);
    }
    EditValidator(request, metadata) {
        return this.rpc.unary(MsgEditValidatorDesc, MsgEditValidator.fromPartial(request), metadata);
    }
    Delegate(request, metadata) {
        return this.rpc.unary(MsgDelegateDesc, MsgDelegate.fromPartial(request), metadata);
    }
    BeginRedelegate(request, metadata) {
        return this.rpc.unary(MsgBeginRedelegateDesc, MsgBeginRedelegate.fromPartial(request), metadata);
    }
    Undelegate(request, metadata) {
        return this.rpc.unary(MsgUndelegateDesc, MsgUndelegate.fromPartial(request), metadata);
    }
}
const MsgDesc = { serviceName: "cosmos.staking.v1beta1.Msg" };
const MsgCreateValidatorDesc = {
    methodName: "CreateValidator",
    service: MsgDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgCreateValidator.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgCreateValidatorResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgEditValidatorDesc = {
    methodName: "EditValidator",
    service: MsgDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgEditValidator.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgEditValidatorResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgDelegateDesc = {
    methodName: "Delegate",
    service: MsgDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgDelegate.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgDelegateResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgBeginRedelegateDesc = {
    methodName: "BeginRedelegate",
    service: MsgDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgBeginRedelegate.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgBeginRedelegateResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
const MsgUndelegateDesc = {
    methodName: "Undelegate",
    service: MsgDesc,
    requestStream: false,
    responseStream: false,
    requestType: {
        serializeBinary() {
            return MsgUndelegate.encode(this).finish();
        },
    },
    responseType: {
        deserializeBinary(data) {
            const value = MsgUndelegateResponse.decode(data);
            return {
                ...value,
                toObject() {
                    return value;
                },
            };
        },
    },
};
class GrpcWebImpl {
    host;
    options;
    constructor(host, options) {
        this.host = host;
        this.options = options;
    }
    unary(methodDesc, _request, metadata) {
        const request = { ..._request, ...methodDesc.requestType };
        const maybeCombinedMetadata = metadata && this.options.metadata
            ? new BrowserHeaders({ ...this.options?.metadata.headersMap, ...metadata?.headersMap })
            : metadata ?? this.options.metadata;
        return new Promise((resolve, reject) => {
            grpc.unary(methodDesc, {
                request,
                host: this.host,
                metadata: maybeCombinedMetadata ?? {},
                ...(this.options.transport !== undefined ? { transport: this.options.transport } : {}),
                debug: this.options.debug ?? false,
                onEnd: function (response) {
                    if (response.status === grpc.Code.OK) {
                        resolve(response.message.toObject());
                    }
                    else {
                        const err = new GrpcWebError(response.statusMessage, response.status, response.trailers);
                        reject(err);
                    }
                },
            });
        });
    }
}
const tsProtoGlobalThis = (() => {
    if (typeof globalThis !== "undefined") {
        return globalThis;
    }
    if (typeof self !== "undefined") {
        return self;
    }
    if (typeof window !== "undefined") {
        return window;
    }
    if (typeof global !== "undefined") {
        return global;
    }
    throw "Unable to locate global object";
})();
function toTimestamp(date) {
    const seconds = date.getTime() / 1_000;
    const nanos = (date.getTime() % 1_000) * 1_000_000;
    return { seconds, nanos };
}
function fromTimestamp(t) {
    let millis = (t.seconds || 0) * 1_000;
    millis += (t.nanos || 0) / 1_000_000;
    return new Date(millis);
}
function fromJsonTimestamp(o) {
    if (o instanceof Date) {
        return o;
    }
    else if (typeof o === "string") {
        return new Date(o);
    }
    else {
        return fromTimestamp(Timestamp.fromJSON(o));
    }
}
function isSet(value) {
    return value !== null && value !== undefined;
}
class GrpcWebError extends tsProtoGlobalThis.Error {
    code;
    metadata;
    constructor(message, code, metadata) {
        super(message);
        this.code = code;
        this.metadata = metadata;
    }
}

const stakingTypes = {
    beginRedelegate: [
        '/cosmos.staking.v1beta1.MsgBeginRedelegate',
        MsgBeginRedelegate
    ],
    msgCreateValidator: [
        '/cosmos.staking.v1beta1.MsgCreateValidator',
        MsgCreateValidator
    ],
    delegate: ['/cosmos.staking.v1beta1.MsgDelegate', MsgDelegate],
    editValidator: ['/cosmos.staking.v1beta1.MsgEditValidator', MsgEditValidator],
    undelegate: ['/cosmos.staking.v1beta1.MsgUndelegate', MsgUndelegate]
};
class TxStaking {
    msgBeginRedelegate(data) {
        return {
            typeUrl: stakingTypes.beginRedelegate[0],
            value: stakingTypes.beginRedelegate[1].fromPartial(data)
        };
    }
    msgCreateValidator(data) {
        return {
            typeUrl: stakingTypes.msgCreateValidator[0],
            value: stakingTypes.msgCreateValidator[1].fromPartial(data)
        };
    }
    msgDelegate(data) {
        return {
            typeUrl: stakingTypes.delegate[0],
            value: stakingTypes.delegate[1].fromPartial(data)
        };
    }
    msgEditValidator(data) {
        return {
            typeUrl: stakingTypes.editValidator[0],
            value: stakingTypes.editValidator[1].fromPartial(data)
        };
    }
    msgUndelegate(data) {
        return {
            typeUrl: stakingTypes.undelegate[0],
            value: stakingTypes.undelegate[1].fromPartial(data)
        };
    }
}

function createFileTreeAminoConverters() {
    return {
        '/canine_chain.filetree.MsgPostFile': {
            aminoType: 'filetree/PostFile',
            toAmino: (value) => ({
                creator: value.creator,
                account: value.account,
                hashParent: value.hashParent,
                hashChild: value.hashChild,
                contents: value.contents,
                viewers: value.viewers,
                editors: value.editors,
                trackingNumber: value.trackingNumber
            }),
            fromAmino: (value) => ({
                creator: value.creator,
                account: value.account,
                hashParent: value.hashParent,
                hashChild: value.hashChild,
                contents: value.contents,
                viewers: value.viewers,
                editors: value.editors,
                trackingNumber: value.trackingNumber
            })
        },
        '/canine_chain.filetree.MsgAddViewers': {
            aminoType: 'filetree/AddViewers',
            toAmino: (value) => ({
                creator: value.creator,
                viewerIds: value.viewerIds,
                viewerKeys: value.viewerKeys,
                address: value.address,
                fileowner: value.fileowner
            }),
            fromAmino: (value) => ({
                creator: value.creator,
                viewerIds: value.viewerIds,
                viewerKeys: value.viewerKeys,
                address: value.address,
                fileowner: value.fileowner
            })
        },
        '/canine_chain.filetree.MsgPostkey': {
            aminoType: 'filetree/Postkey',
            toAmino: (value) => ({
                creator: value.creator,
                key: value.key
            }),
            fromAmino: (value) => ({
                creator: value.creator,
                key: value.key
            })
        },
        '/canine_chain.filetree.MsgDeleteFile': {
            aminoType: 'filetree/DeleteFile',
            toAmino: (value) => ({
                creator: value.creator,
                hashPath: value.hashPath,
                account: value.account
            }),
            fromAmino: (value) => ({
                creator: value.creator,
                hashPath: value.hashPath,
                account: value.account
            })
        },
        '/canine_chain.filetree.MsgRemoveViewers': {
            aminoType: 'filetree/RemoveViewers',
            toAmino: (value) => ({
                creator: value.creator,
                viewerIds: value.viewerIds,
                address: value.address,
                fileowner: value.fileowner
            }),
            fromAmino: (value) => ({
                creator: value.creator,
                viewerIds: value.viewerIds,
                address: value.address,
                fileowner: value.fileowner
            })
        },
        '/canine_chain.filetree.MsgMakeRoot': {
            aminoType: 'filetree/MakeRoot',
            toAmino: (value) => ({
                creator: value.creator,
                account: value.account,
                rootHashPath: value.rootHashPath,
                contents: value.contents,
                editors: value.editors,
                viewers: value.viewers,
                trackingNumber: value.trackingNumber
            }),
            fromAmino: (value) => ({
                creator: value.creator,
                account: value.account,
                rootHashPath: value.rootHashPath,
                contents: value.contents,
                editors: value.editors,
                viewers: value.viewers,
                trackingNumber: value.trackingNumber
            })
        },
        '/canine_chain.filetree.MsgMakeRootV2': {
            aminoType: 'filetree/MakeRootV2',
            toAmino: (value) => ({
                creator: value.creator,
                editors: value.editors,
                viewers: value.viewers,
                trackingNumber: value.trackingNumber
            }),
            fromAmino: (value) => ({
                creator: value.creator,
                editors: value.editors,
                viewers: value.viewers,
                trackingNumber: value.trackingNumber
            })
        },
        '/canine_chain.filetree.MsgAddEditors': {
            aminoType: 'filetree/AddEditors',
            toAmino: (value) => ({
                creator: value.creator,
                editorIds: value.editorIds,
                editorKeys: value.editorKeys,
                address: value.address,
                fileowner: value.fileowner
            }),
            fromAmino: (value) => ({
                creator: value.creator,
                editorIds: value.editorIds,
                editorKeys: value.editorKeys,
                address: value.address,
                fileowner: value.fileowner
            })
        },
        '/canine_chain.filetree.MsgRemoveEditors': {
            aminoType: 'filetree/RemoveEditors',
            toAmino: (value) => ({
                creator: value.creator,
                editorIds: value.editorIds,
                address: value.address,
                fileowner: value.fileowner
            }),
            fromAmino: (value) => ({
                creator: value.creator,
                editorIds: value.editorIds,
                address: value.address,
                fileowner: value.fileowner
            })
        },
        '/canine_chain.filetree.MsgResetEditors': {
            aminoType: 'filetree/ResetEditors',
            toAmino: (value) => ({
                creator: value.creator,
                address: value.address,
                fileowner: value.fileowner
            }),
            fromAmino: (value) => ({
                creator: value.creator,
                address: value.address,
                fileowner: value.fileowner
            })
        },
        '/canine_chain.filetree.MsgResetViewers': {
            aminoType: 'filetree/ResetEditors',
            toAmino: (value) => ({
                creator: value.creator,
                address: value.address,
                fileowner: value.fileowner
            }),
            fromAmino: (value) => ({
                creator: value.creator,
                address: value.address,
                fileowner: value.fileowner
            })
        },
        '/canine_chain.filetree.MsgChangeOwner': {
            aminoType: 'filetree/ChangeOwner',
            toAmino: (value) => ({
                creator: value.creator,
                address: value.address,
                fileOwner: value.fileOwner,
                newOwner: value.newOwner
            }),
            fromAmino: (value) => ({
                creator: value.creator,
                address: value.address,
                fileOwner: value.fileOwner,
                newOwner: value.newOwner
            })
        }
    };
}

function createNotificationsAminoConverters() {
    return {
        '/canine_chain.notifications.MsgCreateNotifications': {
            aminoType: 'notifications/CreateNotifications',
            toAmino: (value) => ({
                creator: value.creator,
                notification: value.notification,
                address: value.address
            }),
            fromAmino: (value) => ({
                creator: value.creator,
                notification: value.notification,
                address: value.address
            })
        },
        '/canine_chain.notifications.MsgUpdateNotifications': {
            aminoType: 'notifications/UpdateNotifications',
            toAmino: (value) => ({
                creator: value.creator,
                count: value.count,
                notification: value.notification,
                address: value.address
            }),
            fromAmino: (value) => ({
                creator: value.creator,
                count: value.count,
                notification: value.notification,
                address: value.address
            })
        },
        '/canine_chain.notifications.MsgDeleteNotifications': {
            aminoType: 'notifications/DeleteNotifications',
            toAmino: (value) => ({
                creator: value.creator
            }),
            fromAmino: (value) => ({
                creator: value.creator
            })
        },
        '/canine_chain.notifications.MsgSetCounter': {
            aminoType: 'notifications/SetCounter',
            toAmino: (value) => ({
                creator: value.creator
            }),
            fromAmino: (value) => ({
                creator: value.creator
            })
        },
        '/canine_chain.notifications.MsgBlockSenders': {
            aminoType: 'notifications/BlockSenders',
            toAmino: (value) => ({
                creator: value.creator,
                senderIds: value.senderIds
            }),
            fromAmino: (value) => ({
                creator: value.creator,
                senderIds: value.senderIds
            })
        }
    };
}

function createOracleAminoConverters() {
    return {
        '/canine_chain.oracle.MsgCreateFeed': {
            aminoType: 'oracle/CreateFeed',
            toAmino: (value) => ({
                creator: value.creator,
                name: value.name
            }),
            fromAmino: (value) => ({
                creator: value.creator,
                name: value.name
            })
        },
        '/canine_chain.oracle.MsgUpdateFeed': {
            aminoType: 'oracle/UpdateFeed',
            toAmino: (value) => ({
                creator: value.creator,
                name: value.name,
                data: value.data
            }),
            fromAmino: (value) => ({
                creator: value.creator,
                name: value.name,
                data: value.data
            })
        }
    };
}

function createRnsAminoConverters() {
    return {
        '/canine_chain.rns.MsgRegister': {
            aminoType: 'rns/Register',
            toAmino: (value) => ({
                creator: value.creator,
                name: value.name,
                years: value.years,
                data: value.data
            }),
            fromAmino: (value) => ({
                creator: value.creator,
                name: value.name,
                years: value.years,
                data: value.data
            })
        },
        '/canine_chain.rns.MsgUpdate': {
            aminoType: 'rns/Update',
            toAmino: (value) => ({
                creator: value.creator,
                name: value.name,
                data: value.data
            }),
            fromAmino: (value) => ({
                creator: value.creator,
                name: value.name,
                data: value.data
            })
        },
        '/canine_chain.rns.MsgBid': {
            aminoType: 'rns/Bid',
            toAmino: (value) => ({
                creator: value.creator,
                name: value.name,
                bid: value.bid
            }),
            fromAmino: (value) => ({
                creator: value.creator,
                name: value.name,
                bid: value.bid
            })
        },
        '/canine_chain.rns.MsgAcceptBid': {
            aminoType: 'rns/AcceptBid',
            toAmino: (value) => ({
                creator: value.creator,
                name: value.name,
                from: value.from
            }),
            fromAmino: (value) => ({
                creator: value.creator,
                name: value.name,
                from: value.from
            })
        },
        '/canine_chain.rns.MsgCancelBid': {
            aminoType: 'rns/AminoMsgCancelBid',
            toAmino: (value) => ({
                creator: value.creator,
                name: value.name
            }),
            fromAmino: (value) => ({
                creator: value.creator,
                name: value.name
            })
        },
        '/canine_chain.rns.MsgList': {
            aminoType: 'rns/List',
            toAmino: (value) => ({
                creator: value.creator,
                name: value.name,
                price: value.price
            }),
            fromAmino: (value) => ({
                creator: value.creator,
                name: value.name,
                price: value.price
            })
        },
        '/canine_chain.rns.MsgBuy': {
            aminoType: 'rns/Buy',
            toAmino: (value) => ({
                creator: value.creator,
                name: value.name
            }),
            fromAmino: (value) => ({
                creator: value.creator,
                name: value.name
            })
        },
        '/canine_chain.rns.MsgDelist': {
            aminoType: 'rns/Delist',
            toAmino: (value) => ({
                creator: value.creator,
                name: value.name
            }),
            fromAmino: (value) => ({
                creator: value.creator,
                name: value.name
            })
        },
        '/canine_chain.rns.MsgTransfer': {
            aminoType: 'rns/Transfer',
            toAmino: (value) => ({
                creator: value.creator,
                name: value.name,
                receiver: value.receiver
            }),
            fromAmino: (value) => ({
                creator: value.creator,
                name: value.name,
                receiver: value.receiver
            })
        },
        '/canine_chain.rns.MsgAddRecord': {
            aminoType: 'rns/AddRecord',
            toAmino: (value) => ({
                creator: value.creator,
                name: value.name,
                value: value.value,
                data: value.data,
                record: value.record
            }),
            fromAmino: (value) => ({
                creator: value.creator,
                name: value.name,
                value: value.value,
                data: value.data,
                record: value.record
            })
        },
        '/canine_chain.rns.MsgDelRecord': {
            aminoType: 'rns/DelRecord',
            toAmino: (value) => ({
                creator: value.creator,
                name: value.name
            }),
            fromAmino: (value) => ({
                creator: value.creator,
                name: value.name
            })
        },
        '/canine_chain.rns.MsgInit': {
            aminoType: 'rns/Init',
            toAmino: (value) => ({
                creator: value.creator
            }),
            fromAmino: (value) => ({
                creator: value.creator
            })
        }
    };
}

function createStorageAminoConverters() {
    return {
        '/canine_chain.storage.MsgPostContract': {
            aminoType: 'storage/PostContract',
            toAmino: (value) => ({
                creator: value.creator,
                merkle: value.merkle,
                signee: value.signee,
                filesize: value.filesize,
                fid: value.fid
            }),
            fromAmino: (value) => ({
                creator: value.creator,
                merkle: value.merkle,
                signee: value.signee,
                filesize: value.filesize,
                fid: value.fid
            })
        },
        '/canine_chain.storage.MsgPostproof': {
            aminoType: 'storage/Postproof',
            toAmino: (value) => ({
                creator: value.creator,
                item: value.item,
                hashlist: value.hashlist,
                cid: value.cid
            }),
            fromAmino: (value) => ({
                creator: value.creator,
                item: value.item,
                hashlist: value.hashlist,
                cid: value.cid
            })
        },
        '/canine_chain.storage.MsgSignContract': {
            aminoType: 'storage/SignContract',
            toAmino: (value) => ({
                creator: value.creator,
                cid: value.cid,
                pay_once: value.payOnce
            }),
            fromAmino: (value) => ({
                creator: value.creator,
                cid: value.cid,
                payOnce: value.pay_once
            })
        },
        '/canine_chain.storage.MsgSetProviderIP': {
            aminoType: 'storage/SetProviderIp',
            toAmino: (value) => ({
                creator: value.creator,
                ip: value.ip
            }),
            fromAmino: (value) => ({
                creator: value.creator,
                ip: value.ip
            })
        },
        '/canine_chain.storage.MsgSetProviderKeybase': {
            aminoType: 'storage/SetProviderKeybase',
            toAmino: (value) => ({
                creator: value.creator,
                keybase: value.keybase
            }),
            fromAmino: (value) => ({
                creator: value.creator,
                keybase: value.keybase
            })
        },
        '/canine_chain.storage.MsgSetProviderTotalspace': {
            aminoType: 'storage/SetProviderTotalspace',
            toAmino: (value) => ({
                creator: value.creator,
                space: value.space
            }),
            fromAmino: (value) => ({
                creator: value.creator,
                space: value.space
            })
        },
        '/canine_chain.storage.MsgAddClaimer': {
            aminoType: 'storage/AddClaimer',
            toAmino: (value) => ({
                creator: value.creator,
                claim_address: value.claimAddress
            }),
            fromAmino: (value) => ({
                creator: value.creator,
                claimAddress: value.claim_address
            })
        },
        '/canine_chain.storage.MsgRemoveClaimer': {
            aminoType: 'storage/RemoveClaimer',
            toAmino: (value) => ({
                creator: value.creator,
                claim_address: value.claimAddress
            }),
            fromAmino: (value) => ({
                creator: value.creator,
                claimAddress: value.claim_address
            })
        },
        '/canine_chain.storage.MsgInitProvider': {
            aminoType: 'storage/InitProvider',
            toAmino: (value) => ({
                creator: value.creator,
                ip: value.ip,
                keybase: value.keybase,
                totalspace: value.totalspace
            }),
            fromAmino: (value) => ({
                creator: value.creator,
                ip: value.ip,
                keybase: value.keybase,
                totalspace: value.totalspace
            })
        },
        '/canine_chain.storage.MsgCancelContract': {
            aminoType: 'storage/CancelContract',
            toAmino: (value) => ({
                creator: value.creator,
                cid: value.cid
            }),
            fromAmino: (value) => ({
                creator: value.creator,
                cid: value.cid
            })
        },
        '/canine_chain.storage.MsgBuyStorage': {
            aminoType: 'storage/BuyStorage',
            toAmino: (value) => ({
                creator: value.creator,
                for_address: value.forAddress,
                duration: value.duration,
                bytes: value.bytes,
                payment_denom: value.paymentDenom
            }),
            fromAmino: (value) => ({
                creator: value.creator,
                forAddress: value.for_address,
                duration: value.duration,
                bytes: value.bytes,
                paymentDenom: value.payment_denom
            })
        },
        '/canine_chain.storage.MsgClaimStray': {
            aminoType: 'storage/ClaimStray',
            toAmino: (value) => ({
                creator: value.creator,
                cid: value.cid,
                for_address: value.forAddress
            }),
            fromAmino: (value) => ({
                creator: value.creator,
                cid: value.cid,
                forAddress: value.for_address
            })
        },
        '/canine_chain.storage.MsgUpgradeStorage': {
            aminoType: 'storage/UpgradeStorage',
            toAmino: (value) => ({
                creator: value.creator,
                for_address: value.forAddress,
                duration: value.duration,
                bytes: value.bytes,
                payment_denom: value.paymentDenom
            }),
            fromAmino: (value) => ({
                creator: value.creator,
                forAddress: value.for_address,
                duration: value.duration,
                bytes: value.bytes,
                paymentDenom: value.payment_denom
            })
        }
    };
}

/**
 * The Magic
 */
const masterTypes = [
    ...Object.values(fileTreeTypes),
    ...Object.values(notificationsTypes),
    ...Object.values(oracleTypes),
    ...Object.values(rnsTypes),
    ...Object.values(storageTypes),
    ...Object.values(bankTypes),
    ...Object.values(distibutionTypes),
    ...Object.values(govTypes),
    ...Object.values(slashingTypes),
    ...Object.values(stakingTypes)
];
const masterAminos = {
    ...createDefaultAminoConverters(),
    ...createFileTreeAminoConverters(),
    ...createNotificationsAminoConverters(),
    ...createOracleAminoConverters(),
    ...createRnsAminoConverters(),
    ...createStorageAminoConverters()
};
const registry = new Registry(masterTypes);
const defaultFee = {
    amount: [],
    gas: '200000'
};
const genBroadcaster = async (wallet, { addr: addr } = { addr: 'http://localhost:26657' }) => {
    if (!wallet)
        throw new Error('wallet is required');
    const client = await SigningStargateClient.connectWithSigner(addr, wallet, {
        registry,
        aminoTypes: new AminoTypes(masterAminos)
    });
    const { address } = (await wallet.getAccounts())[0];
    return {
        masterBroadcaster: (msgs, { fee, memo } = { fee: defaultFee, memo: '' }) => client.signAndBroadcast(address, msgs, fee, memo)
    };
};

class QueryFileTree {
    queryClient;
    constructor(rpc) {
        this.queryClient = new QueryClientImpl$a(rpc);
    }
    /** Parameters queries the parameters of the module. */
    async queryParams(request, metadata) {
        return await this.queryClient
            .Params(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [FileTree] queryParams: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    params: {}
                }
            };
        });
    }
    /** Queries a list of Encrypt items. */
    async queryEncrypt(request, metadata) {
        return await this.queryClient
            .Encrypt(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [FileTree] queryEncrypt: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    encryptionData: ''
                }
            };
        });
    }
    /** Queries a list of Decrypt items. */
    async queryDecrypt(request, metadata) {
        return await this.queryClient
            .Decrypt(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [FileTree] queryDecrypt: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    data: ''
                }
            };
        });
    }
    /** Queries a Files by index. */
    async queryFiles(request, metadata) {
        return await this.queryClient
            .Files(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [FileTree] queryFiles: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    files: {
                        address: '',
                        contents: '{}',
                        owner: '',
                        viewingAccess: '{}',
                        editAccess: '{}',
                        trackingNumber: ''
                    }
                }
            };
        });
    }
    /** Queries a list of Files items. */
    async queryFilesAll(request, metadata) {
        return await this.queryClient
            .FilesAll(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [FileTree] queryFilesAll: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    files: [],
                    pagination: { nextKey: new Uint8Array([]), total: 0 }
                }
            };
        });
    }
    /** Queries a Pubkey by index. */
    async queryPubkey(request, metadata) {
        return await this.queryClient
            .Pubkey(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [FileTree] queryPubkey: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    pubkey: {
                        address: '',
                        key: ''
                    }
                }
            };
        });
    }
    /** Queries a list of Pubkey items. */
    async queryPubkeyAll(request, metadata) {
        return await this.queryClient
            .PubkeyAll(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [FileTree] queryPubkeyAll: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    pubkey: [],
                    pagination: { nextKey: new Uint8Array([]), total: 0 }
                }
            };
        });
    }
}

class QueryJklMint {
    queryClient;
    constructor(rpc) {
        this.queryClient = new QueryClientImpl$9(rpc);
    }
    /** Parameters queries the parameters of the module. */
    async queryParams(request, metadata) {
        return await this.queryClient
            .Params(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [JklMint] queryParams: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    params: {
                        mintDenom: ''
                    }
                }
            };
        });
    }
    /** Inflation returns the current minting inflation value. */
    async queryInflation(request, metadata) {
        return await this.queryClient
            .Inflation(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [JklMint] queryInflation: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    inflation: new Uint8Array([])
                }
            };
        });
    }
}

class QueryNotifications {
    queryClient;
    constructor(rpc) {
        this.queryClient = new QueryClientImpl$8(rpc);
    }
    /** Parameters queries the parameters of the module. */
    async queryParams(request, metadata) {
        return await this.queryClient
            .Params(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Notifications] queryParams: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    params: {}
                }
            };
        });
    }
    async queryNotifications(request, metadata) {
        return await this.queryClient
            .Notifications(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Notifications] queryNotifications: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    notifications: {
                        count: 0,
                        notification: '',
                        address: '',
                        sender: ''
                    }
                }
            };
        });
    }
    /** Queries a list of Notifications items. */
    async queryNotificationsAll(request, metadata) {
        return await this.queryClient
            .NotificationsAll(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Notifications] queryNotificationsAll: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    notifications: [],
                    pagination: { nextKey: new Uint8Array([]), total: 0 }
                }
            };
        });
    }
    /** Queries a list of Notifications items by address. */
    async queryNotificationsByAddress(request, metadata) {
        return await this.queryClient
            .NotificationsByAddress(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Notifications] queryNotificationsByAddress: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    notifications: [],
                    pagination: { nextKey: new Uint8Array([]), total: 0 }
                }
            };
        });
    }
    /** Queries a NotiCounter by index. */
    async queryNotiCounter(request, metadata) {
        return await this.queryClient
            .NotiCounter(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Notifications] queryNotiCounter: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    notiCounter: {
                        address: '',
                        counter: 0,
                        blockedSenders: ''
                    }
                }
            };
        });
    }
    /** Queries a list of NotiCounter items. */
    async queryNotiCounterAll(request, metadata) {
        return await this.queryClient
            .NotiCounterAll(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Notifications] queryEncrypt: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    notiCounter: [],
                    pagination: { nextKey: new Uint8Array([]), total: 0 }
                }
            };
        });
    }
}

class QueryOracle {
    queryClient;
    constructor(rpc) {
        this.queryClient = new QueryClientImpl$7(rpc);
    }
    /** Parameters queries the parameters of the module. */
    async queryParams(request, metadata) {
        return await this.queryClient
            .Params(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Oracle] queryParams: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    params: {
                        deposit: ''
                    }
                }
            };
        });
    }
    async queryFeed(request, metadata) {
        return await this.queryClient
            .Feed(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Oracle] queryFeed: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    feed: {
                        owner: '',
                        data: '',
                        lastUpdate: new Date(),
                        name: ''
                    }
                }
            };
        });
    }
    async queryAllFeeds(request, metadata) {
        return await this.queryClient
            .AllFeeds(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Oracle] queryAllFeeds: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    feed: [],
                    pagination: { nextKey: new Uint8Array([]), total: 0 }
                }
            };
        });
    }
}

class QueryRns {
    queryClient;
    constructor(rpc) {
        this.queryClient = new QueryClientImpl$6(rpc);
    }
    /** Parameters queries the parameters of the module. */
    async queryParams(request, metadata) {
        return await this.queryClient
            .Params(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [RNS] queryParams: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    params: {
                        depositAccount: ''
                    }
                }
            };
        });
    }
    /** Queries a Name by index. */
    async queryNames(request, metadata) {
        return await this.queryClient
            .Names(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [RNS] queryNames: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    names: {
                        name: '',
                        expires: 0,
                        value: '',
                        data: '',
                        subdomains: [],
                        tld: '',
                        locked: 0
                    }
                }
            };
        });
    }
    /** Queries a list of Names. */
    async queryNamesAll(request, metadata) {
        return await this.queryClient
            .NamesAll(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [RNS] queryNamesAll: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    names: [],
                    pagination: { nextKey: new Uint8Array([]), total: 0 }
                }
            };
        });
    }
    /** Queries a Bid by index. */
    async queryBids(request, metadata) {
        return await this.queryClient
            .Bids(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [RNS] queryBids: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    bids: {
                        index: '',
                        name: '',
                        bidder: '',
                        price: ''
                    }
                }
            };
        });
    }
    /** Queries a list of Bids. */
    async queryBidsAll(request, metadata) {
        return await this.queryClient
            .BidsAll(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [RNS] queryBidsAll: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    bids: [],
                    pagination: { nextKey: new Uint8Array([]), total: 0 }
                }
            };
        });
    }
    /** Queries a Listing by index. */
    async queryForsale(request, metadata) {
        return await this.queryClient
            .Forsale(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [RNS] queryForsale: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    forsale: {
                        name: '',
                        price: '',
                        owner: ''
                    }
                }
            };
        });
    }
    /** Queries all Listings. */
    async queryForsaleAll(request, metadata) {
        return await this.queryClient
            .ForsaleAll(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [RNS] queryForsaleAll: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    forsale: [],
                    pagination: { nextKey: new Uint8Array([]), total: 0 }
                }
            };
        });
    }
    /** Queries a Init by index. */
    async queryInit(request, metadata) {
        return await this.queryClient
            .Init(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [RNS] queryInit: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    init: false
                }
            };
        });
    }
    /** Queries a list of Init items. */
    async queryInitAll(request, metadata) {
        return await this.queryClient
            .InitAll(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [RNS] queryInitAll: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    init: [],
                    pagination: { nextKey: new Uint8Array([]), total: 0 }
                }
            };
        });
    }
    /** Queries a list of ListOwnedNames items. */
    async queryListOwnedNames(request, metadata) {
        return await this.queryClient
            .ListOwnedNames(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [RNS] queryListOwnedNames: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    names: [],
                    pagination: { nextKey: new Uint8Array([]), total: 0 }
                }
            };
        });
    }
}

/** TODO - Add StoragePaymentInfo in v1.2.5 */
class QueryStorage {
    queryClient;
    constructor(rpc) {
        this.queryClient = new QueryClientImpl$5(rpc);
    }
    /** Parameters queries the parameters of the module. */
    async queryParams(request, metadata) {
        return await this.queryClient
            .Params(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Storage] queryParams: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    params: {
                        depositAccount: '',
                        proofWindow: 0,
                        chunkSize: 0,
                        missesToBurn: 0,
                        priceFeed: '',
                        maxContractAgeInBlocks: 0,
                        pricePerTbPerMonth: 0
                    }
                }
            };
        });
    }
    /** Queries a Contracts by index. */
    async queryContracts(request, metadata) {
        return await this.queryClient
            .Contracts(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Storage] queryContracts: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    contracts: {
                        cid: '',
                        priceamt: '',
                        pricedenom: '',
                        creator: '',
                        merkle: '',
                        signee: '',
                        duration: '',
                        filesize: '',
                        fid: '',
                        age: 0
                    }
                }
            };
        });
    }
    /** Queries a list of Contracts items. */
    async queryContractsAll(request, metadata) {
        return await this.queryClient
            .ContractsAll(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Storage] queryContractsAll: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    contracts: [],
                    pagination: { nextKey: new Uint8Array([]), total: 0 }
                }
            };
        });
    }
    /** Queries a ActiveDeals by index. */
    async queryActiveDeals(request, metadata) {
        return await this.queryClient
            .ActiveDeals(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Storage] queryActiveDeals: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    activeDeals: {
                        cid: '',
                        signee: '',
                        provider: '',
                        startblock: '',
                        endblock: '',
                        filesize: '',
                        proofverified: '',
                        proofsmissed: '',
                        blocktoprove: '',
                        creator: '',
                        merkle: '',
                        fid: ''
                    }
                }
            };
        });
    }
    /** Queries a list of ActiveDeals items. */
    async queryActiveDealsAll(request, metadata) {
        return await this.queryClient
            .ActiveDealsAll(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Storage] queryActiveDealsAll: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    activeDeals: [],
                    pagination: { nextKey: new Uint8Array([]), total: 0 }
                }
            };
        });
    }
    /** Queries a Providers by index. */
    async queryProviders(request, metadata) {
        return await this.queryClient
            .Providers(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Storage] queryProviders: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    providers: {
                        address: '',
                        ip: '',
                        totalspace: '',
                        burnedContracts: '',
                        creator: '',
                        keybaseIdentity: '',
                        authClaimers: []
                    }
                }
            };
        });
    }
    /** Queries a list of Providers items. */
    async queryProvidersAll(request, metadata) {
        return await this.queryClient
            .ProvidersAll(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Storage] queryProvidersAll: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    providers: [],
                    pagination: { nextKey: new Uint8Array([]), total: 0 }
                }
            };
        });
    }
    /** Queries a list of Freespace items. */
    async queryFreespace(request, metadata) {
        return await this.queryClient
            .Freespace(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Storage] queryFreespace: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    space: ''
                }
            };
        });
    }
    /** Queries a list of FindFile items. */
    async queryFindFile(request, metadata) {
        return await this.queryClient
            .FindFile(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Storage] queryFindFile: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    providerIps: ''
                }
            };
        });
    }
    /** Queries a Strays by index. */
    async queryStrays(request, metadata) {
        return await this.queryClient
            .Strays(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Storage] queryStrays: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    strays: {
                        cid: '',
                        fid: '',
                        signee: '',
                        filesize: '',
                        merkle: '',
                        end: 0
                    }
                }
            };
        });
    }
    /** Queries a list of Strays items. */
    async queryStraysAll(request, metadata) {
        return await this.queryClient
            .StraysAll(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Storage] queryStraysAll: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    strays: [],
                    pagination: { nextKey: new Uint8Array([]), total: 0 }
                }
            };
        });
    }
    /** Queries a list of GetClientFreeSpace items. */
    async queryGetClientFreeSpace(request, metadata) {
        return await this.queryClient
            .GetClientFreeSpace(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Storage] queryGetClientFreeSpace: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    bytesfree: 0
                }
            };
        });
    }
    /** Queries a FidCid by index. */
    async queryFidCid(request, metadata) {
        return await this.queryClient
            .FidCid(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Storage] queryFidCid: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    fidCid: {
                        fid: '',
                        cids: '[]'
                    }
                }
            };
        });
    }
    /** Queries a list of FidCid items. */
    async queryFidCidAll(request, metadata) {
        return await this.queryClient
            .FidCidAll(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Storage] queryFidCidAll: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    fidCid: [],
                    pagination: { nextKey: new Uint8Array([]), total: 0 }
                }
            };
        });
    }
    /** Queries a list of GetPayData items. */
    async queryGetPayData(request, metadata) {
        return await this.queryClient
            .GetPayData(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Storage] queryGetPayData: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    timeRemaining: 0,
                    bytes: 0
                }
            };
        });
    }
    /** Queries a StoragePaymentInfo by address. */
    async queryStoragePaymentInfo(request, metadata) {
        return await this.queryClient
            .StoragePaymentInfo(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Storage] queryStoragePaymentInfo: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    storagePaymentInfo: {
                        start: new Date(),
                        end: new Date(),
                        spaceAvailable: 0,
                        spaceUsed: 0,
                        address: ''
                    }
                }
            };
        });
    }
    /** Queries a list of StoragePaymentInfo items. */
    async queryStoragePaymentInfoAll(request, metadata) {
        return await this.queryClient
            .StoragePaymentInfoAll(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Storage] queryStoragePaymentInfoAll: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    storagePaymentInfo: [],
                    pagination: { nextKey: new Uint8Array([]), total: 0 }
                }
            };
        });
    }
    /** Queries whether user can upload a file based on size */
    async queryFileUploadCheck(request, metadata) {
        return await this.queryClient
            .FileUploadCheck(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Storage] queryStoragePaymentInfo: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    valid: false
                }
            };
        });
    }
    /** TODO - Update with correct desc */
    async queryPriceCheck(request, metadata) {
        return await this.queryClient
            .PriceCheck(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Storage] queryPriceCheck: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    price: 0
                }
            };
        });
    }
}

class QueryABCI {
    ABCIApplicationClient;
    constructor(rpc) {
        this.ABCIApplicationClient = new ABCIApplicationClientImpl(rpc);
    }
    /** Returns a message (or echo) */
    async echo(request, metadata) {
        return await this.ABCIApplicationClient.Echo(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [ABCI] echo: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    message: ''
                }
            };
        });
    }
    /** Returns flush  */
    async flush(request, metadata) {
        return await this.ABCIApplicationClient.Flush(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [ABCI] flush: ${err}`);
            return {
                message: '',
                success: false,
                value: {}
            };
        });
    }
    /** Returns the details of a block by requesting versions */
    async info(request, metadata) {
        return await this.ABCIApplicationClient.Info(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [ABCI] info: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    data: '',
                    version: '',
                    appVersion: 0,
                    lastBlockHeight: 0,
                    lastBlockAppHash: new Uint8Array([])
                }
            };
        });
    }
    /** Returns set options */
    async setOption(request, metadata) {
        return await this.ABCIApplicationClient.SetOption(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [ABCI] setOption: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    code: 0,
                    log: '',
                    info: ''
                }
            };
        });
    }
    /** Returns initialization of chains */
    async initChain(request, metadata) {
        return await this.ABCIApplicationClient.InitChain(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [ABCI] initChain: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    consensusParams: undefined,
                    validators: [],
                    appHash: new Uint8Array([])
                }
            };
        });
    }
    /** Returns Returns */
    async query(request, metadata) {
        return await this.ABCIApplicationClient.Query(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [ABCI] query: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    code: 0,
                    log: '',
                    info: '',
                    index: 0,
                    key: new Uint8Array([]),
                    value: new Uint8Array([]),
                    proofOps: undefined,
                    height: 0,
                    codespace: ''
                }
            };
        });
    }
    /** Returns events that begin blocks */
    async beginBlock(request, metadata) {
        return await this.ABCIApplicationClient.BeginBlock(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [ABCI] beginBlock: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    events: []
                }
            };
        });
    }
    /** Returns stuffs that check transactions */
    async checkTx(request, metadata) {
        return await this.ABCIApplicationClient.CheckTx(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [ABCI] checkTx: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    code: 0,
                    data: new Uint8Array([]),
                    log: '',
                    info: '',
                    gasWanted: 0,
                    gasUsed: 0,
                    events: [],
                    codespace: '',
                    sender: '',
                    priority: 0,
                    mempoolError: ''
                }
            };
        });
    }
    /** Returns stuffs that deliver transactions */
    async deliverTx(request, metadata) {
        return await this.ABCIApplicationClient.DeliverTx(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [ABCI] deliverTx: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    code: 0,
                    data: new Uint8Array([]),
                    log: '',
                    info: '',
                    gasWanted: 0,
                    gasUsed: 0,
                    events: [],
                    codespace: '',
                    sender: '',
                    priority: 0,
                    mempoolError: ''
                }
            };
        });
    }
    /** Returns events that end blocks */
    async endBlock(request, metadata) {
        return await this.ABCIApplicationClient.EndBlock(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [ABCI] endBlock: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    validatorUpdates: [],
                    consensusParamUpdates: undefined,
                    events: []
                }
            };
        });
    }
    /** Returns commit data */
    async commit(request, metadata) {
        return await this.ABCIApplicationClient.Commit(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [ABCI] commit: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    data: new Uint8Array([]),
                    retainHeight: 0
                }
            };
        });
    }
    /** Returns a list of snapshots */
    async listSnapshots(request, metadata) {
        return await this.ABCIApplicationClient.ListSnapshots(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [ABCI] listSnapshots: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    snapshots: []
                }
            };
        });
    }
    /** Returns results that offer snapshot */
    async offerSnapshot(request, metadata) {
        return await this.ABCIApplicationClient.OfferSnapshot(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [ABCI] offerSnapshot: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    result: 0
                }
            };
        });
    }
    /** Returns chunks */
    async loadSnapshotChunk(request, metadata) {
        return await this.ABCIApplicationClient.LoadSnapshotChunk(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [ABCI] loadSnapshotChunk: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    chunk: new Uint8Array([])
                }
            };
        });
    }
    /** Returns results that apply snapshot chunks */
    async applySnapshotChunk(request, metadata) {
        return await this.ABCIApplicationClient.ApplySnapshotChunk(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [ABCI] applySnapshotChunk: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    result: 0,
                    refetchChunks: [],
                    rejectSenders: []
                }
            };
        });
    }
}

class QueryBank {
    queryClient;
    constructor(rpc) {
        this.queryClient = new QueryClientImpl$4(rpc);
    }
    /** Balance queries the balance of a single coin for a single account. */
    async queryBalance(request, metadata) {
        return await this.queryClient
            .Balance(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Bank] queryBalance: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    balance: {
                        denom: '',
                        amount: ''
                    }
                }
            };
        });
    }
    /** AllBalances queries the balance of all coins for a single account. */
    async queryAllBalances(request, metadata) {
        return await this.queryClient
            .AllBalances(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Bank] queryAllBalances: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    balances: [],
                    pagination: { nextKey: new Uint8Array([]), total: 0 }
                }
            };
        });
    }
    /**
     * SpendableBalances queries the spenable balance of all coins for a single
     * account.
     */
    async querySpendableBalances(request, metadata) {
        return await this.queryClient
            .SpendableBalances(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Bank] querySpendableBalances: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    balances: [],
                    pagination: { nextKey: new Uint8Array([]), total: 0 }
                }
            };
        });
    }
    /** TotalSupply queries the total supply of all coins. */
    async queryTotalSupply(request, metadata) {
        return await this.queryClient
            .TotalSupply(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Bank] queryTotalSupply: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    supply: [],
                    pagination: { nextKey: new Uint8Array([]), total: 0 }
                }
            };
        });
    }
    /** SupplyOf queries the supply of a single coin. */
    async querySupplyOf(request, metadata) {
        return await this.queryClient
            .SupplyOf(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Bank] querySupplyOf: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    amount: {
                        denom: '',
                        amount: ''
                    }
                }
            };
        });
    }
    /** Params queries the parameters of x/bank module. */
    async queryParams(request, metadata) {
        return await this.queryClient
            .Params(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Bank] queryParams: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    params: {
                        sendEnabled: [],
                        defaultSendEnabled: false
                    }
                }
            };
        });
    }
    /** DenomsMetadata queries the client metadata of a given coin denomination. */
    async queryDenomMetadata(request, metadata) {
        return await this.queryClient
            .DenomMetadata(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Bank] queryDenomMetadata: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    metadata: {
                        description: '',
                        denomUnits: [],
                        base: '',
                        display: '',
                        name: '',
                        symbol: ''
                    }
                }
            };
        });
    }
    /** DenomsMetadata queries the client metadata for all registered coin denominations. */
    async queryDenomsMetadata(request, metadata) {
        return await this.queryClient
            .DenomsMetadata(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Bank] queryDenomsMetadata: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    metadatas: [],
                    pagination: { nextKey: new Uint8Array([]), total: 0 }
                }
            };
        });
    }
}

class QueryDistribution {
    queryClient;
    constructor(rpc) {
        this.queryClient = new QueryClientImpl$3(rpc);
    }
    /** Params queries params of the distribution module. */
    async queryParams(request, metadata) {
        return await this.queryClient
            .Params(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Distribution] queryParams: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    params: {
                        communityTax: '',
                        baseProposerReward: '',
                        bonusProposerReward: '',
                        withdrawAddrEnabled: false
                    }
                }
            };
        });
    }
    /** ValidatorOutstandingRewards queries rewards of a validator address. */
    async queryValidatorOutstandingRewards(request, metadata) {
        return await this.queryClient
            .ValidatorOutstandingRewards(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Distribution] queryValidatorOutstandingRewards: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    rewards: {
                        rewards: []
                    }
                }
            };
        });
    }
    /** ValidatorCommission queries accumulated commission for a validator. */
    async queryValidatorCommission(request, metadata) {
        return await this.queryClient
            .ValidatorCommission(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Distribution] queryValidatorCommission: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    commission: {
                        commission: []
                    }
                }
            };
        });
    }
    /** ValidatorSlashes queries slash events of a validator. */
    async queryValidatorSlashes(request, metadata) {
        return await this.queryClient
            .ValidatorSlashes(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Distribution] queryValidatorSlashes: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    slashes: [],
                    pagination: { nextKey: new Uint8Array([]), total: 0 }
                }
            };
        });
    }
    /** DelegationRewards queries the total rewards accrued by a delegation. */
    async queryDelegationRewards(request, metadata) {
        return await this.queryClient
            .DelegationRewards(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Distribution] queryDelegationRewards: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    rewards: []
                }
            };
        });
    }
    /**
     * DelegationTotalRewards queries the total rewards accrued by a each
     * validator.
     */
    async queryDelegationTotalRewards(request, metadata) {
        return await this.queryClient
            .DelegationTotalRewards(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Distribution] queryDelegationTotalRewards: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    rewards: [],
                    total: []
                }
            };
        });
    }
    /** DelegatorValidators queries the validators of a delegator. */
    async queryDelegatorValidators(request, metadata) {
        return await this.queryClient
            .DelegatorValidators(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Distribution] queryDelegatorValidators: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    validators: []
                }
            };
        });
    }
    /** DelegatorWithdrawAddress queries withdraw address of a delegator. */
    async queryDelegatorWithdrawAddress(request, metadata) {
        return await this.queryClient
            .DelegatorWithdrawAddress(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Distribution] queryDelegatorWithdrawAddress: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    withdrawAddress: ''
                }
            };
        });
    }
    /** CommunityPool queries the community pool coins. */
    async queryCommunityPool(request, metadata) {
        return await this.queryClient
            .CommunityPool(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Distribution] queryCommunityPool: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    pool: []
                }
            };
        });
    }
}

class QueryGov {
    queryClient;
    constructor(rpc) {
        this.queryClient = new QueryClientImpl$2(rpc);
    }
    /** Proposal queries proposal details based on ProposalID. */
    async queryProposal(request, metadata) {
        return await this.queryClient
            .Proposal(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Gov] queryProposal: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    proposal: {
                        proposalId: 0,
                        content: {
                            typeUrl: '',
                            value: new Uint8Array([])
                        },
                        status: -1,
                        finalTallyResult: {
                            yes: '',
                            abstain: '',
                            no: '',
                            noWithVeto: ''
                        },
                        submitTime: new Date(),
                        depositEndTime: new Date(),
                        totalDeposit: [],
                        votingStartTime: new Date(),
                        votingEndTime: new Date()
                    }
                }
            };
        });
    }
    /** Proposals queries all proposals based on given status. */
    async queryProposals(request, metadata) {
        return await this.queryClient
            .Proposals(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Gov] queryProposals: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    proposals: [],
                    pagination: { nextKey: new Uint8Array([]), total: 0 }
                }
            };
        });
    }
    /** Vote queries voted information based on proposalID, voterAddr. */
    async queryVote(request, metadata) {
        return await this.queryClient
            .Vote(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Gov] queryVote: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    vote: {
                        proposalId: 0,
                        voter: '',
                        option: -1,
                        options: []
                    }
                }
            };
        });
    }
    /** Votes queries votes of a given proposal. */
    async queryVotes(request, metadata) {
        return await this.queryClient
            .Votes(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Gov] queryVotes: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    votes: [],
                    pagination: { nextKey: new Uint8Array([]), total: 0 }
                }
            };
        });
    }
    /** Params queries all parameters of the gov module. */
    async queryParams(request, metadata) {
        return await this.queryClient
            .Params(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Gov] queryParams: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    depositParams: {
                        minDeposit: [],
                        maxDepositPeriod: {
                            seconds: 0,
                            nanos: 0
                        }
                    },
                    tallyParams: {
                        quorum: new Uint8Array([]),
                        threshold: new Uint8Array([]),
                        vetoThreshold: new Uint8Array([])
                    },
                    votingParams: {
                        votingPeriod: {
                            seconds: 0,
                            nanos: 0
                        }
                    }
                }
            };
        });
    }
    /** Deposit queries single deposit information based proposalID, depositAddr. */
    async queryDeposit(request, metadata) {
        return await this.queryClient
            .Deposit(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Gov] queryDeposit: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    deposit: {
                        proposalId: 0,
                        depositor: '',
                        amount: []
                    }
                }
            };
        });
    }
    /** Deposits queries all deposits of a single proposal. */
    async queryDeposits(request, metadata) {
        return await this.queryClient
            .Deposits(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Gov] queryDeposits: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    deposits: [],
                    pagination: { nextKey: new Uint8Array([]), total: 0 }
                }
            };
        });
    }
    /** TallyResult queries the tally of a proposal vote. */
    async queryTallyResult(request, metadata) {
        return await this.queryClient
            .TallyResult(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Gov] queryTallyResult: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    tally: {
                        yes: '',
                        abstain: '',
                        no: '',
                        noWithVeto: ''
                    }
                }
            };
        });
    }
}

class QuerySlashing {
    queryClient;
    constructor(rpc) {
        this.queryClient = new QueryClientImpl$1(rpc);
    }
    /** Params queries the parameters of slashing module */
    async queryParams(request, metadata) {
        return await this.queryClient
            .Params(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Slashing] queryParams: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    params: {
                        signedBlocksWindow: 0,
                        minSignedPerWindow: new Uint8Array([]),
                        downtimeJailDuration: {
                            seconds: 0,
                            nanos: 0
                        },
                        slashFractionDoubleSign: new Uint8Array([]),
                        slashFractionDowntime: new Uint8Array([])
                    }
                }
            };
        });
    }
    /** SigningInfo queries the signing info of given cons address */
    async querySigningInfo(request, metadata) {
        return await this.queryClient
            .SigningInfo(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Slashing] querySigningInfo: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    valSigningInfo: {
                        address: '',
                        startHeight: 0,
                        indexOffset: 0,
                        jailedUntil: new Date(),
                        tombstoned: false,
                        missedBlocksCounter: 0
                    }
                }
            };
        });
    }
    /** SigningInfos queries signing info of all validators */
    async querySigningInfos(request, metadata) {
        return await this.queryClient
            .SigningInfos(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Slashing] querySigningInfos: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    info: [],
                    pagination: { nextKey: new Uint8Array([]), total: 0 }
                }
            };
        });
    }
}

class QueryStaking {
    queryClient;
    constructor(rpc) {
        this.queryClient = new QueryClientImpl(rpc);
    }
    /** Validators queries all validators that match the given status. */
    async queryValidators(request, metadata) {
        return await this.queryClient
            .Validators(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Staking] queryValidators: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    validators: [],
                    pagination: { nextKey: new Uint8Array([]), total: 0 }
                }
            };
        });
    }
    /** Validator queries validator info for given validator address. */
    async queryValidator(request, metadata) {
        return await this.queryClient
            .Validator(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Staking] queryValidator: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    validator: {
                        operatorAddress: '',
                        consensusPubkey: {
                            typeUrl: '',
                            value: new Uint8Array([])
                        },
                        jailed: false,
                        status: -1,
                        tokens: '',
                        delegatorShares: '',
                        description: {
                            moniker: '',
                            identity: '',
                            website: '',
                            securityContact: '',
                            details: ''
                        },
                        unbondingHeight: 0,
                        unbondingTime: new Date(),
                        commission: {
                            commissionRates: {
                                rate: '',
                                maxRate: '',
                                maxChangeRate: ''
                            },
                            updateTime: new Date()
                        },
                        minSelfDelegation: ''
                    }
                }
            };
        });
    }
    /** ValidatorDelegations queries delegate info for given validator. */
    async queryValidatorDelegations(request, metadata) {
        return await this.queryClient
            .ValidatorDelegations(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Staking] queryValidatorDelegations: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    delegationResponses: [],
                    pagination: { nextKey: new Uint8Array([]), total: 0 }
                }
            };
        });
    }
    /** ValidatorUnbondingDelegations queries unbonding delegations of a validator. */
    async queryValidatorUnbondingDelegations(request, metadata) {
        return await this.queryClient
            .ValidatorUnbondingDelegations(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Staking] queryValidatorUnbondingDelegations: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    unbondingResponses: [],
                    pagination: { nextKey: new Uint8Array([]), total: 0 }
                }
            };
        });
    }
    /** Delegation queries delegate info for given validator delegator pair. */
    async queryDelegation(request, metadata) {
        return await this.queryClient
            .Delegation(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Staking] queryDelegation: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    delegationResponse: {
                        delegation: {
                            delegatorAddress: '',
                            validatorAddress: '',
                            shares: ''
                        },
                        balance: {
                            denom: '',
                            amount: ''
                        }
                    }
                }
            };
        });
    }
    /**
     * UnbondingDelegation queries unbonding info for given validator delegator
     * pair.
     */
    async queryUnbondingDelegation(request, metadata) {
        return await this.queryClient
            .UnbondingDelegation(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Staking] queryUnbondingDelegation: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    unbond: {
                        delegatorAddress: '',
                        validatorAddress: '',
                        entries: []
                    }
                }
            };
        });
    }
    /** DelegatorDelegations queries all delegations of a given delegator address. */
    async queryDelegatorDelegations(request, metadata) {
        return await this.queryClient
            .DelegatorDelegations(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Staking] queryDelegatorDelegations: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    delegationResponses: [],
                    pagination: { nextKey: new Uint8Array([]), total: 0 }
                }
            };
        });
    }
    /**
     * DelegatorUnbondingDelegations queries all unbonding delegations of a given
     * delegator address.
     */
    async queryDelegatorUnbondingDelegations(request, metadata) {
        return await this.queryClient
            .DelegatorUnbondingDelegations(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Staking] queryDelegatorUnbondingDelegations: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    unbondingResponses: [],
                    pagination: { nextKey: new Uint8Array([]), total: 0 }
                }
            };
        });
    }
    /** Redelegations queries redelegations of given address. */
    async queryRedelegations(request, metadata) {
        return await this.queryClient
            .Redelegations(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Staking] queryRedelegations: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    redelegationResponses: [],
                    pagination: { nextKey: new Uint8Array([]), total: 0 }
                }
            };
        });
    }
    /**
     * DelegatorValidators queries all validators info for given delegator
     * address.
     */
    async queryDelegatorValidators(request, metadata) {
        return await this.queryClient
            .DelegatorValidators(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Staking] queryDelegatorValidators: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    validators: [],
                    pagination: { nextKey: new Uint8Array([]), total: 0 }
                }
            };
        });
    }
    /**
     * DelegatorValidator queries validator info for given delegator validator
     * pair.
     */
    async queryDelegatorValidator(request, metadata) {
        return await this.queryClient
            .DelegatorValidator(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Staking] queryDelegatorValidator: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    validator: {
                        operatorAddress: '',
                        consensusPubkey: {
                            typeUrl: '',
                            value: new Uint8Array([])
                        },
                        jailed: false,
                        status: -1,
                        tokens: '',
                        delegatorShares: '',
                        description: {
                            moniker: '',
                            identity: '',
                            website: '',
                            securityContact: '',
                            details: ''
                        },
                        unbondingHeight: 0,
                        unbondingTime: new Date(),
                        commission: {
                            commissionRates: {
                                rate: '',
                                maxRate: '',
                                maxChangeRate: ''
                            },
                            updateTime: new Date()
                        },
                        minSelfDelegation: ''
                    }
                }
            };
        });
    }
    /** HistoricalInfo queries the historical info for given height. */
    async queryHistoricalInfo(request, metadata) {
        return await this.queryClient
            .HistoricalInfo(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Staking] queryHistoricalInfo: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    hist: {
                        valset: [],
                        header: {
                            version: {
                                block: 0,
                                app: 0
                            },
                            chainId: '',
                            height: 0,
                            time: new Date(),
                            lastBlockId: {
                                hash: new Uint8Array([]),
                                partSetHeader: {
                                    total: 0,
                                    hash: new Uint8Array([])
                                }
                            },
                            lastCommitHash: new Uint8Array([]),
                            dataHash: new Uint8Array([]),
                            validatorsHash: new Uint8Array([]),
                            nextValidatorsHash: new Uint8Array([]),
                            consensusHash: new Uint8Array([]),
                            appHash: new Uint8Array([]),
                            lastResultsHash: new Uint8Array([]),
                            evidenceHash: new Uint8Array([]),
                            proposerAddress: new Uint8Array([])
                        }
                    }
                }
            };
        });
    }
    /** Pool queries the pool info. */
    async queryPool(request, metadata) {
        return await this.queryClient
            .Pool(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Staking] queryPool: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    pool: {
                        notBondedTokens: '',
                        bondedTokens: ''
                    }
                }
            };
        });
    }
    /** Parameters queries the staking parameters. */
    async queryParams(request, metadata) {
        return await this.queryClient
            .Params(request, metadata)
            .then((resp) => {
            return {
                message: '',
                success: true,
                value: resp
            };
        })
            .catch((err) => {
            console.warn(`jackal.js-protos - [Staking] queryParams: ${err}`);
            return {
                message: '',
                success: false,
                value: {
                    params: {
                        unbondingTime: {
                            seconds: 0,
                            nanos: 0
                        },
                        maxValidators: 0,
                        maxEntries: 0,
                        historicalEntries: 0,
                        bondDenom: ''
                    }
                }
            };
        });
    }
}

class QueryBuilder {
    GRpc;
    constructor(queryUrl) {
        const qUrl = queryUrl || 'http://localhost:9091';
        this.GRpc = new GrpcWebImpl$k(qUrl, {
            transport: NodeHttpTransport()
        });
    }
    /** General */
    makeAllQuery() {
        return {
            /** Custom */
            fileTree: this.makeFileTreeQuery(),
            jklMint: this.makeJklMintQuery(),
            notifications: this.makeNotificationsQuery(),
            oracle: this.makeOracleQuery(),
            rns: this.makeRnsQuery(),
            storage: this.makeStorageQuery(),
            /** Static */
            abci: this.makeABCIQuery(),
            bank: this.makeBankQuery(),
            distribution: this.makeDistributionQuery(),
            gov: this.makeGovQuery(),
            slashing: this.makeSlashingQuery(),
            staking: this.makeStakingQuery()
        };
    }
    /** Custom */
    makeFileTreeQuery() {
        return new QueryFileTree(this.GRpc);
    }
    makeJklMintQuery() {
        return new QueryJklMint(this.GRpc);
    }
    makeNotificationsQuery() {
        return new QueryNotifications(this.GRpc);
    }
    makeOracleQuery() {
        return new QueryOracle(this.GRpc);
    }
    makeRnsQuery() {
        return new QueryRns(this.GRpc);
    }
    makeStorageQuery() {
        return new QueryStorage(this.GRpc);
    }
    /** Static */
    makeABCIQuery() {
        return new QueryABCI(this.GRpc);
    }
    makeBankQuery() {
        return new QueryBank(this.GRpc);
    }
    makeDistributionQuery() {
        return new QueryDistribution(this.GRpc);
    }
    makeGovQuery() {
        return new QueryGov(this.GRpc);
    }
    makeSlashingQuery() {
        return new QuerySlashing(this.GRpc);
    }
    makeStakingQuery() {
        return new QueryStaking(this.GRpc);
    }
}
class ProtoBuilder extends QueryBuilder {
    signer;
    txUrl;
    constructor(signer, txUrl, queryUrl) {
        super(queryUrl);
        this.signer = signer;
        this.txUrl = txUrl || 'http://localhost:26657';
    }
    /** General */
    makeMasterBroadcaster() {
        return genBroadcaster(this.signer, { addr: this.txUrl }).catch((err) => {
            throw err;
        });
    }
    makeAllTx() {
        return {
            /** Custom */
            fileTree: this.makeFileTreeTx(),
            jklMint: null,
            notifications: this.makeNotificationsTx(),
            oracle: this.makeOracleTx(),
            rns: this.makeRnsTx(),
            storage: this.makeStorageTx(),
            /** Static */
            bank: this.makeBankTx(),
            distribution: this.makeDistributionTx(),
            gov: this.makeGovTx(),
            slashing: this.makeSlashingTx(),
            staking: this.makeStakingTx()
        };
    }
    /** Custom */
    makeFileTreeTx() {
        return new TxFileTree();
    }
    makeNotificationsTx() {
        return new TxNotifications();
    }
    makeOracleTx() {
        return new TxOracle();
    }
    makeRnsTx() {
        return new TxRns();
    }
    makeStorageTx() {
        return new TxStorage();
    }
    /** Static */
    makeBankTx() {
        return new TxBank();
    }
    makeDistributionTx() {
        return new TxDistribution();
    }
    makeGovTx() {
        return new TxGov();
    }
    makeSlashingTx() {
        return new TxSlashing();
    }
    makeStakingTx() {
        return new TxStaking();
    }
}

var IProtoBuilder = /*#__PURE__*/Object.freeze({
    __proto__: null
});

var IQueryBuilder = /*#__PURE__*/Object.freeze({
    __proto__: null
});

export { ABCIApplicationApplySnapshotChunkDesc, ABCIApplicationBeginBlockDesc, ABCIApplicationCheckTxDesc, ABCIApplicationClientImpl, ABCIApplicationCommitDesc, ABCIApplicationDeliverTxDesc, ABCIApplicationDesc, ABCIApplicationEchoDesc, ABCIApplicationEndBlockDesc, ABCIApplicationFlushDesc, ABCIApplicationInfoDesc, ABCIApplicationInitChainDesc, ABCIApplicationListSnapshotsDesc, ABCIApplicationLoadSnapshotChunkDesc, ABCIApplicationOfferSnapshotDesc, ABCIApplicationQueryDesc, ABCIApplicationSetOptionDesc, BlockParams, CheckTxType, ConsensusParams, Contracts, Event, EventAttribute, Evidence, EvidenceType, FidCid, Files, GrpcWebError$f as GrpcWebError, GrpcWebImpl$f as GrpcWebImpl, IProtoBuilder, IQueryBuilder, LastCommitInfo, NotiCounter, Notifications, PageResponse, ProposalStatus, ProtoBuilder, Pubkey, QueryAllNotiCounterResponse, QueryAllNotificationsByAddressResponse, QueryAllNotificationsResponse, QueryBuilder, QueryFileResponse, QueryFindFileResponse, QueryGetNotiCounterResponse, QueryGetNotificationsResponse, Request, RequestApplySnapshotChunk, RequestBeginBlock, RequestCheckTx, RequestCommit, RequestDeliverTx, RequestEcho, RequestEndBlock, RequestFlush, RequestInfo, RequestInitChain, RequestListSnapshots, RequestLoadSnapshotChunk, RequestOfferSnapshot, RequestQuery, RequestSetOption, Response, ResponseApplySnapshotChunk, ResponseApplySnapshotChunk_Result, ResponseBeginBlock, ResponseCheckTx, ResponseCommit, ResponseDeliverTx, ResponseEcho, ResponseEndBlock, ResponseException, ResponseFlush, ResponseInfo, ResponseInitChain, ResponseListSnapshots, ResponseLoadSnapshotChunk, ResponseOfferSnapshot, ResponseOfferSnapshot_Result, ResponseQuery, ResponseSetOption, Snapshot, Strays, TxBank, TxDistribution, TxFileTree, TxGov, TxNotifications, TxOracle, TxResult, TxRns, TxSlashing, TxStaking, TxStorage, Validator$1 as Validator, ValidatorUpdate, VoteInfo, checkTxTypeFromJSON, checkTxTypeToJSON, evidenceTypeFromJSON, evidenceTypeToJSON, genBroadcaster, protobufPackage$m as protobufPackage, responseApplySnapshotChunk_ResultFromJSON, responseApplySnapshotChunk_ResultToJSON, responseOfferSnapshot_ResultFromJSON, responseOfferSnapshot_ResultToJSON };
