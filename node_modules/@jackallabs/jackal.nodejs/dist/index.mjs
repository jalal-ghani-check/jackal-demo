import { Secp256k1HdWallet } from '@cosmjs/amino';
import { DirectSecp256k1HdWallet, isOfflineDirectSigner } from '@cosmjs/proto-signing';
import { Buffer as Buffer$1, Blob } from 'node:buffer';
import { webcrypto, getRandomValues, randomUUID } from 'node:crypto';
import { encrypt, decrypt, PrivateKey } from 'eciesjs';
import { QueryBuilder, ProtoBuilder } from '@jackallabs/jackal.nodejs-protos';

class AbciHandler {
    qH;
    constructor(wallet) {
        this.qH = wallet.getQueryHandler();
    }
    static async trackAbci(wallet) {
        return new AbciHandler(wallet);
    }
    async getEcho(message) {
        return (await this.qH.ABCIQuery.echo({ message })).value.message || '';
    }
    async getBlockInfo(versions) {
        return (await this.qH.ABCIQuery.info(versions)).value;
    }
    async setOptionByKeyValue(key, value) {
        return (await this.qH.ABCIQuery.setOption({ key, value })).value;
    }
    async initializeChain(object) {
        return (await this.qH.ABCIQuery.initChain(object)).value;
    }
    async getQuery(object) {
        return (await this.qH.ABCIQuery.query(object)).value;
    }
    async getBeginBlock(object) {
        return (await this.qH.ABCIQuery.beginBlock(object)).value;
    }
    async getCheckTx(tx, type) {
        return (await this.qH.ABCIQuery.checkTx({ tx, type })).value;
    }
    async getDeliverTx(tx) {
        return (await this.qH.ABCIQuery.deliverTx({ tx })).value;
    }
    async getEndBlock(height) {
        return (await this.qH.ABCIQuery.endBlock({ height })).value;
    }
    async getCommit() {
        return (await this.qH.ABCIQuery.commit({})).value;
    }
    async getListSnapshots() {
        return (await this.qH.ABCIQuery.listSnapshots({})).value;
    }
    async getOfferSnapshot(object) {
        return (await this.qH.ABCIQuery.offerSnapshot(object)).value;
    }
    async getSnapshotChunk(height, format, chunk) {
        return ((await this.qH.ABCIQuery.loadSnapshotChunk({ height, format, chunk }))
            .value.chunk || new Uint8Array(0));
    }
    async putSnapshotChunk(index, chunk, sender) {
        return (await this.qH.ABCIQuery.applySnapshotChunk({ index, chunk, sender })).value;
    }
}

class MnemonicWallet {
    directWallet;
    aminoWallet;
    /**
     * Receives properties from create() to instantiate CustomWallet for us in creating WalletHandler instance.
     * @param {OfflineDirectSigner} directWallet
     * @param {OfflineAminoSigner} aminoWallet
     * @private
     */
    constructor(directWallet, aminoWallet) {
        this.directWallet = directWallet;
        this.aminoWallet = aminoWallet;
    }
    /**
     * Async wrapper to create a CustomWallet instance.
     * @param {string} mnemonic - Seed phrase to use to generate the wallet sessions.
     * @returns {Promise<MnemonicWallet>} - Instance of CustomWallet.
     */
    static async create(mnemonic) {
        let directWallet = await DirectSecp256k1HdWallet.fromMnemonic(mnemonic, {
            prefix: 'jkl'
        });
        let aminoWallet = await Secp256k1HdWallet.fromMnemonic(mnemonic, {
            prefix: 'jkl'
        });
        /* Destroy mnemonic */
        mnemonic = '';
        return new MnemonicWallet(directWallet, aminoWallet);
    }
    /**
     * Expose DirectSigner for use in WalletHandler.
     * @returns {Promise<OfflineDirectSigner>}
     */
    async getOfflineSignerAuto() {
        return this.directWallet;
    }
    /**
     * Generate signature used by WalletHandler to create session secret.
     * @param {string} address - Jkl address to use for signature.
     * @param {string} message - Value to use as signature base.
     * @returns {Promise<StdSignature>} - Resulting AminoSignResponse.signature.
     */
    async signArbitrary(address, message) {
        const signed = await this.aminoWallet.signAmino(address, {
            chain_id: '',
            account_number: '0',
            sequence: '0',
            fee: {
                gas: '0',
                amount: []
            },
            msgs: [
                {
                    type: 'sign/MsgSignData',
                    value: {
                        signer: address,
                        data: btoa(message)
                    }
                }
            ],
            memo: ''
        });
        return signed.signature;
    }
}

const defaultTxAddr26657 = 'http://localhost:26657';
const defaultQueryAddr9091 = 'http://localhost:9091';
const jackalMainnetChainId = 'jackal-1';
const keyAlgo = {
    name: 'AES-GCM',
    length: 256
};

/**
 * Hash input using SHA-256, then convert to hex string.
 * @param {string} input - Source string for hashing.
 * @returns {Promise<string>} - Resulting Hex string.
 * @private
 */
async function hashAndHex(input) {
    const algo = 'SHA-256';
    const raw = await webcrypto.subtle.digest(algo, new TextEncoder().encode(input));
    return bufferToHex(new Uint8Array(raw));
}
/**
 * Create a Merkle Hex string.
 * @param {string} path - Hex string to use as base.
 * @param {string} fileName - Raw string that will use hashAndHex() before combining with path.
 * @returns {Promise<string>} - Resulting Merkle Hex string.
 * @private
 */
async function hexFullPath(path, fileName) {
    return await hashAndHex(`${path}${await hashAndHex(fileName)}`);
}
/**
 * Create a Merkle Hex string from a directory path.
 * @param {string} path - Directory path as delimited by slashes "/".
 * @returns {Promise<string>} - Resulting Merkle Hex string.
 * @private
 */
async function merkleMeBro(path) {
    const pathArray = path.split('/');
    let merkle = '';
    for (let i = 0; i < pathArray.length; i++) {
        merkle = await hexFullPath(merkle, pathArray[i]);
    }
    return merkle;
}
/**
 * Converts hashed values into strings.
 * @param {Uint8Array} buf - ArrayBuffy view contained hash results.
 * @returns {string} - Hex string converted from source.
 * @private
 */
function bufferToHex(buf) {
    return buf.reduce((acc, curr) => {
        return acc + hashMap$1[curr];
    }, '');
}
const hashMap$1 = [
    '00',
    '01',
    '02',
    '03',
    '04',
    '05',
    '06',
    '07',
    '08',
    '09',
    '0a',
    '0b',
    '0c',
    '0d',
    '0e',
    '0f',
    '10',
    '11',
    '12',
    '13',
    '14',
    '15',
    '16',
    '17',
    '18',
    '19',
    '1a',
    '1b',
    '1c',
    '1d',
    '1e',
    '1f',
    '20',
    '21',
    '22',
    '23',
    '24',
    '25',
    '26',
    '27',
    '28',
    '29',
    '2a',
    '2b',
    '2c',
    '2d',
    '2e',
    '2f',
    '30',
    '31',
    '32',
    '33',
    '34',
    '35',
    '36',
    '37',
    '38',
    '39',
    '3a',
    '3b',
    '3c',
    '3d',
    '3e',
    '3f',
    '40',
    '41',
    '42',
    '43',
    '44',
    '45',
    '46',
    '47',
    '48',
    '49',
    '4a',
    '4b',
    '4c',
    '4d',
    '4e',
    '4f',
    '50',
    '51',
    '52',
    '53',
    '54',
    '55',
    '56',
    '57',
    '58',
    '59',
    '5a',
    '5b',
    '5c',
    '5d',
    '5e',
    '5f',
    '60',
    '61',
    '62',
    '63',
    '64',
    '65',
    '66',
    '67',
    '68',
    '69',
    '6a',
    '6b',
    '6c',
    '6d',
    '6e',
    '6f',
    '70',
    '71',
    '72',
    '73',
    '74',
    '75',
    '76',
    '77',
    '78',
    '79',
    '7a',
    '7b',
    '7c',
    '7d',
    '7e',
    '7f',
    '80',
    '81',
    '82',
    '83',
    '84',
    '85',
    '86',
    '87',
    '88',
    '89',
    '8a',
    '8b',
    '8c',
    '8d',
    '8e',
    '8f',
    '90',
    '91',
    '92',
    '93',
    '94',
    '95',
    '96',
    '97',
    '98',
    '99',
    '9a',
    '9b',
    '9c',
    '9d',
    '9e',
    '9f',
    'a0',
    'a1',
    'a2',
    'a3',
    'a4',
    'a5',
    'a6',
    'a7',
    'a8',
    'a9',
    'aa',
    'ab',
    'ac',
    'ad',
    'ae',
    'af',
    'b0',
    'b1',
    'b2',
    'b3',
    'b4',
    'b5',
    'b6',
    'b7',
    'b8',
    'b9',
    'ba',
    'bb',
    'bc',
    'bd',
    'be',
    'bf',
    'c0',
    'c1',
    'c2',
    'c3',
    'c4',
    'c5',
    'c6',
    'c7',
    'c8',
    'c9',
    'ca',
    'cb',
    'cc',
    'cd',
    'ce',
    'cf',
    'd0',
    'd1',
    'd2',
    'd3',
    'd4',
    'd5',
    'd6',
    'd7',
    'd8',
    'd9',
    'da',
    'db',
    'dc',
    'dd',
    'de',
    'df',
    'e0',
    'e1',
    'e2',
    'e3',
    'e4',
    'e5',
    'e6',
    'e7',
    'e8',
    'e9',
    'ea',
    'eb',
    'ec',
    'ed',
    'ee',
    'ef',
    'f0',
    'f1',
    'f2',
    'f3',
    'f4',
    'f5',
    'f6',
    'f7',
    'f8',
    'f9',
    'fa',
    'fb',
    'fc',
    'fd',
    'fe',
    'ff'
];

const { subtle } = webcrypto;
/**
 * Convert CryptoKey to storable format (see importJackalKey()).
 * @param {CryptoKey} key - CryptoKey to convert.
 * @returns {Promise<Uint8Array>} - CryptoKey as Uint8Array.
 */
async function exportJackalKey(key) {
    return new Uint8Array(await subtle.exportKey('raw', key));
}
/**
 * Convert stored format to CryptoKey (see exportJackalKey()).
 * @param {Uint8Array} rawExport - Uint8Array to recover to CryptoKey.
 * @returns {Promise<CryptoKey>} - Recovered CryptoKey.
 */
function importJackalKey(rawExport) {
    return subtle.importKey('raw', rawExport, 'AES-GCM', true, [
        'encrypt',
        'decrypt'
    ]);
}
/**
 * Generate a new CryptoKey from scratch. Compatible with AES-256 and exportJackalKey(). Supports encrypt and decrypt.
 * @returns {Promise<CryptoKey>} - Fresh random CryptoKey.
 */
async function genKey() {
    return await subtle.generateKey(keyAlgo, true, ['encrypt', 'decrypt']);
}
/**
 * Generate a new iv from scratch. Compatible with AES-256.
 * @returns {Uint8Array} - Fresh random iv.
 */
function genIv() {
    return getRandomValues(new Uint8Array(16));
}
/**
 * Encrypt or decrypt a NodeJs Buffer using AES-256 (AES-GCM).
 * @param {Buffer} data - Source to encrypt or decrypt.
 * @param {CryptoKey} key - Key to use. Decryption key must match encryption key that was used.
 * @param {Uint8Array} iv - Iv to use. Decryption iv must match encryption iv that was used.
 * @param {"encrypt" | "decrypt"} mode - Toggle between encryption and decryption.
 * @returns {Promise<Buffer>} - Processed result.
 */
async function aesCrypt(data, key, iv, mode) {
    const algo = {
        name: 'AES-GCM',
        iv
    };
    if (data.byteLength < 1) {
        return Buffer$1.from([]);
    }
    else if (mode?.toLowerCase() === 'encrypt') {
        return await subtle
            .encrypt(algo, key, data)
            .then((res) => {
            return Buffer$1.from(res);
        })
            .catch((err) => {
            console.error(`aesCrypt(encrypt) - ${err}`);
            throw err;
        });
    }
    else {
        return await subtle
            .decrypt(algo, key, data)
            .then((res) => {
            return Buffer$1.from(res);
        })
            .catch((err) => {
            console.error(`aesCrypt(decrypt) - ${err}`);
            throw err;
        });
    }
}
/**
 * Encrypts AES iv/CryptoKey set to string using receiver's ECIES public key.
 * @param {IWalletHandler} wallet - Wallet instance for accessing functions.
 * @param {string} pubKey - Receiver's ECIES public key.
 * @param {IAesBundle} aes - AES iv/CryptoKey set to encrypt.
 * @returns {Promise<string>} - Encrypted string with pipe "|" delimiter.
 */
async function aesToString(wallet, pubKey, aes) {
    const theIv = wallet.asymmetricEncrypt(Buffer$1.from(aes.iv), pubKey);
    const key = await exportJackalKey(aes.key);
    const theKey = wallet.asymmetricEncrypt(Buffer$1.from(key), pubKey);
    return `${theIv}|${theKey}`;
}
/**
 * Decrypts AES iv/CryptoKey set from string using owner's ECIES private key.
 * @param {IWalletHandler} wallet - Wallet instance for accessing functions and owner's private key.
 * @param {string} source - String containing encrypted AES iv/CryptoKey set with pipe "|" delimiter.
 * @returns {Promise<IAesBundle>} - Decrypted AES iv/CryptoKey set.
 */
async function stringToAes(wallet, source) {
    if (source.indexOf('|') < 0) {
        throw new Error('stringToAes() : Invalid source string');
    }
    const parts = source.split('|');
    return {
        iv: new Uint8Array(wallet.asymmetricDecrypt(parts[0])),
        key: await importJackalKey(new Uint8Array(wallet.asymmetricDecrypt(parts[1])))
    };
}
/**
 * Converts raw File to Public-mode File.
 * @param {File} workingFile - Source File.
 * @returns {Promise<File>} - Public-mode File.
 */
async function convertToPublicFile(workingFile) {
    const chunkSize = 32 * Math.pow(1024, 2); /** in bytes */
    const details = {
        name: workingFile.name,
        lastModified: workingFile.lastModified,
        type: workingFile.type,
        size: workingFile.size
    };
    const detailsBuf = Buffer$1.from(JSON.stringify(details));
    const publicArray = [
        Buffer$1.from((detailsBuf.length + 16).toString().padStart(8, '0')),
        detailsBuf
    ];
    for (let i = 0; i < workingFile.size; i += chunkSize) {
        const bufChunk = Buffer$1.from(await workingFile.slice(i, i + chunkSize).arrayBuffer());
        publicArray.push(Buffer$1.from((bufChunk.length + 16).toString().padStart(8, '0')), bufChunk);
    }
    const finalName = `${await hashAndHex(details.name + Date.now().toString())}.jkl`;
    const abArray = publicArray.map((el) => el.buffer.slice(el.byteOffset, el.byteOffset + el.byteLength));
    return new File(abArray, finalName, { type: 'text/plain' });
}
/**
 * Converts raw Public-mode NodeJS Buffer to File.
 * @param {Buffer} source - Source raw NodeJS Buffer.
 * @returns {Promise<File>} - Decrypted File.
 */
async function convertFromPublicFile(source) {
    let detailsBuf = Buffer$1.from('');
    const bufParts = [];
    for (let i = 0; i < source.length;) {
        const offset = i + 8;
        const segSize = Number(source.slice(i, offset).toString());
        const last = offset + segSize;
        const segment = source.slice(offset, last);
        if (i === 0) {
            detailsBuf = segment;
        }
        else {
            bufParts.push(segment);
        }
        i = last;
    }
    const details = JSON.parse(detailsBuf.toString());
    const abArray = bufParts.map((el) => el.buffer.slice(el.byteOffset, el.byteOffset + el.byteLength));
    return new File(abArray, details.name, details);
}
/**
 * Converts raw File to encrypted File.
 * @param {File} workingFile - Source File.
 * @param {CryptoKey} key - AES-256 CryptoKey.
 * @param {Uint8Array} iv - AES-256 iv.
 * @returns {Promise<File>} - Encrypted File.
 */
async function convertToEncryptedFile(workingFile, key, iv) {
    const chunkSize = 32 * Math.pow(1024, 2); /** in bytes */
    const details = {
        name: workingFile.name,
        lastModified: workingFile.lastModified,
        type: workingFile.type,
        size: workingFile.size
    };
    const detailsBuf = Buffer$1.from(JSON.stringify(details));
    const encryptedArray = [
        Buffer$1.from((detailsBuf.length + 16).toString().padStart(8, '0')),
        // Buffer.from((detailsBuf.length).toString().padStart(8, '0')),
        await aesCrypt(detailsBuf, key, iv, 'encrypt')
    ];
    for (let i = 0; i < workingFile.size; i += chunkSize) {
        const bufChunk = Buffer$1.from(await workingFile.slice(i, i + chunkSize).arrayBuffer());
        encryptedArray.push(Buffer$1.from((bufChunk.length + 16).toString().padStart(8, '0')), 
        // Buffer.from((bufChunk.length).toString().padStart(8, '0')),
        await aesCrypt(bufChunk, key, iv, 'encrypt'));
    }
    const finalName = `${await hashAndHex(details.name + Date.now().toString())}.jkl`;
    const abArray = encryptedArray.map((el) => el.buffer.slice(el.byteOffset, el.byteOffset + el.byteLength));
    return new File(abArray, finalName, { type: 'text/plain' });
}
/**
 * Converts raw NodeJS Buffer to decrypted File.
 * @param {Buffer} source - Source raw Buffer.
 * @param {CryptoKey} key - AES-256 CryptoKey.
 * @param {Buffer} iv - AES-256 iv.
 * @returns {Promise<File>} - Decrypted File.
 */
async function convertFromEncryptedFile(source, key, iv) {
    let detailsBuf = Buffer$1.from('');
    const bufParts = [];
    for (let i = 0; i < source.length;) {
        const offset = i + 8;
        const segSize = Number(source.slice(i, offset).toString());
        const last = offset + segSize;
        const segment = source.slice(offset, last);
        const dec = await aesCrypt(segment, key, iv, 'decrypt');
        if (i === 0) {
            detailsBuf = dec;
        }
        else {
            bufParts.push(dec);
        }
        i = last;
    }
    const details = JSON.parse(detailsBuf.toString());
    const abArray = bufParts.map((el) => el.buffer.slice(el.byteOffset, el.byteOffset + el.byteLength));
    return new File(abArray, details.name, details);
}
/**
 * Encrypt or decrypt a string using AES-256 (AES-GCM).
 * @param {string} input - Source string to encrypt or decrypt.
 * @param {CryptoKey} key - CryptoKey to use. Decryption CryptoKey must match encryption CryptoKey that was used.
 * @param {Uint8Array} iv - Iv to use. Decryption iv must match encryption iv that was used.
 * @param {"encrypt" | "decrypt"} mode - Toggle between encryption and decryption.
 * @returns {Promise<string>} - Processed result.
 */
async function cryptString(input, key, iv, mode) {
    if (mode === 'encrypt') {
        const result = await aesCrypt(Buffer$1.from(input), key, iv, mode);
        return result.toString('base64');
    }
    else if (mode === 'decrypt') {
        const result = await aesCrypt(Buffer$1.from(input, 'base64'), key, iv, mode);
        return result.toString('utf-8');
    }
    else {
        throw new Error('cryptString() - Invalid Mode!');
    }
}

class PrivateFileDownloadHandler {
    file;
    /**
     * Receives properties from trackFile() to instantiate PrivateFileDownloadHandler.
     * @param {File} file - Downloaded File post-processing
     * @protected
     */
    constructor(file) {
        this.file = file;
    }
    /**
     * Creates PrivateFileDownloadHandler instance.
     * @param {NodeJS Buffer} file - Raw file data direct from download source.
     * @param {CryptoKey} key - AES-256 CryptoKey.
     * @param {Uint8Array} iv - AES-256 iv.
     * @returns {Promise<IFileDownloadHandler>} - FileDownloadHandler instance.
     */
    static async trackFile(file, key, iv) {
        const decryptedFile = await convertFromEncryptedFile(file, key, iv);
        return new PrivateFileDownloadHandler(decryptedFile);
    }
    /**
     * Returns downloaded file in decrypted state.
     * @returns {File}
     */
    receiveBacon() {
        return this.file;
    }
}

/**
 * Notify that function is deprecated and should no longer be used.
 * @param {string} thing - Name of deprecated item. Example: "[ParentContext] functionName()".
 * @param {string} version - First version with deprecated item. Example: "v1.1.1".
 * @param {{aggressive?: boolean, replacement?: string}} opts -
 * Aggressive: TRUE to trigger alert.
 * Replacement: the function name that should be used instead. Example: "replacementFunction()".
 */
function deprecated(thing, version, opts) {
    let notice = `${thing} is deprecated as of: ${version}`;
    if (opts?.replacement) {
        notice += ` - Please use ${opts.replacement} instead`;
    }
    console.error(notice);
    if (opts?.aggressive)
        alert(notice);
}
function getRandomIndex(limit) {
    return Math.floor(Math.random() * Number(limit) || 0);
}
/**
 * Notify that Signer has not been enabled.
 * @param {string} module - Name of parent Module.
 * @param {string} func - Name of function error occured in.
 * @returns {string} - String containing error message.
 */
function signerNotEnabled(module, func) {
    let notice = `[${module}] ${func}() - Signer has not been enabled. Please init ProtoHandler`;
    console.error(notice);
    return notice;
}
/**
 * Sort array of strings in A-Z order.
 * @param {string[]} sortable - Array of string to organize.
 * @returns {string[]} - Array of sorted strings.
 */
function orderStrings(sortable) {
    return sortable.sort((a, b) => {
        const lowerA = a.toLowerCase();
        const lowerB = b.toLowerCase();
        if (lowerA < lowerB) {
            return -1;
        }
        else if (lowerA > lowerB) {
            return 1;
        }
        else {
            return 0;
        }
    });
}
/**
 * Remove all slashes "/".
 * @param {string} value - Starting string.
 * @returns {string} - String without slashes.
 */
function stripper(value) {
    return value.replace(/\/+/g, '');
}
/**
 * Check chain response for insufficient gas.
 * @param response - @cosmjs/stargate DeliverTxResponse.
 */
function checkResults(response) {
    console.dir(response);
    if (response.gasUsed > response.gasWanted) {
        console.log('Out Of Gas');
        alert('Ran out of gas. Please refresh page and try again with fewer items.');
    }
}
/**
 * Round number to whole TB (See numTo3xTB().
 * @param {number | string} base - Accepts number or number-like string.
 * @returns {string} - Whole TB as string for Msg compatibility.
 */
function numToWholeTB(base) {
    return numTo3xTB(Math.floor(Number(base)) || 0);
}
/**
 * Round any number to TB.
 * @param {number | string} base - Accepts number or number-like string.
 * @returns {string} - Total TB as string for Msg compatibility.
 */
function numTo3xTB(base) {
    let final = Math.max(Number(base), 0);
    final *= 1000; /** KB */
    final *= 1000; /** MB */
    final *= 1000; /** GB */
    final *= 1000; /** TB */
    final *= 3; /** Redundancy */
    return final.toString();
}
/**
 * Forces string "null" or "undefined" to their proper types. Needed for handling some responses.
 * @param {string} value - String to check.
 * @returns {string | undefined | null} - Returns null or undefined if string matches, otherwise returns original string.
 */
function bruteForceString(value) {
    switch (value.toLowerCase()) {
        case 'null':
            return null;
        case 'undefined':
            return undefined;
        default:
            return value;
    }
}
/**
 * Cycle through pagination results and merge into single result.
 * @param handler - QueryHandler to use for function source.
 * @param {string} queryTag - Query function to use.
 * @param additionalParams - Non-pagination parameters required by queryTag function.
 * @returns {Promise<any[]>} - Merged pagination results.
 */
async function handlePagination(handler, queryTag, additionalParams) {
    const raw = [];
    let nextPage = new Uint8Array();
    do {
        let data = await handler[queryTag]({
            ...additionalParams,
            pagination: {
                key: nextPage,
                limit: 1000
            }
        });
        raw.push(data.value);
        nextPage = data.value.pagination.nextKey;
    } while (nextPage.length);
    return raw;
}
/**
 * Set a timer.
 * @param {number} duration - Duration of timer in ms.
 * @returns {Promise<void>}
 */
async function setDelay(duration) {
    await new Promise((resolve) => setTimeout(resolve, Number(duration)));
}
/**
 * Converts chain block height to UTC Date using getAverageBlockTime().
 * @param {IBlockTimeOptions} options - Values to use for calculating UTC date.
 * @returns {Promise<Date>} - Date object for future date matching input future chain height.
 */
async function blockToDate(options) {
    if (!options.rpcUrl)
        throw new Error('RPC URL is required!');
    /** Block time in milliseconds */
    const blockTime = await getAverageBlockTime(options.rpcUrl, 20);
    return blockToDateFixed({ ...options, blockTime });
}
/**
 * Converts chain block height to UTC Date using provided block time value.
 * @param {IBlockTimeOptions} options - Values to use for calculating UTC date.
 * @returns {Date} - Date object for future date matching input future chain height.
 */
function blockToDateFixed(options) {
    if (!options.blockTime)
        throw new Error('Block Time is required!');
    const targetHeight = Number(options.targetBlockHeight) || 0;
    const blockDiff = targetHeight - options.currentBlockHeight;
    const diffMs = blockDiff * options.blockTime;
    const now = Date.now();
    return new Date(now + diffMs);
}
/**
 * Fine average block time of recent blocks.
 * @param {string} rpc - RPC node address to query.
 * @param {number} blocks - Number of blocks to use for average.
 * @returns {Promise<number>} - Time in ms per block of submitted window.
 */
async function getAverageBlockTime(rpc, blocks) {
    const latestBlockInfo = await fetch(`${rpc}/block`)
        .then((res) => res.json())
        .catch((err) => {
        console.warn('getAvgBlockTime() latestBlockInfo fetch error:');
        console.error(err);
        return { result: { block: { header: { height: blocks, time: 0 } } } };
    });
    const blockOffset = Number(latestBlockInfo.result.block.header.height - blocks) || 0;
    const pastBlockInfo = await fetch(`${rpc}/block?height=${blockOffset}`)
        .then((res) => res.json())
        .catch((err) => {
        console.warn('getAvgBlockTime() pastBlockInfo fetch error:');
        console.error(err);
        return { result: { block: { header: { time: 0 } } } };
    });
    const latest = Date.parse(latestBlockInfo.result.block.header.time);
    const past = Date.parse(pastBlockInfo.result.block.header.time);
    return Math.round((latest - past) / blocks);
}
/**
 * Converts Uint8Array to string.
 * @param {Uint8Array} buf - Uint8Array to convert.
 * @returns {string} - Converted result.
 */
function uint8ToString(buf) {
    return String.fromCharCode.apply(null, [...buf]);
}
/**
 * Converts string to Uint8Array.
 * @param {string} str - String to convert.
 * @returns {Uint8Array} - Converted result.
 */
function stringToUint8(str) {
    const uintView = new Uint8Array(str.length);
    for (let i = 0; i < str.length; i++) {
        uintView[i] = str.charCodeAt(i);
    }
    return uintView;
}
/**
 * Converts Uint16Array to string.
 * @param {Uint16Array} buf - Uint16Array to convert.
 * @returns {string} - Converted result.
 */
function uint16ToString(buf) {
    return String.fromCharCode.apply(null, [...buf]);
}
/**
 * Converts string to Uint16Array.
 * @param {string} str - String to convert.
 * @returns {Uint16Array} - Converted result.
 */
function stringToUint16(str) {
    const uintView = new Uint16Array(str.length);
    for (let i = 0; i < str.length; i++) {
        uintView[i] = str.codePointAt(i) || 0;
    }
    return uintView;
}
/**
 * Retrieve data from FileTree path.
 * @param {string} rawPath - FileTree path to retrieve from.
 * @param {string} owner - Jkl address of path owner.
 * @param {IQueryHandler} qH - QueryHandler instance.
 * @returns {Promise<IFileResponse>} - Raw query response.
 */
async function getFileTreeData(rawPath, owner, qH) {
    console.log('rawPath');
    console.log(rawPath);
    const hexAddress = await merkleMeBro(rawPath);
    const hexedOwner = await hashAndHex(`o${hexAddress}${await hashAndHex(owner)}`);
    return await qH.fileTreeQuery.queryFiles({
        address: hexAddress,
        ownerAddress: hexedOwner
    });
}
/**
 * Forces Blob-likes to proper Blob.
 * @param {Blob} source - Blob-likes to sanitize.
 * @returns {Promise<Blob>} - Sanitized Blob.
 */
async function standardizeBlob(source) {
    return new Blob([new Uint8Array(await source.arrayBuffer())]);
}
/**
 * Forces array of Blob-likes and ArrayBufferViews to array of Uint8Arrays.
 * @param {any[]} source - Mixed array of Blob-likes and ArrayBufferViews.
 * @returns {Promise<Uint8Array[]>} - Sanitized array of Uint8Arrays.
 */
async function standardizeFileSource(source) {
    const ret = [];
    for (let blob of source) {
        ret.push(new Uint8Array(await blob.arrayBuffer()));
    }
    return ret;
}

class FileDownloadHandler extends PrivateFileDownloadHandler {
    constructor(file) {
        super(file);
    }
    /**
     * Creates FileDownloadHandler instance.
     * @param {NodeJS Buffer} file - Raw file data direct from download source.
     * @param {CryptoKey} key - AES-256 CryptoKey.
     * @param {Uint8Array} iv - AES-256 iv.
     * @returns {Promise<IFileDownloadHandler>} - FileDownloadHandler instance.
     */
    static async trackFile(file, key, iv) {
        deprecated('FileDownloadHandler', '1.0.0', {
            replacement: 'PrivateFileDownloadHandler'
        });
        const decryptedFile = await convertFromEncryptedFile(file, key, iv);
        return new FileDownloadHandler(decryptedFile);
    }
}

class FileUploadHandler {
    file;
    key;
    iv;
    parentPath;
    uuid;
    cid;
    fid;
    isFolder;
    /**
     * Create a FileUploadHandler instance.
     * @param {File} file - File to stage for upload.
     * @param {string} parentPath - Path of folder File will be stored in.
     * @param {string} uuid - Instance UUID.
     * @param {CryptoKey} key - Instance AES key.
     * @param {Uint8Array} iv - Instance AES iv.
     * @private
     */
    constructor(file, parentPath, uuid, key, iv) {
        this.file = file;
        this.key = key;
        this.iv = iv;
        this.parentPath = parentPath;
        this.uuid = uuid;
        this.cid = '';
        this.fid = [];
        this.isFolder = false;
    }
    /**
     * Async wrapper to create a FileUploadHandler instance from a File.
     * @param {File} file - File to stage for uploading.
     * @param {string} parentPath - Path of folder File will be stored in.
     * @returns {Promise<IFileUploadHandler>}
     */
    static async trackFile(file, parentPath) {
        const savedKey = await genKey();
        const savedIv = genIv();
        const uuid = crypto.randomUUID();
        return new FileUploadHandler(file, parentPath, uuid, savedKey, savedIv);
    }
    /**
     * Update instance CID(s) and FID(s).
     * @param {{cid: string, fid: string[]}} idObj - New CID(s) and FID(s).
     */
    setIds(idObj) {
        this.cid = idObj.cid;
        this.fid = idObj.fid;
    }
    /**
     * Update instance UUID.
     * @param {string} uuid - New UUID.
     */
    setUUID(uuid) {
        this.uuid = uuid;
    }
    /**
     * Get instance CID(s) and FID(s).
     * @returns {{fid: string[], cid: string}}
     */
    getIds() {
        return { fid: this.fid, cid: this.cid };
    }
    /**
     * Get instance UUID.
     * @returns {string}
     */
    getUUID() {
        return this.uuid;
    }
    /**
     * Get name of the File.
     * @returns {string}
     */
    getWhoAmI() {
        return this.file.name;
    }
    /**
     * Get path of parent folder.
     * @returns {string}
     */
    getWhereAmI() {
        return this.parentPath;
    }
    /**
     * Convert staged File to encrypted File for upload.
     * @param {IAesBundle} aes - Bundle of encryption details. (Optional)
     * @returns {Promise<File>}
     */
    getForUpload(aes) {
        this.key = aes?.key || this.key;
        this.iv = aes?.iv || this.iv;
        return convertToEncryptedFile(this.file, this.key, this.iv);
    }
    /**
     * Provide staged File for upload without encryption.
     * @returns {File}
     */
    getForPublicUpload() {
        return this.file;
    }
    /**
     * Get instance encryption details.
     * @returns {Promise<IAesBundle>}
     */
    async getEnc() {
        return {
            iv: this.iv,
            key: this.key
        };
    }
    /**
     * Get full merkle string of path to File.
     * @returns {Promise<string>}
     */
    async getFullMerkle() {
        return await hexFullPath(await this.getMerklePath(), this.getWhoAmI());
    }
    /**
     * Get full merkle string of path to parent folder.
     * @returns {Promise<string>}
     */
    getMerklePath() {
        return merkleMeBro(this.parentPath);
    }
    /**
     * Get File metadata.
     * @returns {IFileMeta}
     */
    getMeta() {
        return {
            name: this.file.name,
            lastModified: this.file.lastModified,
            size: this.file.size,
            type: this.file.type
        };
    }
}

/**
 * Save encrypted data to FileTree path.
 * @param {string} toAddress - Jkl address of owner.
 * @param {string} rawPath - Parent path to store to.
 * @param {string} rawTarget - Specific entry to store to.
 * @param {{[p: string]: any}} rawContents - Data object to store.
 * @param {IWalletHandler} walletRef - Wallet instance for accessing functions.
 * @returns {Promise<EncodeObject>} - FileTree msg to save entry.
 */
async function saveFileTreeEntry(toAddress, rawPath, rawTarget, rawContents, walletRef) {
    const aes = {
        iv: genIv(),
        key: await genKey()
    };
    const creator = walletRef.getJackalAddress();
    const account = await hashAndHex(creator);
    const msg = {
        account,
        creator,
        contents: '',
        hashParent: await merkleMeBro(rawPath),
        hashChild: await hashAndHex(rawTarget),
        trackingNumber: randomUUID(),
        editors: '',
        viewers: ''
    };
    msg.contents = await cryptString(JSON.stringify(rawContents), aes.key, aes.iv, 'encrypt');
    const basePerms = {
        num: msg.trackingNumber,
        aes
    };
    const selfPubKey = walletRef.getPubkey();
    const me = {
        ...basePerms,
        pubKey: selfPubKey,
        usr: creator
    };
    msg.editors = JSON.stringify(await makePermsBlock({ base: 'e', ...me }, walletRef));
    if (toAddress === creator) {
        msg.viewers = JSON.stringify(await makePermsBlock({ base: 'v', ...me }, walletRef));
    }
    else {
        const destPubKey = await walletRef.findPubKey(toAddress);
        const them = {
            ...basePerms,
            pubKey: destPubKey,
            usr: toAddress
        };
        msg.viewers = JSON.stringify({
            ...(await makePermsBlock({ base: 'v', ...me }, walletRef)),
            ...(await makePermsBlock({ base: 'v', ...them }, walletRef))
        });
    }
    return buildPostFile(msg, walletRef.getProtoHandler());
}
/**
 * Read encrypted data from FileTree path.
 * @param {string} owner - Jkl address of owner.
 * @param {string} rawPath - Path to stored data.
 * @param {IWalletHandler} walletRef - Wallet instance for accessing functions.
 * @returns {Promise<{[p: string]: any}>} - Stored data object.
 */
async function readFileTreeEntry(owner, rawPath, walletRef) {
    const result = await getFileTreeData(rawPath, owner, walletRef.getQueryHandler());
    if (!result.success) {
        console.warn(`'Share Data Not Found for: ${rawPath}`);
        return {};
    }
    else {
        try {
            const { contents, viewingAccess, trackingNumber } = result.value
                .files;
            const parsedVA = JSON.parse(viewingAccess);
            const viewName = await hashAndHex(`v${trackingNumber}${walletRef.getJackalAddress()}`);
            const keys = await stringToAes(walletRef, parsedVA[viewName]);
            const final = await cryptString(contents, keys.key, keys.iv, 'decrypt').catch((err) => {
                console.error(err);
                return '{}';
            });
            return JSON.parse(final);
        }
        catch (err) {
            throw err;
        }
    }
}
/**
 * Remove FileTree entry from target path.
 * @param {string} rawPath - Path to FileTree entry to remove.
 * @param {IWalletHandler} walletRef
 * @returns {Promise<EncodeObject>}
 */
async function removeFileTreeEntry(rawPath, walletRef) {
    const creator = walletRef.getJackalAddress();
    return walletRef.getProtoHandler().fileTreeTx.msgDeleteFile({
        creator,
        hashPath: await merkleMeBro(rawPath),
        account: await hashAndHex(creator)
    });
}
/** Helpers */
/**
 * Creates properly formatted data block for use in IMsgPartialPostFileBundle.editors and viewers.
 * @param {IPermsParts} parts - All elements needed to build IEditorsViewers.
 * @param {IWalletHandler} walletRef - Wallet instance for accessing functions.
 * @returns {Promise<IEditorsViewers>} - Completed permissions block.
 */
async function makePermsBlock(parts, walletRef) {
    const perms = {};
    const user = await hashAndHex(`${parts.base}${parts.num}${parts.usr}`);
    perms[user] = await aesToString(walletRef, parts.pubKey, parts.aes);
    return perms;
}
/**
 * Map data object to specific order of properties required by PostFile msg.
 * @param {IMsgPartialPostFileBundle} data - Data object to map.
 * @param {IProtoHandler} pH - ProtoHandler instance for accessing msgPostFile function.
 * @returns {Promise<EncodeObject>} - Encoded msgPostFile in correct order.
 */
async function buildPostFile(data, pH) {
    return pH.fileTreeTx.msgPostFile({
        creator: data.creator,
        account: data.account,
        hashParent: data.hashParent,
        hashChild: data.hashChild,
        contents: data.contents,
        editors: data.editors,
        viewers: data.viewers,
        trackingNumber: data.trackingNumber
    });
}

class FolderHandler {
    folderDetails;
    isFolder;
    /**
     * Create a FolderHandler instance.
     * @param {IFolderFrame} folderDetails - Folder metadata.
     * @private
     */
    constructor(folderDetails) {
        this.folderDetails = folderDetails;
        this.isFolder = true;
    }
    /**
     * Async wrapper to create a FolderHandler instance from a FileTree source.
     * @param {IFolderFrame} dirInfo - Folder metadata.
     * @returns {Promise<IFolderHandler>}
     */
    static async trackFolder(dirInfo) {
        return new FolderHandler(dirInfo);
    }
    /**
     * Async wrapper to create a FolderHandler instance for a new folder.
     * @param {IChildDirInfo} dirInfo - Initial Folder details.
     * @returns {Promise<IFolderHandler>}
     */
    static async trackNewFolder(dirInfo) {
        const folderDetails = {
            whoAmI: stripper(dirInfo.myName),
            whereAmI: dirInfo.myParent,
            whoOwnsMe: dirInfo.myOwner,
            dirChildren: [],
            fileChildren: {}
        };
        return new FolderHandler(folderDetails);
    }
    /**
     * Get name of Folder.
     * @returns {string}
     */
    getWhoAmI() {
        return this.folderDetails.whoAmI;
    }
    /**
     * Get parent path of Folder.
     * @returns {string}
     */
    getWhereAmI() {
        return this.folderDetails.whereAmI;
    }
    /**
     * Get Bech32 address of Folder owner.
     * @returns {string}
     */
    getWhoOwnsMe() {
        return this.folderDetails.whoOwnsMe;
    }
    /**
     * Get full Folder path (parent path + Folder name)
     * @returns {string}
     */
    getMyPath() {
        return `${this.getWhereAmI()}/${this.getWhoAmI()}`;
    }
    /**
     * Get full path for target child.
     * @param {string} child
     * @returns {string}
     */
    getMyChildPath(child) {
        return `${this.getMyPath()}/${child}`;
    }
    /**
     * Get full Folder metadata.
     * @returns {IFolderFileFrame}
     */
    getFolderDetails() {
        return this.folderDetails;
    }
    /**
     * Get all direct child folders.
     * @returns {string[]}
     */
    getChildDirs() {
        return this.folderDetails.dirChildren;
    }
    /**
     * Get all direct child files.
     * @returns {{[p: string]: IFileMeta}}
     */
    getChildFiles() {
        return this.folderDetails.fileChildren;
    }
    /**
     * Creates and returns FileTree EncodeObject for saving Folder to network.
     * @param {IWalletHandler} walletRef - WalletHandler instance.
     * @returns {Promise<EncodeObject>}
     */
    async getForFiletree(walletRef) {
        if (!walletRef.traits)
            throw new Error(signerNotEnabled('FolderHandler', 'getForFiletree'));
        return await saveFileTreeEntry(walletRef.getJackalAddress(), this.getWhereAmI(), this.getWhoAmI(), this.folderDetails, walletRef);
    }
    /**
     * Get full merkle string of path to target child.
     * @param {string} child - Name of child Folder or file.
     * @returns {Promise<string>}
     */
    async getChildMerkle(child) {
        return await merkleMeBro(`${this.getWhereAmI()}/${this.getWhoAmI()}/${child}`);
    }
    /**
     * Add direct child Folder(s) to this Folder's metadata.
     * @param {string[]} childNames - Array of names to add as direct child Folders.
     * @param {IWalletHandler} walletRef - WalletHandler instance.
     * @returns {Promise<{encoded: EncodeObject[], existing: string[]}>}
     */
    async addChildDirs(childNames, walletRef) {
        const existing = childNames.filter((name) => this.folderDetails.dirChildren.includes(name));
        const more = childNames.filter((name) => !this.folderDetails.dirChildren.includes(name));
        const handlers = await Promise.all(more.map(async (name) => await FolderHandler.trackNewFolder(this.makeChildDirInfo(name))));
        const encoded = await Promise.all(handlers.map(async (handler) => await handler.getForFiletree(walletRef)));
        if (more.length > 0) {
            this.folderDetails.dirChildren = [
                ...new Set([...this.folderDetails.dirChildren, ...more])
            ];
            encoded.push(await this.getForFiletree(walletRef));
        }
        return { encoded: encoded || [], existing };
    }
    /**
     * Add direct child file(s) to this Folder's metadata.
     * @param {IFileMetaHashMap} newFiles - Map of file metadata using file name as key.
     * @param {IWalletHandler} walletRef - WalletHandler instance.
     * @returns {Promise<EncodeObject>}
     */
    async addChildFileReferences(newFiles, walletRef) {
        this.folderDetails.fileChildren = {
            ...this.folderDetails.fileChildren,
            ...newFiles
        };
        return await this.getForFiletree(walletRef);
    }
    /**
     * Remove direct child Folder(s) from this Folder's metadata.
     * @param {string[]} toRemove - Array of names to remove as direct child Folders.
     * @param {IWalletHandler} walletRef - WalletHandler instance.
     * @returns {Promise<EncodeObject>}
     */
    async removeChildDirReferences(toRemove, walletRef) {
        this.folderDetails.dirChildren = this.folderDetails.dirChildren.filter((saved) => !toRemove.includes(saved));
        return await this.getForFiletree(walletRef);
    }
    /**
     * Remove direct child file(s) from this Folder's metadata.
     * @param {string[]} toRemove - Array of names to remove as direct child files.
     * @param {IWalletHandler} walletRef - WalletHandler instance.
     * @returns {Promise<EncodeObject>}
     */
    async removeChildFileReferences(toRemove, walletRef) {
        for (let i = 0; i < toRemove.length; i++) {
            delete this.folderDetails.fileChildren[toRemove[i]];
        }
        return await this.getForFiletree(walletRef);
    }
    /**
     * Remove direct child Folder(s) and/or file(s) from this Folder's metadata.
     * @param {string[]} dirs - Array of names to remove as direct child Folders.
     * @param {string[]} files - Array of names to remove as direct child files.
     * @param {IWalletHandler} walletRef - WalletHandler instance.
     * @returns {Promise<EncodeObject>}
     */
    async removeChildDirAndFileReferences(dirs, files, walletRef) {
        this.folderDetails.dirChildren = this.folderDetails.dirChildren.filter((saved) => !dirs.includes(saved));
        for (let i = 0; i < files.length; i++) {
            delete this.folderDetails.fileChildren[files[i]];
        }
        return await this.getForFiletree(walletRef);
    }
    /**
     * Generate metadata bundle to create new direct child Folder. For use with FolderHandler.trackNewFolder().
     * @param {string} childName - Name of Folder to create.
     * @returns {IChildDirInfo}
     */
    makeChildDirInfo(childName) {
        const myName = stripper(childName);
        const myParent = `${this.folderDetails.whereAmI}/${this.folderDetails.whoAmI}`;
        const myOwner = this.folderDetails.whoOwnsMe;
        return { myName, myParent, myOwner };
    }
}

class PublicFileDownloadHandler {
    file;
    /**
     * Receives properties from trackFile() to instantiate PublicFileDownloadHandler.
     * @param {File} file - Downloaded File post-processing
     * @protected
     */
    constructor(file) {
        this.file = file;
    }
    /**
     * Creates PublicFileDownloadHandler instance.
     * @param {NodeJS Buffer} file - Raw file data direct from download source.
     * @returns {Promise<IFileDownloadHandler>} - PublicFileDownloadHandler instance.
     */
    static async trackFile(file) {
        const decryptedFile = await convertFromPublicFile(file);
        return new PublicFileDownloadHandler(decryptedFile);
    }
    /**
     * Returns downloaded file in decrypted state.
     * @returns {File}
     */
    receiveBacon() {
        return this.file;
    }
}

class FileIo {
    walletRef;
    qH;
    availableProviders;
    currentProvider;
    /**
     * Receives properties from trackIo() to instantiate FileIo.
     * @param {IWalletHandler} wallet - WalletHandler instance for QueryHandler and ProtoHandler management.
     * @param {IMiner[]} providers - Array of filtered Provider details to cycle through for uploads.
     * @param {IMiner} currentProvider - Starting active upload Provider.
     * @private
     */
    constructor(wallet, providers, currentProvider) {
        this.walletRef = wallet;
        this.qH = wallet.getQueryHandler();
        this.availableProviders = providers;
        this.currentProvider = currentProvider;
    }
    /**
     * Creates FileIo instance.
     * @param {IWalletHandler} wallet - WalletHandler instance.
     * @param {string | string[]} versionFilter - Optional minimum chain version flag. Blocks all Providers if undefined. (Optional)
     * @returns {Promise<FileIo>}
     */
    static async trackIo(wallet, versionFilter) {
        if (!wallet.traits)
            throw new Error(signerNotEnabled('FileIo', 'trackIo'));
        const providers = await verifyProviders(await getProviders(wallet.getQueryHandler()), wallet.traits.chainId, versionFilter);
        const provider = providers[getRandomIndex(providers.length)];
        return new FileIo(wallet, providers, provider);
    }
    /**
     * Fetches and categorizes all providers registered to network.
     * @param {IWalletHandler} wallet - WalletHandler instance.
     * @param {string | string[]} versionFilter - Optional minimum chain version flag. Blocks all Providers if undefined. (Optional)
     * @returns {Promise<IProviderChecks>}
     */
    static async checkProviders(wallet, versionFilter) {
        if (!wallet.traits)
            throw new Error(signerNotEnabled('FileIo', 'checkProviders'));
        const raw = await fetchProviders(wallet.getQueryHandler());
        const filtered = await filterProviders(raw);
        return {
            filtered,
            raw,
            verified: versionFilter
                ? await verifyProviders(filtered, wallet.traits.chainId, versionFilter)
                : filtered
        };
    }
    /**
     * Expose active Provider for uploads.
     * @returns {IMiner}
     */
    getCurrentProvider() {
        return this.currentProvider;
    }
    /**
     * Expose all active Providers available for uploads.
     * @returns {IMiner[]}
     */
    getAvailableProviders() {
        return this.availableProviders;
    }
    /**
     * Set active Provider for uploads.
     * @param {IMiner} toSet
     */
    forceProvider(toSet) {
        this.currentProvider = toSet;
    }
    /**
     * Remove problem Provider from list and select new active Provider.
     * @param {string} exclude - Provider address to exclude.
     * @returns {Promise<void>}
     */
    async clearProblems(exclude) {
        this.availableProviders = this.availableProviders.filter((prov) => prov.ip !== exclude);
        await this.shuffle();
    }
    /**
     * Randomly selects new active Provider from list of active Providers available for uploads.
     * @returns {Promise<void>}
     */
    async shuffle() {
        this.currentProvider =
            this.availableProviders[getRandomIndex(this.availableProviders.length)];
    }
    /**
     * Re-queries network for Providers and randomly selects new active Provider.
     * @returns {Promise<void>}
     */
    async refresh() {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('FileIo', 'refresh'));
        this.availableProviders = await verifyProviders(await getProviders(this.qH), this.walletRef.traits.chainId);
        this.currentProvider =
            this.availableProviders[getRandomIndex(this.availableProviders.length)];
    }
    /**
     * Converts File-based folder(s) to FileTree-based folder(s).
     * @param {string[]} toCheck - Folder paths (without s/) to check and convert.
     * @returns {Promise<void>}
     */
    async migrate(toCheck) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('FileIo', 'migrate'));
        const owner = this.walletRef.getJackalAddress();
        const toMigrate = [];
        const toCreate = [];
        for (let name of toCheck) {
            const data = await readFileTreeEntry(owner, `s/${name}`, this.walletRef).catch((err) => {
                throw err;
            });
            if (data.fids) {
                toMigrate.push(`s/${name}`);
            }
            else if (Object.keys(data).length === 0) {
                toCreate.push(name);
            }
            else {
                /* All Good */
            }
        }
        const readyToBroadcast = [];
        if (toCreate.length > 0) {
            readyToBroadcast.push(...(await this.rawGenerateInitialDirs(null, toCreate)));
        }
        for (let path of toMigrate) {
            readyToBroadcast.push(...(await this.rawConvertFolderType(path)));
        }
        if (readyToBroadcast.length > 0) {
            const memo = ``;
            await this.walletRef
                .getProtoHandler()
                .debugBroadcaster(readyToBroadcast, { memo, step: false });
        }
    }
    /**
     * Create new Subfolder(s) with single shared parent Folder. Wrapper for rawCreateFolders().
     * @param {IFolderHandler} parentDir - Parent Folder instance.
     * @param {string[]} newDirs - Name(s) of Subfolder(s) to create.
     * @returns {Promise<void>}
     */
    async createFolders(parentDir, newDirs) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('FileIo', 'createFolders'));
        const pH = this.walletRef.getProtoHandler();
        const readyToBroadcast = await this.rawCreateFolders(parentDir, newDirs);
        const memo = ``;
        await pH.debugBroadcaster(readyToBroadcast, { memo, step: false });
    }
    /**
     * Creates and returns FileTree EncodeObject instances for external consumption by a signAndBroadcast.
     * @param {IFolderHandler} parentDir - Parent Folder instance.
     * @param {string[]} newDirs - Name(s) of Subfolder(s) to create.
     * @returns {Promise<EncodeObject[]>}
     */
    async rawCreateFolders(parentDir, newDirs) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('FileIo', 'rawCreateFolders'));
        const result = await parentDir.addChildDirs(newDirs, this.walletRef);
        if (result.existing.length > 0) {
            console.log('The following duplicate folder names were ignored: ', result.existing);
        }
        return result.encoded;
    }
    /**
     * Check if base Folders exist and create if not found.
     * @param {string[]} toCheck - Name(s) of base Folder(s) to check.
     * @returns {Promise<number>}
     */
    async verifyFoldersExist(toCheck) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('FileIo', 'verifyFoldersExist'));
        const toCreate = [];
        const owner = this.walletRef.getJackalAddress();
        for (let i = 0; i < toCheck.length; i++) {
            const check = await readFileTreeEntry(owner, `s/${toCheck[i]}`, this.walletRef).catch((err) => {
                console.warn(`verifyFoldersExist() s/${toCheck[i]}`, err);
                throw err;
            });
            if (Object.keys(check).length > 0) {
                console.info(`${toCheck[i]} exists`);
            }
            else {
                console.warn(`${toCheck[i]} does not exist`);
                toCreate.push(toCheck[i]);
            }
        }
        if (toCreate.length) {
            console.log('Creating: ', toCreate);
            await this.generateInitialDirs(null, toCreate);
        }
        return toCreate.length;
    }
    /**
     * Uploads file(s) and queues successes into batches for wallet prompts.
     * @param {IUploadList} sourceHashMap - Map of all files, key is file name.
     * @param {IFolderHandler} parent - Folder the files are being uploaded to.
     * @param {IStaggeredTracker} tracker - External access to completion progress. Not yet implemented.
     * @returns {Promise<void>}
     */
    async staggeredUploadFiles(sourceHashMap, parent, tracker) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('FileIo', 'staggeredUploadFiles'));
        const pH = this.walletRef.getProtoHandler();
        const sourceKeys = Object.keys(sourceHashMap);
        const jackalAddr = this.walletRef.getJackalAddress();
        let queueHashMap = {};
        for (let key of sourceKeys) {
            queueHashMap[key] = false;
        }
        await Promise.any(Object.values(sourceHashMap).map(async (bundle) => {
            const { exists, handler, key, uploadable } = bundle;
            const existing = exists
                ? await prepExistingUpload(handler, jackalAddr, this.walletRef).catch((err) => {
                    console.warn('prepExistingUpload() Failed');
                    console.error(err);
                    throw err;
                })
                : { cfg: null, file: null };
            bundle.data = existing.cfg;
            const prom = await this.tumbleUpload(jackalAddr, existing.file
                || new File(await standardizeFileSource([uploadable]), handler.getWhoAmI())).catch((err) => {
                console.warn('tumbleUpload() Failed');
                console.error(err);
                throw err;
            });
            handler.setIds(prom);
            sourceHashMap[key].handler = handler;
            queueHashMap[key] = true;
            tracker.complete++;
            return 'Done';
        })).catch((err) => {
            console.warn('All Uploads Failed');
            console.error(err);
            alert('All Uploads Failed');
        });
        do {
            await statusCheck(sourceKeys.length, tracker);
            const processingNames = Object.keys(queueHashMap).filter((name) => queueHashMap[name]);
            const processValues = processingNames.map((name) => sourceHashMap[name]);
            if (processingNames.length === 0) {
                // do nothing
            }
            else {
                const fileNames = processValues.reduce((acc, curr) => {
                    acc[curr.handler.getWhoAmI()] = curr.handler.getMeta();
                    return acc;
                }, {});
                const readyToBroadcast = await this.rawAfterUpload(processValues);
                readyToBroadcast.push(await parent.addChildFileReferences(fileNames, this.walletRef));
                const memo = `Processing batch of ${processValues.length} uploads`;
                await pH
                    .debugBroadcaster(readyToBroadcast, { memo, step: false })
                    .catch((err) => {
                    throw err;
                });
                for (let key of processingNames) {
                    delete queueHashMap[key];
                }
            }
        } while (Object.keys(queueHashMap).length > 0);
    }
    /**
     * Saves completed uploads to FileTree.
     * @param {IQueueItemPostUpload[]} ids - Bundle(s) of details on uploaded file(s).
     * @returns {Promise<EncodeObject[]>}
     * @private
     */
    async rawAfterUpload(ids) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('FileIo', 'rawAfterUpload'));
        const pH = this.walletRef.getProtoHandler();
        const creator = this.walletRef.getJackalAddress();
        const needingReset = [];
        const ready = await Promise.all(ids.flatMap(async (item) => {
            const { cid, fid } = item.handler.getIds();
            const common = {
                aes: await item.handler.getEnc(),
                num: randomUUID(),
                pubKey: this.walletRef.getPubkey(),
                usr: this.walletRef.getJackalAddress()
            };
            console.log('rawAfterUpload');
            const msgPostFileBundle = {
                creator,
                account: await hashAndHex(creator),
                hashParent: await item.handler.getMerklePath(),
                hashChild: await hashAndHex(item.handler.getWhoAmI()),
                contents: JSON.stringify({ fids: fid }),
                viewers: JSON.stringify(await makePermsBlock({ base: 'v', ...common }, this.walletRef)),
                editors: JSON.stringify(await makePermsBlock({ base: 'e', ...common }, this.walletRef)),
                trackingNumber: common.num
            };
            if (item.data) {
                msgPostFileBundle.viewers = item.data.viewingAccess;
                msgPostFileBundle.editors = item.data.editAccess;
                msgPostFileBundle.trackingNumber = item.data.trackingNumber;
                const delItem = await this.makeDelete(creator, [
                    `${item.handler.getWhereAmI()}/${item.handler.getWhoAmI()}`
                ]);
                needingReset.push(...delItem);
            }
            const msgPost = await buildPostFile(msgPostFileBundle, pH);
            const msgSign = pH.storageTx.msgSignContract({
                creator,
                cid,
                payOnce: false
            });
            return [msgPost, msgSign];
        }));
        ready.unshift(ready.pop());
        return [...needingReset, ...ready.flat()];
    }
    /**
     * Fetches FileTree data for target Folder and creates Handler instance.
     * @param {string} rawPath - Full path to Folder. Example: s/Node/Pictures.
     * @returns {Promise<IFolderHandler>}
     */
    async downloadFolder(rawPath) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('FileIo', 'downloadFolder'));
        const owner = this.walletRef.getJackalAddress();
        const data = await readFileTreeEntry(owner, rawPath, this.walletRef).catch((err) => {
            throw err;
        });
        if (Object.keys(data).length === 0) {
            console.warn('Folder recovery failed. Rebuilding ', rawPath);
            const parts = rawPath.split('/');
            const child = parts.pop();
            const folderDetails = {
                myName: child,
                myParent: parts.join('/'),
                myOwner: owner
            };
            return await FolderHandler.trackNewFolder(folderDetails);
        }
        else {
            return await FolderHandler.trackFolder(data);
        }
    }
    /**
     * Download File.
     * @param {IDownloadDetails} downloadDetails - Details needed to find file.
     * @param {{track: number}} completion - External access to download progress.
     * @returns {Promise<IFileDownloadHandler>}
     */
    async downloadFile(downloadDetails, completion) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('FileIo', 'downloadFile'));
        const { rawPath, owner } = downloadDetails;
        const { success, value: { files } } = await getFileTreeData(rawPath, owner, this.qH);
        if (!success)
            throw new Error('No Existing File');
        const { contents, editAccess, viewingAccess, trackingNumber } = files;
        let parsedContents;
        try {
            parsedContents = JSON.parse(contents);
        }
        catch (err) {
            console.warn('downloadFile() : ', rawPath);
            console.error(err);
            alert(err);
            parsedContents = { fids: [] };
        }
        const fid = parsedContents.fids[0];
        const fileProviders = verifyFileProviderIps((await this.qH.storageQuery.queryFindFile({ fid })).value);
        if (fileProviders && fileProviders.length) {
            const config = {
                editAccess: JSON.parse(editAccess),
                viewingAccess: JSON.parse(viewingAccess),
                trackingNumber: trackingNumber
            };
            const requester = await hashAndHex(`v${trackingNumber}${this.walletRef.getJackalAddress()}`);
            for (let i = 0; i < fileProviders.length; i++) {
                const url = `${fileProviders[i].replace(/\/+$/, '')}/download/${fid}`;
                try {
                    const resp = await fetch(url);
                    const contentLength = resp.headers.get('Content-Length');
                    if (!resp.body)
                        throw new Error();
                    const reader = resp.body.getReader();
                    let receivedLength = 0;
                    let chunks = [];
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) {
                            break;
                        }
                        chunks.push(...value);
                        receivedLength += value.length;
                        completion.track =
                            Math.floor((receivedLength / Number(contentLength)) * 100) || 1;
                    }
                    const { key, iv } = await stringToAes(this.walletRef, config.viewingAccess[requester]);
                    return await FileDownloadHandler.trackFile(Buffer$1.from(chunks), key, iv);
                }
                catch (err) {
                    const attempt = i + 1;
                    const remaining = fileProviders.length - attempt;
                    console.warn(`File fetch() failed. Attempt #${attempt}. ${remaining} attempts remaining`);
                    console.error(err);
                    console.warn(`Bad file provider url: ${url}`);
                }
            }
            throw new Error('All file fetch() attempts failed!');
        }
        else {
            throw new Error('No available providers!');
        }
    }
    /**
     * Locate and download file using unique FID.
     * @param {string} fid - FID for target File.
     * @param {{track: number}} completion - External access to download progress.
     * @returns {Promise<IFileDownloadHandler>}
     */
    async downloadFileByFid(fid, completion) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('FileIo', 'downloadFileByFid'));
        const fileProviders = verifyFileProviderIps((await this.qH.storageQuery.queryFindFile({ fid })).value);
        if (fileProviders && fileProviders.length) {
            for (let i = 0; i < fileProviders.length; i++) {
                const url = `${fileProviders[i].replace(/\/+$/, '')}/download/${fid}`;
                try {
                    const resp = await fetch(url);
                    const contentLength = resp.headers.get('Content-Length');
                    if (!resp.body)
                        throw new Error();
                    const reader = resp.body.getReader();
                    let receivedLength = 0;
                    let chunks = [];
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) {
                            break;
                        }
                        chunks.push(value);
                        receivedLength += value.length;
                        completion.track =
                            Math.floor((receivedLength / Number(contentLength)) * 100) || 1;
                    }
                    const rawFile = chunks.reduce((acc, curr) => {
                        acc.push(...curr);
                        return acc;
                    }, []);
                    return await PublicFileDownloadHandler.trackFile(Buffer$1.from(rawFile));
                }
                catch (err) {
                    const attempt = i + 1;
                    const remaining = fileProviders.length - attempt;
                    console.warn(`File fetch() failed. Attempt #${attempt}. ${remaining} attempts remaining`);
                    console.error(err);
                    console.warn(`Bad file provider url: ${url}`);
                }
            }
            throw new Error('All file fetch() attempts failed!');
        }
        else {
            throw new Error('No available providers!');
        }
    }
    /**
     * Deletes target Folder(s) and sub folders/files. Wraps rawDeleteTargets().
     * @param {string[]} targets - Target Folder(s) and/or files and children.
     * @param {IFolderHandler} parent - Parent Folder that is NOT being deleted.
     * @returns {Promise<void>}
     */
    async deleteTargets(targets, parent) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('FileIo', 'deleteTargets'));
        const pH = this.walletRef.getProtoHandler();
        const readyToBroadcast = await this.rawDeleteTargets(targets, parent);
        const existingDirs = parent.getChildDirs();
        const existingFiles = parent.getChildFiles();
        const dirs = targets.filter((target) => existingDirs.includes(target));
        const files = targets.filter((target) => Object.keys(existingFiles).includes(target));
        readyToBroadcast.push(await parent.removeChildDirAndFileReferences(dirs, files, this.walletRef));
        const memo = ``;
        await pH.debugBroadcaster(readyToBroadcast, { memo, step: false });
    }
    /**
     * Creates and returns FileTree and Storage EncodeObject instances for external consumption by a signAndBroadcast.
     * @param {string[]} targets - Target Folder(s) and/or files and children.
     * @param {IFolderHandler} parent - Parent Folder that is NOT being deleted.
     * @returns {Promise<EncodeObject[]>}
     */
    async rawDeleteTargets(targets, parent) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('FileIo', 'rawDeleteTargets'));
        const existingDirs = parent.getChildDirs();
        const existingFiles = parent.getChildFiles();
        const dirs = targets.filter((target) => existingDirs.includes(target));
        const files = targets.filter((target) => Object.keys(existingFiles).includes(target));
        const location = `${parent.getWhereAmI()}/${parent.getWhoAmI()}`;
        const encoded = [];
        await Promise.all(dirs.map(async (name) => {
            const rawPath = `${location}/${name}`;
            if (await this.checkFolderIsFileTree(rawPath).catch(() => true)) {
                encoded.push(await removeFileTreeEntry(rawPath, this.walletRef));
            }
            else {
                encoded.push(...(await this.makeDelete(this.walletRef.getJackalAddress(), [
                    rawPath
                ])));
            }
        }));
        await Promise.all(files.map(async (name) => {
            encoded.push(...(await this.makeDelete(this.walletRef.getJackalAddress(), [
                `${location}/${name}`
            ])));
        }));
        for (let dir of dirs) {
            const folder = await this.downloadFolder(`${location}/${dir}`);
            const moreTargets = [
                ...new Set([
                    ...folder.getChildDirs(),
                    ...Object.keys(folder.getChildFiles())
                ])
            ];
            encoded.push(...(await this.rawDeleteTargets(moreTargets, folder)));
        }
        return encoded;
    }
    /**
     * Creates target base Folders and inits storage if provided. Wraps rawGenerateInitialDirs().
     * @param {EncodeObject | null} initMsg - Msg to init storage if needed.
     * @param {string[]} startingDirs - Base Folders to create. (Optional)
     * @returns {Promise<void>}
     */
    async generateInitialDirs(initMsg, startingDirs) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('FileIo', 'generateInitialDirs'));
        const pH = this.walletRef.getProtoHandler();
        const readyToBroadcast = await this.rawGenerateInitialDirs(initMsg, startingDirs);
        const memo = ``;
        await pH
            .debugBroadcaster(readyToBroadcast, { memo, step: false })
            .catch((err) => {
            console.error('generateInitialDirs() -', err);
        });
    }
    /**
     * Creates and returns FileTree EncodeObject instances for external consumption by a signAndBroadcast.
     * @param {EncodeObject | null} initMsg - Msg to init storage if needed.
     * @param {string[]} startingDirs - Base Folders to create. (Optional)
     * @returns {Promise<EncodeObject[]>}
     */
    async rawGenerateInitialDirs(initMsg, startingDirs) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('FileIo', 'rawGenerateInitialDirs'));
        const toGenerate = startingDirs || ['Config', 'Home', 'WWW'];
        const creator = this.walletRef.getJackalAddress();
        const dirMsgs = await Promise.all(toGenerate.map(async (pathName) => {
            return await this.createFileTreeFolderMsg(pathName, 's', creator);
        }));
        const readyToBroadcast = [];
        if (initMsg) {
            readyToBroadcast.push(initMsg);
        }
        readyToBroadcast.push(await this.createRoot(), ...dirMsgs);
        return readyToBroadcast;
    }
    /**
     * Converts File-based Folders to FileTree-based Folders. Wraps rawConvertFolderType().
     * @param {string} rawPath - Full path to the target Folder.
     * @returns {Promise<IFolderHandler>}
     */
    async convertFolderType(rawPath) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('FileIo', 'convertFolderType'));
        const pH = this.walletRef.getProtoHandler();
        const readyToBroadcast = await this.rawConvertFolderType(rawPath);
        const memo = ``;
        await pH
            .debugBroadcaster(readyToBroadcast, { memo, step: false })
            .catch((err) => {
            console.error('convertFolderType() -', err);
        });
        return await this.downloadFolder(rawPath);
    }
    /**
     * Creates and returns FileTree and Storage EncodeObject instances for external consumption by a signAndBroadcast.
     * @param {string} rawPath - Full path to the target Folder.
     * @returns {Promise<EncodeObject[]>}
     */
    async rawConvertFolderType(rawPath) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('FileIo', 'rawConvertFolderType'));
        const base = await this.downloadFolder(rawPath);
        const encoded = [];
        if (await this.checkFolderIsFileTree(rawPath)) {
            // do nothing
        }
        else {
            encoded.push(...(await this.makeDelete(this.walletRef.getJackalAddress(), [
                base.getMyPath()
            ])));
        }
        encoded.push(await base.getForFiletree(this.walletRef));
        for (let dir of base.getChildDirs()) {
            encoded.push(...(await this.rawConvertFolderType(base.getMyChildPath(dir))));
        }
        return encoded;
    }
    /**
     * Determine if a Folder is File or FileTree based.
     * @param {string} rawPath - Full path to the target Folder.
     * @returns {Promise<IFolderHandler | null>} - Returns FolderHandler instance if Folder is FileTree-based.
     */
    async checkFolderIsFileTree(rawPath) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('FileIo', 'checkFolderIsFileTree'));
        const owner = this.walletRef.getJackalAddress();
        try {
            const data = await readFileTreeEntry(owner, rawPath, this.walletRef).catch((err) => {
                throw err;
            });
            return await FolderHandler.trackFolder(data).catch((err) => {
                console.error(err);
                return FolderHandler.trackNewFolder({
                    myName: '',
                    myParent: '',
                    myOwner: ''
                });
            });
        }
        catch (err) {
            console.warn('checkFolderIsFileTree()', err);
            return null;
        }
    }
    /**
     * Generate FolderHandler for target new folder. Used by rawGenerateInitialDirs().
     * @param {string} pathName - Name of Folder.
     * @param {string} parentPath - Full path to parent Folder.
     * @param {string} creator - Bech32 address of owner.
     * @returns {Promise<EncodeObject>}
     * @private
     */
    async createFileTreeFolderMsg(pathName, parentPath, creator) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('FileIo', 'createFileTreeFolderMsg'));
        const folderDetails = {
            myName: stripper(pathName),
            myParent: parentPath,
            myOwner: creator
        };
        const handler = await FolderHandler.trackNewFolder(folderDetails);
        return await handler.getForFiletree(this.walletRef);
    }
    /**
     * Creates and returns FileTree and Storage EncodeObject instances for external consumption by a signAndBroadcast.
     * @param {string} creator - Bech32 address of owner.
     * @param {string[]} targets - Full path to deletion target.
     * @returns {Promise<EncodeObject[]>}
     * @private
     */
    async makeDelete(creator, targets) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('FileIo', 'makeDelete'));
        const pH = this.walletRef.getProtoHandler();
        const readyToDelete = await Promise.all(targets.map(async (rawPath) => {
            const fileTreeResult = (await getFileTreeData(rawPath, creator, this.qH)).value.files;
            let fids;
            try {
                fids = JSON.parse(fileTreeResult.contents).fids;
            }
            catch (err) {
                console.error(`[FileIo] makeDelete()`);
                console.error(err);
                console.warn('Proceeding...');
                fids = [];
            }
            const { cids } = (await this.qH.storageQuery.queryFidCid({ fid: fids[0] })).value.fidCid;
            const linkedCids = JSON.parse(cids);
            const toRemove = await Promise.all(linkedCids.filter(async (cid) => {
                return await matchOwnerToCid(this.qH, cid, creator);
            }));
            const cancelContractsMsgs = toRemove.map((cid) => pH.storageTx.msgCancelContract({ creator, cid }));
            const msgDelFile = pH.fileTreeTx.msgDeleteFile({
                creator,
                hashPath: await merkleMeBro(rawPath),
                account: await hashAndHex(creator)
            });
            return [...cancelContractsMsgs, msgDelFile];
        }));
        return readyToDelete.flat();
    }
    /**
     * Upload Files via Fetch and gracefully rollover to next provider if upload fails.
     * @param {string} sender - Bech32 address of owner.
     * @param {File} file - File to upload.
     * @returns {Promise<IProviderModifiedResponse>}
     * @private
     */
    async tumbleUpload(sender, file) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('FileIo', 'tumbleUpload'));
        while (this.availableProviders.length > 0) {
            const { ip } = this.currentProvider;
            console.log('Current Provider:', ip);
            const url = `${ip.replace(/\/+$/, '')}/upload`;
            try {
                return await doUpload(url, sender, file);
            }
            catch (err) {
                console.warn(err);
                await this.clearProblems(ip);
                continue;
            }
        }
        console.log('Provider Options Exhausted');
        return { fid: [''], cid: '' };
    }
    /**
     * Create s/.
     * @returns {Promise<EncodeObject>}
     * @private
     */
    async createRoot() {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('FileIo', 'createRoot'));
        const pH = this.walletRef.getProtoHandler();
        const common = {
            aes: {
                iv: genIv(),
                key: await genKey()
            },
            num: randomUUID(),
            pubKey: this.walletRef.getPubkey(),
            usr: this.walletRef.getJackalAddress()
        };
        console.log('createRoot');
        return pH.fileTreeTx.msgMakeRootV2({
            creator: this.walletRef.getJackalAddress(),
            editors: JSON.stringify(await makePermsBlock({ base: 'e', ...common }, this.walletRef)),
            viewers: JSON.stringify(await makePermsBlock({ base: 'v', ...common }, this.walletRef)),
            trackingNumber: common.num
        });
    }
}
/** Helpers */
/**
 * Check if File exists on chain and fetch details if so.
 * @param {IFileUploadHandler} data - File to check
 * @param {string} ownerAddr - Bech32 address of owner.
 * @param {IWalletHandler} walletRef - WalletHandler instance.
 * @returns {Promise<{file: File, cfg: IFileConfigRaw}>}
 * @private
 */
async function prepExistingUpload(data, ownerAddr, walletRef) {
    const hexedOwner = await hashAndHex(`o${await data.getFullMerkle()}${await hashAndHex(ownerAddr)}`);
    const fileChainResult = await getFileTreeData(await data.getFullMerkle(), hexedOwner, walletRef.getQueryHandler());
    const typedData = fileChainResult.value.files;
    const editPool = JSON.parse(typedData.editAccess);
    const editor = await hashAndHex(`e${typedData.trackingNumber}${walletRef.getJackalAddress()}`);
    const editorKeys = editPool[editor];
    return {
        cfg: typedData,
        file: await data.getForUpload(await stringToAes(walletRef, editorKeys))
    };
}
/**
 * Process upload to Provider via Fetch.
 * @param {string} url - URL of Provider to upload to.
 * @param {string} sender - Bech32 address of owner.
 * @param {File} file - File to upload.
 * @returns {Promise<IProviderModifiedResponse>}
 * @private
 */
async function doUpload(url, sender, file) {
    const fileFormData = new FormData();
    fileFormData.set('file', file);
    fileFormData.set('sender', sender);
    return await fetch(url, { method: 'POST', body: fileFormData })
        .then((resp) => {
        if (resp.status !== 200)
            throw new Error(`Status Message: ${resp.statusText}`);
        return resp.json();
    })
        .then((resp) => {
        return { fid: [resp.fid], cid: resp.cid };
    })
        .catch((err) => {
        throw err;
    });
}
/**
 * Query for list of all usable Providers.
 * @param {IQueryHandler} qH - QueryHandler instance.
 * @param {number} max - Maximum number of Providers to return.
 * @returns {Promise<IMiner[]>}
 * @private
 */
async function getProviders(qH, max) {
    const rawProviderList = await fetchProviders(qH);
    console.info('Raw Providers');
    console.dir(rawProviderList);
    return filterProviders(rawProviderList, max);
}
/**
 * Query for list of all registered Providers.
 * @param {IQueryHandler} qH - QueryHandler instance.
 * @returns {Promise<IMiner[]>}
 * @private
 */
async function fetchProviders(qH) {
    return (await handlePagination(qH.storageQuery, 'queryProvidersAll', {})).reduce((acc, curr) => {
        acc.push(...curr.providers);
        return acc;
    }, []);
}
/**
 * Filters array of Providers to remove invalid addresses.
 * @param {IMiner[]} rawProviderList - Array from providers to filter.
 * @param {number} max - Maximum number of Providers to return.
 * @returns {Promise<IMiner[]>}
 * @private
 */
async function filterProviders(rawProviderList, max) {
    const disallowList = [
        /example/,
        /sample/,
        /0\.0\.0\.0/,
        /127\.\d{1,3}\.\d{1,3}\.\d{1,3}/,
        /192\.168\.\d{1,3}\.\d{1,3}/,
        /placeholder/
    ];
    const filteredProviders = rawProviderList.filter((provider) => {
        const one = provider.ip.toLowerCase();
        if (one.match('localhost')) {
            return true;
        }
        else {
            return one.startsWith('https') && !disallowList.some((rx) => rx.test(one));
        }
    });
    return filteredProviders.slice(0, Number(max) || 1000);
}
/**
 * Check array of Providers are accessible and operating on correct network.
 * @param {IMiner[]} providers - Array from providers to check.
 * @param {string} chainId - Network id to check against.
 * @param {string | string[]} versionFilter - Provider version(s) to check against.
 * @returns {Promise<IMiner[]>}
 * @private
 */
async function verifyProviders(providers, chainId, versionFilter) {
    const versionArray = [];
    if (versionFilter) {
        console.log(`Checking for provider version(s) : ${versionFilter}`);
        typeof versionFilter === 'string'
            ? versionArray.push(versionFilter)
            : versionArray.push(...versionFilter);
    }
    const preRegExArray = versionArray.map((s) => {
        return s.split('.').slice(0, 2).join('.');
    });
    const verRegEx = new RegExp(`(${preRegExArray.join('|')})\\..+$`);
    const staged = await Promise.all(providers.map(async (provider) => {
        const result = await fetch(`${provider.ip.replace(/\/+$/, '')}/version`, {
            signal: AbortSignal.timeout(1500)
        })
            .then(async (res) => {
            const parsed = await res.json();
            const chainCheck = chainId === undefined || chainId === parsed['chain-id'];
            const verCheck = versionFilter === undefined || verRegEx.test(parsed.version);
            return res.ok && chainCheck && verCheck;
        })
            .catch((err) => {
            console.warn('verifyProviders() Error');
            console.error(err);
            if (err.message.includes('AbortSignal')) {
                alert('AbortSignal.timeout() error! Chromium family version 103+ required!');
            }
            return false;
        });
        return result;
    }));
    const verified = providers.filter((_, index) => staged[index]);
    console.info('Verified Providers');
    console.dir(verified);
    return verified;
}
/**
 * Sanity check FID host Provider addresses.
 * @param {QueryFindFileResponse} resp - FileTree query response to check.
 * @returns {string[] | false}
 * @private
 */
function verifyFileProviderIps(resp) {
    if (!resp) {
        console.error('Invalid resp passed to verifyFileProviderIps()');
        return false;
    }
    if (!resp.providerIps) {
        console.error('Incomplete resp passed to verifyFileProviderIps()');
        return false;
    }
    const brutedString = bruteForceString(resp.providerIps);
    if (!brutedString) {
        console.error('bruteForceString() returned False in verifyFileProviderIps()');
        return false;
    }
    try {
        return JSON.parse(resp.providerIps);
    }
    catch (err) {
        console.error('JSON.parse() failed in verifyFileProviderIps()');
        console.error(err);
        return false;
    }
}
/**
 * Verify Msg creator is owner of File contract.
 * @param {IQueryHandler} qH - QueryHandler instance.
 * @param {string} cid - CID to check against.
 * @param {string} owner - Bech32 address of owner to compare to CID.
 * @returns {Promise<boolean>}
 * @private
 */
async function matchOwnerToCid(qH, cid, owner) {
    const contractsResult = (await qH.storageQuery.queryContracts({ cid })).value
        .contracts;
    if (contractsResult.signee === owner) {
        return true;
    }
    const straysResult = (await qH.storageQuery.queryStrays({ cid })).value
        .strays;
    return straysResult.signee === owner;
}
/**
 * Timer used by staggeredUploadFiles() to manage queues.
 * @param {number} target - Total to process.
 * @param {IStaggeredTracker} tracker - Current completed.
 * @returns {Promise<void>}
 * @private
 */
async function statusCheck(target, tracker) {
    await new Promise(async (resolve) => {
        for (tracker.timer = 120; tracker.timer > 0; tracker.timer--) {
            if (tracker.complete === target) {
                resolve();
            }
            else {
                await setDelay(500);
            }
        }
        resolve();
    });
}

class GovHandler {
    walletRef;
    qH;
    /**
     * Create a GovHandler instance.
     * @param {IWalletHandler} wallet - Instance of WalletHandler.
     * @private
     */
    constructor(wallet) {
        this.walletRef = wallet;
        this.qH = wallet.getQueryHandler();
    }
    /**
     * Async wrapper to create a GovHandler instance.
     * @param {IWalletHandler} wallet - Instance of WalletHandler.
     * @returns {Promise<IGovHandler>} - Instance of GovHandler.
     */
    static async trackGov(wallet) {
        return new GovHandler(wallet);
    }
    /** Staking Queries */
    /**
     * Query all individual rewards for all delegators on all validators.
     * @returns {Promise<IDelegationRewards>}
     */
    async getTotalRewards() {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('GovHandler', 'getTotalRewards'));
        const ret = await this.qH.distributionQuery.queryDelegationTotalRewards({
            delegatorAddress: this.walletRef.getJackalAddress()
        });
        return ret.value;
    }
    /**
     * Query total rewards for all delegators on all validators.
     * @returns {Promise<number>}
     */
    async getCondensedTotalRewards() {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('GovHandler', 'getCondensedTotalRewards'));
        const ret = await this.qH.distributionQuery.queryDelegationTotalRewards({
            delegatorAddress: this.walletRef.getJackalAddress()
        });
        return ret.value.total.reduce((acc, coin) => {
            acc += Number(coin.amount);
            return acc;
        }, 0);
    }
    /**
     * Query all individual rewards for all delegators on target validator.
     * @param {string} validatorAddress - Bech32 address of validator.
     * @returns {Promise<ICoin[]>}
     */
    async getRewards(validatorAddress) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('GovHandler', 'getRewards'));
        const ret = await this.qH.distributionQuery.queryDelegationRewards({
            delegatorAddress: this.walletRef.getJackalAddress(),
            validatorAddress
        });
        return ret.value.rewards;
    }
    /**
     * Query total rewards for all delegators on target validator.
     * @param {string} validatorAddress - Bech32 address of validator.
     * @returns {Promise<number>}
     */
    async getCondensedRewards(validatorAddress) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('GovHandler', 'getCondensedRewards'));
        const ret = await this.qH.distributionQuery.queryDelegationRewards({
            delegatorAddress: this.walletRef.getJackalAddress(),
            validatorAddress
        });
        return ret.value.rewards.reduce((acc, coin) => {
            acc += fixRewardsOffset(coin.amount);
            return acc;
        }, 0);
    }
    /**
     * Query total $JKL staked for target delegator on all validators.
     * @returns {Promise<number>}
     */
    async getTotalStaked() {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('GovHandler', 'getTotalStaked'));
        const delegations = (await this.qH.stakingQuery.queryDelegatorDelegations({
            delegatorAddr: this.walletRef.getJackalAddress()
        })).value.delegationResponses;
        return delegations.reduce((acc, del) => {
            acc += Math.round(Number(del.balance.amount));
            return acc;
        }, 0);
    }
    /**
     * Query $JKL staked for target delegator on all validators as map of validator Bech32 addresses.
     * @returns {Promise<IDelegationSummaryMap>}
     */
    async getStakedMap() {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('GovHandler', 'getStakedMap'));
        const delegations = (await this.qH.stakingQuery.queryDelegatorDelegations({
            delegatorAddr: this.walletRef.getJackalAddress()
        })).value.delegationResponses;
        return delegations.reduce((acc, del) => {
            acc[del.delegation.validatorAddress] = del;
            return acc;
        }, {});
    }
    /**
     * Query details for only validators user delegates to and amount delegated.
     * @returns {Promise<IStakingValidatorStakedMap>}
     */
    async getStakedValidatorDetailsMap() {
        const allVals = await this.getCompleteMergedValidatorDetailsMap();
        const staked = await this.getStakedMap();
        return await includeStaked(allVals, staked, true);
    }
    /**
     * Query details of target validator user is delegated to.
     * @param {string} validatorAddress - Bech32 address of validator.
     * @returns {Promise<IStakingValidator>}
     */
    async getDelegatorValidatorDetails(validatorAddress) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('GovHandler', 'getDelegatorValidatorDetails'));
        const result = (await this.qH.stakingQuery.queryDelegatorValidator({
            delegatorAddr: this.walletRef.getJackalAddress(),
            validatorAddr: validatorAddress
        })).value.validator;
        if (result) {
            return result;
        }
        else {
            throw new Error('No Validator Details Found');
        }
    }
    /**
     * Query details for all validator details user is delegated to.
     * @returns {Promise<IStakingValidator[]>}
     */
    async getAllDelegatorValidatorDetails() {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('GovHandler', 'getAllDelegatorValidatorDetails'));
        return (await this.qH.stakingQuery.queryDelegatorValidators({
            delegatorAddr: this.walletRef.getJackalAddress()
        })).value.validators;
    }
    /**
     * Query details for all validator details user is delegated to as a Map. Wraps getAllDelegatorValidatorDetails().
     * @returns {Promise<IStakingValidatorMap>}
     */
    async getAllDelegatorValidatorDetailsMap() {
        const vals = await this.getAllDelegatorValidatorDetails();
        return vals.reduce((acc, curr) => {
            acc[curr.operatorAddress] = curr;
            return acc;
        }, {});
    }
    /**
     * Query details of target validator.
     * @param {string} validatorAddress - Bech32 address of validator.
     * @returns {Promise<IStakingValidator>}
     */
    async getValidatorDetails(validatorAddress) {
        const result = (await this.qH.stakingQuery.queryValidator({
            validatorAddr: validatorAddress
        })).value.validator;
        if (result) {
            return result;
        }
        else {
            throw new Error('No Validator Details Found');
        }
    }
    /**
     * Query details for all validators with target status.
     * @param {TValidatorStatus} status - String matching 1 of the 4 TValidatorStatus statuses.
     * @returns {Promise<IStakingValidator[]>}
     */
    async getAllValidatorDetails(status) {
        return (await this.qH.stakingQuery.queryValidators({
            status: validatorStatusMap[status.toUpperCase()]
        })).value.validators;
    }
    /**
     * Query details for all validators with target status as Map. Wraps getAllValidatorDetails().
     * @param {TValidatorStatus} status - String matching 1 of the 4 TValidatorStatus statuses.
     * @returns {Promise<IStakingValidatorMap>}
     */
    async getAllValidatorDetailsMap(status) {
        const vals = await this.getAllValidatorDetails(status);
        return vals.reduce((acc, curr) => {
            acc[curr.operatorAddress] = curr;
            return acc;
        }, {});
    }
    /**
     * Query details for all validators with user delegation and all validators with target status as Map.
     * Wraps getAllDelegatorValidatorDetailsMap() and getAllValidatorDetailsMap().
     * @param {TValidatorStatus} status - String matching 1 of the 4 TValidatorStatus statuses.
     * @returns {Promise<IStakingValidatorExtendedMap>}
     */
    async getMergedValidatorDetailsMap(status) {
        const staked = await this.getAllDelegatorValidatorDetailsMap();
        const allOfStatus = await this.getAllValidatorDetailsMap(status);
        return flagStaked(allOfStatus, staked);
    }
    /**
     * Query details including staking details for all validators with user delegation and all validators with target status as Map.
     * Wraps getAllDelegatorValidatorDetailsMap() and getAllValidatorDetailsMap().
     * @param {TValidatorStatus} status - String matching 1 of the 4 TValidatorStatus statuses.
     * @returns {Promise<IStakingValidatorStakedMap>}
     */
    async getMergedValidatorDetailsStakedMap(status) {
        const staked = await this.getAllDelegatorValidatorDetailsMap();
        const allOfStatus = await this.getAllValidatorDetailsMap(status);
        const flagged = flagStaked(allOfStatus, staked);
        const stakedMap = await this.getStakedMap();
        return await includeStaked(flagged, stakedMap);
    }
    /**
     * Query details including staking details for all validators with user delegation and all validators with an inactive status as Map.
     * Wraps getAllDelegatorValidatorDetailsMap() and getInactiveMergedValidatorDetailsMap().
     * @returns {Promise<IStakingValidatorExtendedMap>}
     */
    async getInactiveMergedValidatorDetailsStakedMap() {
        const staked = await this.getAllDelegatorValidatorDetailsMap();
        const allInactive = await this.getInactiveMergedValidatorDetailsMap();
        const flagged = flagStaked(allInactive, staked);
        const stakedMap = await this.getStakedMap();
        return await includeStaked(flagged, stakedMap);
    }
    /**
     * Query details for all validators with user delegation and all validators with an inactive status as Map.
     * Wraps getAllDelegatorValidatorDetailsMap() and getAllValidatorDetailsMap().
     * @returns {Promise<IStakingValidatorExtendedMap>}
     */
    async getInactiveMergedValidatorDetailsMap() {
        const staked = this.getAllDelegatorValidatorDetailsMap();
        const allUnbonding = this.getAllValidatorDetailsMap('UNBONDING');
        const allUnbonded = this.getAllValidatorDetailsMap('UNBONDED');
        const merged = { ...(await allUnbonding), ...(await allUnbonded) };
        return flagStaked(merged, await staked);
    }
    /**
     * Query details including staking details for all validators as Map.
     * Wraps getAllDelegatorValidatorDetailsMap() and getAllValidatorDetailsMap().
     * @returns {Promise<IStakingValidatorExtendedMap>}
     */
    async getCompleteMergedValidatorDetailsMap() {
        const staked = this.getAllDelegatorValidatorDetailsMap();
        const allUnbonding = this.getAllValidatorDetailsMap('UNBONDING');
        const allUnbonded = this.getAllValidatorDetailsMap('UNBONDED');
        const allActive = this.getAllValidatorDetailsMap('BONDED');
        const merged = {
            ...(await allUnbonding),
            ...(await allUnbonded),
            ...(await allActive)
        };
        return flagStaked(merged, await staked);
    }
    /**
     * Query details including public staking details for all validators as Map. Wraps getAllValidatorDetailsMap().
     * @param {TValidatorStatus} status - String matching 1 of the 4 TValidatorStatus statuses.
     * @returns {Promise<IStakingValidatorStakedMap>}
     */
    async getPublicMergedValidatorDetailsMap(status) {
        const allOfStatus = await this.getAllValidatorDetailsMap(status);
        return await includeStaked(flagStaked(allOfStatus, {}), {});
    }
    /**
     * Query details including public staking details for all inactive status validators as Map. Wraps getAllValidatorDetailsMap().
     * @returns {Promise<IStakingValidatorExtendedMap>}
     */
    async getPublicInactiveMergedValidatorDetailsStakedMap() {
        const allUnbonding = this.getAllValidatorDetailsMap('UNBONDING');
        const allUnbonded = this.getAllValidatorDetailsMap('UNBONDED');
        const merged = { ...(await allUnbonding), ...(await allUnbonded) };
        return flagStaked(merged, {});
    }
    /** End Staking Queries */
    /** Voting Queries */
    /**
     * Query details of target governance proposal.
     * @param {number} proposalId - Index of proposal.
     * @returns {Promise<IPropDetails>}
     */
    async getPropDetails(proposalId) {
        const prop = await this.qH.govQuery.queryProposal({
            proposalId
        });
        return prop.value.proposal;
    }
    /**
     * Query details of all governance proposals with target status.
     * @param {TPropStatus} status - String matching 1 of the 7 TPropStatus statuses.
     * @returns {Promise<IPropDetails[]>}
     */
    async getAllPropDetailsInStatus(status) {
        return (await this.qH.govQuery.queryProposals({
            proposalStatus: propStatusMap[status.toUpperCase()]
        })).value.proposals;
    }
    /**
     * Query details of all governance proposals with target status as Map. Wraps getAllPropDetailsInStatus().
     * @param {TPropStatus} status - String matching 1 of the 7 TPropStatus statuses.
     * @returns {Promise<IPropDetailsMap>}
     */
    async getAllPropDetailsInStatusMap(status) {
        const props = await this.getAllPropDetailsInStatus(status);
        return props.reduce((acc, curr) => {
            acc[curr.proposalId] = curr;
            return acc;
        }, {});
    }
    /**
     * Query details of all governance proposals with a completed status as Map. Wraps getAllPropDetailsInStatus().
     * @returns {Promise<IPropDetailsMap>}
     */
    async getAllCompletedPropDetailsMap() {
        const allPassed = this.getAllPropDetailsInStatusMap('PASSED');
        const allVeto = this.getAllPropDetailsInStatusMap('VETO');
        const allFailed = this.getAllPropDetailsInStatusMap('FAILED');
        return { ...(await allVeto), ...(await allFailed), ...(await allPassed) };
    }
    /** End Voting Queries */
    /** Staking Msgs */
    /**
     * Claim user's staking rewards for target validator.
     * @param {string[]} validatorAddresses - Bech32 address of validator.
     * @returns {Promise<void>}
     */
    async claimDelegatorRewards(validatorAddresses) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('GovHandler', 'claimDelegatorRewards'));
        const pH = this.walletRef.getProtoHandler();
        const msgs = validatorAddresses.map((address) => {
            return pH.distributionTx.msgWithdrawDelegatorReward({
                delegatorAddress: this.walletRef.getJackalAddress(),
                validatorAddress: address
            });
        });
        await pH.debugBroadcaster(msgs, {});
    }
    /**
     * Creates and returns Staking EncodeObject instances for external consumption by a signAndBroadcast.
     * @param {string} validatorAddress - Bech32 address of validator.
     * @param {number | string} amount - Amount to delegate in ujkl.
     * @returns {EncodeObject}
     */
    rawDelegateTokens(validatorAddress, amount) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('GovHandler', 'rawDelegateTokens'));
        const pH = this.walletRef.getProtoHandler();
        return pH.stakingTx.msgDelegate({
            delegatorAddress: this.walletRef.getJackalAddress(),
            validatorAddress,
            amount: {
                denom: 'ujkl',
                amount: amount.toString()
            }
        });
    }
    /**
     * Delegates specified amount of tokens to target validator. Wraps rawDelegateTokens().
     * @param {string} validatorAddress - Bech32 address of validator.
     * @param {number | string} amount - Amount to delegate in ujkl.
     * @returns {Promise<void>}
     */
    async delegateTokens(validatorAddress, amount) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('GovHandler', 'delegateTokens'));
        const pH = this.walletRef.getProtoHandler();
        const msg = this.rawDelegateTokens(validatorAddress, amount);
        await pH.debugBroadcaster([msg], {});
    }
    /**
     * Creates and returns Staking EncodeObject instances for external consumption by a signAndBroadcast.
     * @param {string} validatorAddress - Bech32 address of validator.
     * @param {number | string} amount - Amount to undelegate in ujkl.
     * @returns {EncodeObject}
     */
    rawUndelegateTokens(validatorAddress, amount) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('GovHandler', 'rawUndelegateTokens'));
        const pH = this.walletRef.getProtoHandler();
        return pH.stakingTx.msgUndelegate({
            delegatorAddress: this.walletRef.getJackalAddress(),
            validatorAddress,
            amount: {
                denom: 'ujkl',
                amount: amount.toString()
            }
        });
    }
    /**
     * Undelegates specified amount of tokens from target validator. Wraps rawUndelegateTokens().
     * @param {string} validatorAddress - Bech32 address of validator.
     * @param {number | string} amount - Amount to undelegate in ujkl.
     * @returns {Promise<void>}
     */
    async undelegateTokens(validatorAddress, amount) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('GovHandler', 'undelegateTokens'));
        const pH = this.walletRef.getProtoHandler();
        const msg = this.rawUndelegateTokens(validatorAddress, amount);
        await pH.debugBroadcaster([msg], {});
    }
    /**
     * Creates and returns Staking EncodeObject instances for external consumption by a signAndBroadcast.
     * @param {string} fromAddress - Bech32 address of source validator.
     * @param {string} toAddress - Bech32 address of receiving validator.
     * @param {number | string} amount - Amount to undelegate in ujkl.
     * @returns {EncodeObject}
     */
    rawRedelegateTokens(fromAddress, toAddress, amount) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('GovHandler', 'rawRedelegateTokens'));
        const pH = this.walletRef.getProtoHandler();
        return pH.stakingTx.msgBeginRedelegate({
            delegatorAddress: this.walletRef.getJackalAddress(),
            validatorSrcAddress: fromAddress,
            validatorDstAddress: toAddress,
            amount: {
                denom: 'ujkl',
                amount: amount.toString()
            }
        });
    }
    /**
     * Redelegates specified amount of tokens between target validators. Wraps rawRedelegateTokens().
     * @param {string} fromAddress - Bech32 address of source validator.
     * @param {string} toAddress - Bech32 address of receiving validator.
     * @param {number | string} amount - Amount to undelegate in ujkl.
     * @returns {Promise<void>}
     */
    async redelegateTokens(fromAddress, toAddress, amount) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('GovHandler', 'redelegateTokens'));
        const pH = this.walletRef.getProtoHandler();
        const msg = this.rawRedelegateTokens(fromAddress, toAddress, amount);
        await pH.debugBroadcaster([msg], {});
    }
}
/** Helpers */
const validatorStatusMap = {
    UNSPECIFIED: 'BOND_STATUS_UNSPECIFIED',
    UNBONDED: 'BOND_STATUS_UNBONDED',
    UNBONDING: 'BOND_STATUS_UNBONDING',
    BONDED: 'BOND_STATUS_BONDED'
};
const propStatusMap = {
    UNSPECIFIED: 0,
    DEPOSIT: 1,
    VOTING: 2,
    PASSED: 3,
    VETO: 4,
    FAILED: 5,
    UNRECOGNIZED: -1
};
/**
 * Flags members of the base Map as stakedWith: true if the member is in the staked Map.
 * @param {IStakingValidatorMap} base - Map of validators to check.
 * @param {IStakingValidatorMap} staked - Map of user's staked validators to check against.
 * @returns {IStakingValidatorExtendedMap}
 * @private
 */
function flagStaked(base, staked) {
    const final = {};
    for (let val in base) {
        if (staked[val]) {
            final[val] = { ...base[val], stakedWith: true };
        }
        else {
            final[val] = { ...base[val], stakedWith: false };
        }
    }
    return final;
}
/**
 * Checks members of the flagged Map and includes staking details if the member is in the stakedMap Map.
 * @param {IStakingValidatorExtendedMap} flagged - Map of validators to check.
 * @param {IDelegationSummaryMap} stakedMap - Map of user's staked validators to check against.
 * @param {boolean} ignore - True to discard all flagged members not in stakedMap from results.
 * @returns {Promise<IStakingValidatorStakedMap>}
 * @private
 */
async function includeStaked(flagged, stakedMap, ignore) {
    const final = {};
    for (let val in flagged) {
        if (stakedMap[val]) {
            final[val] = { ...flagged[val], stakedDetails: stakedMap[val] };
        }
        else if (ignore) {
            // do nothing
        }
        else {
            final[val] = { ...flagged[val] };
        }
    }
    return final;
}
/**
 * Adjust staking rewards decimal to match ujkl.
 * @param {string | number} reward - Value to adjust.
 * @returns {number}
 * @private
 */
function fixRewardsOffset(reward) {
    const num = Number(reward) || 0;
    const shifted = num / 10000000000000000; /** 1e+16 */
    return Math.round(shifted) / 100; /** Total Shift 1e+18 */
}

class NotificationHandler {
    walletRef;
    qH;
    /**
     * Create a NotificationHandler instance.
     * @param {IWalletHandler} wallet - Instance of WalletHandler.
     * @private
     */
    constructor(wallet) {
        this.walletRef = wallet;
        this.qH = wallet.getQueryHandler();
    }
    /**
     * Async wrapper to create a NotificationHandler instance.
     * @param {IWalletHandler} wallet - Instance of WalletHandler.
     * @returns {Promise<INotificationHandler>} - Instance of NotificationHandler.
     */
    static async trackNotification(wallet) {
        return new NotificationHandler(wallet);
    }
    /**
     * Create and send Notification to target user.
     * @param {string} notification - Notification content.
     * @param {string} address - Bech32 address of recipient.
     * @returns {EncodeObject}
     */
    makeNotification(notification, address) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('NotificationHandler', 'makeNotification'));
        const pH = this.walletRef.getProtoHandler();
        return pH.notificationsTx.msgCreateNotifications({
            creator: this.walletRef.getJackalAddress(),
            notification,
            address
        });
    }
    /**
     * Modify previously sent Notification. Does not re-notify receiver.
     * @param {number} count - Index of Notification to update.
     * @param {string} notification - New Notification content.
     * @param {string} address - Bech32 address of recipient.
     * @returns {EncodeObject}
     */
    makeNotificationUpdate(count, notification, address) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('NotificationHandler', 'makeNotificationUpdate'));
        const pH = this.walletRef.getProtoHandler();
        return pH.notificationsTx.msgUpdateNotifications({
            creator: this.walletRef.getJackalAddress(),
            count,
            notification,
            address
        });
    }
    /**
     * Deletes all Notifications created by user.
     * @returns {EncodeObject}
     */
    makeNotificationDeletion() {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('NotificationHandler', 'makeNotificationDeletion'));
        const pH = this.walletRef.getProtoHandler();
        return pH.notificationsTx.msgDeleteNotifications({
            creator: this.walletRef.getJackalAddress()
        });
    }
    /**
     * Initializes Notification system for user.
     * @returns {EncodeObject}
     */
    makeCounter() {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('NotificationHandler', 'makeCounter'));
        const pH = this.walletRef.getProtoHandler();
        return pH.notificationsTx.msgSetCounter({
            creator: this.walletRef.getJackalAddress()
        });
    }
    /**
     * Blocks target address from sending Notifications to user.
     * @param {string} sender - Bech32 address to block.
     * @returns {EncodeObject}
     */
    makeBlockedSender(sender) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('NotificationHandler', 'makeBlockedSender'));
        const pH = this.walletRef.getProtoHandler();
        return pH.notificationsTx.msgBlockSenders({
            creator: this.walletRef.getJackalAddress(),
            senderIds: sender
        });
    }
    /**
     * Initializes Notification system for user. Wraps makeCounter().
     * @returns {Promise<void>}
     */
    async broadcastMakeCounter() {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('NotificationHandler', 'broadcastMakeCounter'));
        const msg = this.makeCounter();
        const pH = this.walletRef.getProtoHandler();
        pH.debugBroadcaster([msg], { memo: '', step: false }).catch((err) => {
            console.warn(err);
            throw err;
        });
    }
    /**
     * Get target Notification for target receiver.
     * @param {string} forAddress - Bech32 address of receiver of Notification.
     * @param {number} index - Index of Notification to retrieve.
     * @returns {Promise<QueryGetNotificationsResponse>}
     */
    async getNotification(forAddress, index) {
        return (await this.qH.notificationsQuery.queryNotifications({
            count: index,
            address: forAddress
        })).value;
    }
    /**
     * Get all Notifications.
     * @returns {Promise<QueryAllNotificationsResponse>}
     */
    async getAllNotifications() {
        return (await handlePagination(this.qH.notificationsQuery, 'queryNotificationsAll', {})).reduce((acc, curr) => {
            acc.push(...curr.notifications);
            return acc;
        }, []);
    }
    /**
     * Get all Notifications for target receiver.
     * @param {string} forAddress - Bech32 address of receiver of Notification.
     * @returns {Promise<Notifications[]>}
     */
    async getSingleAddressNotifications(forAddress) {
        return (await handlePagination(this.qH.notificationsQuery, 'queryNotificationsByAddress', { address: forAddress })).reduce((acc, curr) => {
            acc.push(...curr.notifications);
            return acc;
        }, []);
    }
    /**
     * Check if makeCounter() or broadcastMakeCounter() has been run for target address.
     * @param {string} forAddress - Bech32 address to check.
     * @returns {Promise<boolean>}
     */
    async checkNotificationInit(forAddress) {
        return (await this.getBaseNotiCounter(forAddress)).success;
    }
    /**
     * Check Notification count for target address. Wrapper for getBaseNotiCounter().
     * @param {string} forAddress - Bech32 address to check.
     * @returns {Promise<QueryGetNotiCounterResponse>}
     */
    async getNotificationCounter(forAddress) {
        return (await this.getBaseNotiCounter(forAddress)).value;
    }
    /**
     * Check Notification count for all addresses.
     * @returns {Promise<QueryAllNotiCounterResponse>}
     */
    async getAllNotificationCounters() {
        return (await handlePagination(this.qH.notificationsQuery, 'queryNotificationsAll', {})).reduce((acc, curr) => {
            acc.push(...curr.notiCounter);
            return acc;
        }, []);
    }
    /** Standardized Messages */
    /**
     * Standardized general-purpose Notification Msg creator.
     * @param {string} type - Notification identification code.
     * @param {string} address - Bech32 address of Notification target.
     * @returns {Promise<EncodeObject>}
     */
    async makeStandardizedShareNotification(type, address) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('NotificationHandler', 'makeStandardizedShareNotification'));
        const pubKey = await this.walletRef.findPubKey(address);
        const baseNoti = { type };
        const bufNoti = new TextEncoder().encode(JSON.stringify(baseNoti));
        return this.makeNotification(this.walletRef.asymmetricEncrypt(Buffer.from(bufNoti), pubKey), address);
    }
    /**
     * Create sharing added Notification entry. Wraps makeStandardizedShareNotification().
     * @param {string} address - Bech32 address of Notification target.
     * @returns {Promise<EncodeObject>}
     */
    async makeAddShareNoti(address) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('NotificationHandler', 'makeAddShareNoti'));
        return await this.makeStandardizedShareNotification('dbfs-add', address);
    }
    /**
     * Create sharing updated Notification entry. Wraps makeStandardizedShareNotification().
     * @param {string} address - Bech32 address of Notification target.
     * @returns {Promise<EncodeObject>}
     */
    async makeUpdateShareNoti(address) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('NotificationHandler', 'makeUpdateShareNoti'));
        return await this.makeStandardizedShareNotification('dbfs-update', address);
    }
    /**
     * Create sharing cancelled Notification entry. Wraps makeStandardizedShareNotification().
     * @param {string} address - Bech32 address of Notification target.
     * @returns {Promise<EncodeObject>}
     */
    async makeRemoveShareNoti(address) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('NotificationHandler', 'makeRemoveShareNoti'));
        return await this.makeStandardizedShareNotification('dbfs-remove', address);
    }
    /** Read Encrypted Notifications */
    /**
     * Query user's Notification by index
     * @param {number} index - Index of Notification to retrieve.
     * @returns {Promise<IReadableNoti>}
     */
    async readMyShareNoti(index) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('NotificationHandler', 'readMyShareNoti'));
        const { notifications } = await this.getNotification(this.walletRef.getJackalAddress(), index);
        return processNotiRead(notifications, this.walletRef);
    }
    /**
     * Query all of user's Notifications.
     * @returns {Promise<IReadableNoti[]>}
     */
    async readAllMyShareNotis() {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('NotificationHandler', 'readAllMyShareNotis'));
        const data = await this.getSingleAddressNotifications(this.walletRef.getJackalAddress());
        return data.map((noti) => processNotiRead(noti, this.walletRef));
    }
    /** Private Methods */
    /**
     * Check Notification count for target address.
     * @param {string} forAddress - Bech32 address for target.
     * @returns {Promise<IBaseNotiResponse>}
     * @private
     */
    async getBaseNotiCounter(forAddress) {
        return await this.qH.notificationsQuery.queryNotiCounter({
            address: forAddress
        });
    }
}
/** Helpers */
/**
 * Decrypt encrypted Notification contents.
 * @param {Notifications} noti - Contents to decrypt.
 * @param {IWalletHandler} walletRef - WalletHandler instance for decryption methods.
 * @returns {{contents: string, from: string, to: string}}
 * @private
 */
function processNotiRead(noti, walletRef) {
    const contents = new TextDecoder().decode(walletRef.asymmetricDecrypt(noti.notification));
    return { from: noti.sender, to: noti.address, contents };
}

class OracleHandler {
    qH;
    /**
     * Receives properties from trackOracle() to instantiate OracleHandler.
     * @param {IWalletHandler} wallet - Query or signing WalletHandler instance.
     * @private
     */
    constructor(wallet) {
        this.qH = wallet.getQueryHandler();
    }
    /**
     * Creates OracleHandler instance.
     * @param {IWalletHandler} wallet - Query or signing WalletHandler instance.
     * @returns {Promise<IOracleHandler>} - OracleHandler instance linked to provided WalletHandler instance.
     */
    static async trackOracle(wallet) {
        return new OracleHandler(wallet);
    }
    /**
     * Retrieve data of specified on-chain oracle.
     * @param {string} name - Name of oracle.
     * @returns {Promise<IOracleFeed>}
     */
    async getFeed(name) {
        const result = (await this.qH.oracleQuery.queryFeed({ name })).value.feed;
        return result ? result : { owner: 'na', data: 'na', name: 'na' };
    }
    /**
     * Retrieve data of all on-chain oracles.
     * @returns {Promise<IOracleFeed[]>}
     */
    async getAllFeeds() {
        return (await this.qH.oracleQuery.queryAllFeeds({})).value.feed;
    }
}

/**
 * Class encompassing basic and advanced methods needed for interaction with RNS addresses on the chain.
 */
class RnsHandler {
    walletRef;
    qH;
    /**
     * Create an RNS instance.
     * @param {IWalletHandler} wallet - Instance of WalletHandler from WalletHandler.trackWallet().
     * @private
     */
    constructor(wallet) {
        this.walletRef = wallet;
        this.qH = wallet.getQueryHandler();
    }
    /**
     * Async wrapper to create an RNS instance.
     * @param {IWalletHandler} wallet - Instance of WalletHandler from WalletHandler.trackWallet().
     * @returns {Promise<IRnsHandler>} - Instance of RnsHandler.
     */
    static async trackRns(wallet) {
        return new RnsHandler(wallet);
    }
    /**
     * Create Msg for accepting a bid on the user's RNS.
     * @param {string} rns -  The RNS to accept the bid for.
     * @param {string} from - The Jackal address to accept the bid from.
     * @returns {EncodeObject} - The Msg for processing by the chain.
     */
    makeAcceptBidMsg(rns, from) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('RnsHandler', 'makeAcceptBidMsg'));
        const pH = this.walletRef.getProtoHandler();
        const trueRns = sanitizeRns(rns);
        return pH.rnsTx.msgAcceptBid({
            creator: this.walletRef.getJackalAddress(),
            name: trueRns,
            from
        });
    }
    /**
     * Create Msg for adding a subdomain entry on the user's RNS.
     * @param {IRnsRecordItem} recordValues - New subdomain's values.
     * @returns {EncodeObject} - The Msg for processing by the chain.
     */
    makeAddRecordMsg(recordValues) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('RnsHandler', 'makeAddRecordMsg'));
        const pH = this.walletRef.getProtoHandler();
        const trueRns = sanitizeRns(recordValues.name);
        return pH.rnsTx.msgAddRecord({
            creator: this.walletRef.getJackalAddress(),
            name: trueRns,
            value: recordValues.value,
            data: sanitizeRnsData(recordValues.data, 'makeAddRecordMsg'),
            record: recordValues.record
        });
    }
    /**
     * Create Msg for submitting an offer on another user's RNS.
     * @param {string} rns - RNS to submit offer on.
     * @param {string} bid - Value of offer in ujkl. Example: "1000000ujkl" (1 $JKL).
     * @returns {EncodeObject} - The Msg for processing by the chain.
     */
    makeBidMsg(rns, bid) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('RnsHandler', 'makeBidMsg'));
        const pH = this.walletRef.getProtoHandler();
        const trueRns = sanitizeRns(rns);
        return pH.rnsTx.msgBid({
            creator: this.walletRef.getJackalAddress(),
            name: trueRns,
            bid
        });
    }
    /**
     * Create Msg for purchasing RNS listed on market.
     * @param {string} rns - RNS to purchase.
     * @returns {EncodeObject} - The Msg for processing by the chain.
     */
    makeBuyMsg(rns) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('RnsHandler', 'makeBuyMsg'));
        const pH = this.walletRef.getProtoHandler();
        const trueRns = sanitizeRns(rns);
        return pH.rnsTx.msgBuy({
            creator: this.walletRef.getJackalAddress(),
            name: trueRns
        });
    }
    /**
     * Create Msg to retract offer on another user's RNS.
     * @param {string} rns - RNS to retract offer from.
     * @returns {EncodeObject} - The Msg for processing by the chain.
     */
    makeCancelBidMsg(rns) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('RnsHandler', 'makeCancelBidMsg'));
        const pH = this.walletRef.getProtoHandler();
        const trueRns = sanitizeRns(rns);
        return pH.rnsTx.msgCancelBid({
            creator: this.walletRef.getJackalAddress(),
            name: trueRns
        });
    }
    /**
     * Create Msg to remove user's RNS from the market.
     * @param {string} rns - RNS to remove.
     * @returns {EncodeObject} - The Msg for processing by the chain.
     */
    makeDelistMsg(rns) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('RnsHandler', 'makeDelistMsg'));
        const pH = this.walletRef.getProtoHandler();
        const trueRns = sanitizeRns(rns);
        return pH.rnsTx.msgDelist({
            creator: this.walletRef.getJackalAddress(),
            name: trueRns
        });
    }
    /**
     * Create Msg to delete user's RNS.
     * @param {string} rns - RNS to delete.
     * @returns {EncodeObject} - The Msg for processing by the chain.
     */
    makeDelRecordMsg(rns) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('RnsHandler', 'makeDelRecordMsg'));
        const pH = this.walletRef.getProtoHandler();
        const trueRns = sanitizeRns(rns);
        return pH.rnsTx.msgDelRecord({
            creator: this.walletRef.getJackalAddress(),
            name: trueRns
        });
    }
    /**
     * Create Msg to activate user in the RNS system and to generate free account RNS.
     * @returns {EncodeObject} - The Msg for processing by the chain.
     */
    makeRnsInitMsg() {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('RnsHandler', 'makeRnsInitMsg'));
        const pH = this.walletRef.getProtoHandler();
        return pH.rnsTx.msgInit({
            creator: this.walletRef.getJackalAddress()
        });
    }
    /**
     * Create Msg to add user's RNS to the market.
     * @param {string} rns - RNS to list on market.
     * @param {string} price - Price of offer in ujkl. Example: "1000000ujkl" (1 $JKL).
     * @returns {EncodeObject} - The Msg for processing by the chain.
     */
    makeListMsg(rns, price) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('RnsHandler', 'makeListMsg'));
        const pH = this.walletRef.getProtoHandler();
        const trueRns = sanitizeRns(rns);
        return pH.rnsTx.msgList({
            creator: this.walletRef.getJackalAddress(),
            name: trueRns,
            price
        });
    }
    /**
     * Create Msg to register new RNS.
     * @param {IRnsRegistrationItem} registrationValues - Bundle containing RNS name, duration in years, and JSON.stringified metadata.
     * @returns {EncodeObject} - The Msg for processing by the chain.
     */
    makeNewRegistrationMsg(registrationValues) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('RnsHandler', 'makeNewRegistrationMsg'));
        const pH = this.walletRef.getProtoHandler();
        const trueRns = sanitizeRns(registrationValues.nameToRegister);
        return pH.rnsTx.msgRegister({
            creator: this.walletRef.getJackalAddress(),
            name: trueRns,
            years: (Number(registrationValues.yearsToRegister) || 1).toString(),
            data: sanitizeRnsData(registrationValues.data, 'makeNewRegistrationMsg')
        });
    }
    /**
     * Create Msg to transfer user's RNS to another user.
     * @param {string} rns - RNS to transfer.
     * @param {string} receiver - Jackal address to transfer to.
     * @returns {EncodeObject} - The Msg for processing by the chain.
     */
    makeTransferMsg(rns, receiver) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('RnsHandler', 'makeTransferMsg'));
        const pH = this.walletRef.getProtoHandler();
        const trueRns = sanitizeRns(rns);
        return pH.rnsTx.msgTransfer({
            creator: this.walletRef.getJackalAddress(),
            name: trueRns,
            receiver
        });
    }
    /**
     * Create Msg to update RNS metadata.
     * @param {string} rns - User's RNS to update.
     * @param {string} data - JSON.stringified new metadata to replace existing data.
     * @returns {EncodeObject} - The Msg for processing by the chain.
     */
    makeUpdateMsg(rns, data) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('RnsHandler', 'makeUpdateMsg'));
        const pH = this.walletRef.getProtoHandler();
        const trueRns = sanitizeRns(rns);
        return pH.rnsTx.msgUpdate({
            creator: this.walletRef.getJackalAddress(),
            name: trueRns,
            data: sanitizeRnsData(data, 'makeUpdateMsg')
        });
    }
    /**
     * Find a specific RNS bid by global index.
     * @param {string} index - Index to find.
     * @returns {Promise<IRnsBidItem>} - Bid if found, defaults to bid item with empty values if no match found.
     */
    async findSingleBid(index) {
        const trueIndex = sanitizeRns(index);
        return (await this.qH.rnsQuery.queryBids({ index: trueIndex })).value
            .bids;
    }
    /**
     * List all outstanding bids for all users.
     * @returns {Promise<IRnsBidHashMap>} - Object map of bid arrays by RNS name.
     */
    async findAllBids() {
        const data = (await handlePagination(this.qH.rnsQuery, 'queryBidsAll', {})).reduce((acc, curr) => {
            acc.push(...curr.bids);
            return acc;
        }, []);
        return data.reduce((acc, curr) => {
            if (!acc[curr.name]?.length) {
                acc[curr.name] = [curr];
            }
            else {
                acc[curr.name].push(curr);
            }
            return acc;
        }, {});
    }
    /**
     * Get RNS market details for a single listed RNS.
     * @param {string} rns - RNS address to find.
     * @returns {Promise<IRnsForSaleItem>} - Listing if found, defaults to list item with empty values if no match found.
     */
    async findSingleForSaleName(rns) {
        const trueRns = sanitizeRns(rns);
        return (await this.qH.rnsQuery.queryForsale({ name: trueRns })).value
            .forsale;
    }
    /**
     * Finds paginated RNS listed on market
     * @returns {Promise<IPaginatedMap<IRnsForSaleHashMap>>}
     */
    async findSomeForSaleNames(options) {
        const data = await this.qH.rnsQuery.queryForsaleAll({
            pagination: {
                key: options?.nextPage,
                limit: options?.limit || 100
            }
        });
        const condensed = data.value.forsale.reduce((acc, curr) => {
            acc[curr.name] = curr;
            return acc;
        }, {});
        return {
            data: condensed,
            nextPage: data.value.pagination?.nextKey
        };
    }
    /**
     * Finds all RNS listed on market.
     * @param {number} blockTime - Block length in milliseconds.
     * @returns {Promise<IRnsExpandedForSaleHashMap>} - Object map of list items by RNS name.
     */
    async findAllForSaleNames(blockTime) {
        const extendData = this.findAllNames();
        const data = (await handlePagination(this.qH.rnsQuery, 'queryForsaleAll', {})).reduce((acc, curr) => {
            acc.push(...curr.forsale);
            return acc;
        }, []);
        const ready = await extendData;
        return data.reduce((acc, curr) => {
            const cleanName = curr.name.replace('.jkl', '');
            const { expires } = ready[cleanName];
            acc[curr.name] = {
                ...curr,
                expires,
                expireDate: parseExpires(blockTime || 6000, expires),
                mine: false
            };
            return acc;
        }, {});
    }
    async findAllNames() {
        const data = (await handlePagination(this.qH.rnsQuery, 'queryNamesAll', {})).reduce((acc, curr) => {
            acc.push(...curr.names);
            return acc;
        }, []);
        return data.reduce((acc, curr) => {
            acc[curr.name] = curr;
            return acc;
        }, {});
    }
    /**
     * Finds all RNS listed on market and flags "mine" boolean if the user owns the RNS.
     * @param {number} blockTime - Block length in milliseconds.
     * @returns {Promise<IRnsExpandedForSaleHashMap>} - Object map of list items by RNS name.
     */
    async findExpandedForSaleNames(blockTime) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('RnsHandler', 'findExpandedForSaleNames'));
        const address = this.walletRef.getJackalAddress();
        const fullData = this.findAllNames();
        const data = (await handlePagination(this.qH.rnsQuery, 'queryForsaleAll', {})).reduce((acc, curr) => {
            acc.push(...curr.forsale);
            return acc;
        }, []);
        const ready = await fullData;
        return data.reduce((acc, curr) => {
            const cleanName = curr.name.replace('.jkl', '');
            const { expires } = ready[cleanName];
            acc[curr.name] = {
                ...curr,
                expires,
                expireDate: parseExpires(blockTime || 6000, expires),
                mine: curr.owner === address
            };
            return acc;
        }, {});
    }
    /**
     * Finds all RNS the current user owns.
     * @param {number} blockTime - Block length in milliseconds.
     * @returns {Promise<IRnsOwnedHashMap>} - Object map of entries by RNS name, locked RNS is stored as "free" instead.
     */
    async findMyExistingNames(blockTime) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('RnsHandler', 'findMyExistingNames'));
        const address = this.walletRef.getJackalAddress();
        return this.findYourExistingNames(address, blockTime);
    }
    /**
     * Finds all RNS the target user owns.
     * @param {string} address - JKL address to check for RNS names.
     * @param {number} blockTime - Block length in milliseconds.
     * @returns {Promise<IRnsOwnedHashMap>} - Object map of entries by RNS name, locked RNS is stored as "free" instead.
     */
    async findYourExistingNames(address, blockTime) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('RnsHandler', 'findYourExistingNames'));
        const data = (await handlePagination(this.qH.rnsQuery, 'queryListOwnedNames', {
            address
        })).reduce((acc, curr) => {
            acc.push(...curr.names);
            return acc;
        }, []);
        return data.reduce((acc, curr) => {
            const item = {
                ...curr,
                expireDate: parseExpires(blockTime || 6000, curr.expires)
            };
            if (curr.locked) {
                acc.free = item;
            }
            else {
                acc[curr.name] = item;
            }
            return acc;
        }, {});
    }
    /**
     * Find RNS details using RNS address.
     * @param {string} rns - RNS address to search.
     * @returns {Promise<IRnsItem>} - Data if found, defaults to item with empty values if no match found.
     */
    async findSingleRns(rns) {
        const trueRns = sanitizeRns(rns);
        return (await this.qH.rnsQuery.queryNames({ index: trueRns })).value
            .names;
    }
    /**
     * Find owner's address using RNS address.
     * @param {string} rns - RNS address to search.
     * @returns {Promise<string>} - Owner's address if found, defaults to empty string if no match found.
     */
    async findMatchingAddress(rns) {
        return (await this.findSingleRns(rns)).value || '';
    }
}
/**
 * Ensures RNS address ends with ".jkl".
 * @param {string} rns - RNS address to process.
 * @returns {string} - Source RNS address with ".jkl" included.
 * @private
 */
function sanitizeRns(rns) {
    const allowedExtensions = /\.(jkl|ibc)$/;
    return rns.match(allowedExtensions) ? rns : `${rns}.jkl`;
}
// /**
//  * Strip ".jkl" and ".ibc" endings from RNS address.
//  * @param {string} rns - RNS address to process.
//  * @returns {string} - Source RNS address with ".jkl" and ".ibc" excluded.
//  */
// function reverseSanitizeRns (rns: string): string {
//   const strippedExtensions = /\.(jkl|ibc)$/
//   return rns.replace(strippedExtensions, '')
// }
/**
 * Enforces JSON.stringify on data. Used by: makeUpdateMsg(), makeNewRegistrationMsg(), and makeAddRecordMsg().
 * @param {string} data - Data to force to JSON.stringify compliant string.
 * @param {string} caller - Function calling sanitizeRnsData() in case error is logged.
 * @returns {string} - JSON.stringify safe string.
 * @private
 */
function sanitizeRnsData(data, caller) {
    try {
        return typeof data === 'string'
            ? JSON.stringify(JSON.parse(data))
            : JSON.stringify(data);
    }
    catch (err) {
        console.error(`sanitizeRnsData() failed for ${caller}`);
        console.error(err);
        return '{}';
    }
}
/**
 * Convert RNS blockheight-based expiration to formatted Date string.
 * @param {number} blockTime - Duration of a block in milliseconds.
 * @param {number} expires - Blockheight of RNS expiration
 * @returns {string} - Localized date using 4 digit year, 2 digit day, and month name.
 * @private
 */
function parseExpires(blockTime, expires) {
    const dd = blockToDateFixed({
        /** Block time in milliseconds */
        blockTime: blockTime,
        currentBlockHeight: 2000000,
        targetBlockHeight: expires
    });
    return dd.toLocaleString('default', {
        year: 'numeric',
        month: 'long',
        day: '2-digit'
    });
}

class StorageHandler {
    walletRef;
    qH;
    /**
     * Receives properties from trackStorage() instantiate StorageHandler.
     * @param {IWalletHandler} wallet - Query or signing WalletHandler instance.
     * @private
     */
    constructor(wallet) {
        this.walletRef = wallet;
        this.qH = wallet.getQueryHandler();
    }
    /**
     * Creates StorageHandler instance.
     * @param {IWalletHandler} wallet - Query or signing WalletHandler instance.
     * @returns {Promise<IStorageHandler>} - StorageHandler instance linked to provided WalletHandler instance.
     */
    static async trackStorage(wallet) {
        return new StorageHandler(wallet);
    }
    /**
     * Purchase storage for specified address that does not currently have storage. For existing see upgradeStorage().
     * @param {string} forAddress - Jkl address to receive the purchased storage.
     * @param {number} duration - How long in months to purchase the storage.
     * @param {number} space - Amount of effective storage to purchase in TB.
     * @returns {Promise<DeliverTxResponse>} - Result of purchase broadcast.
     */
    async buyStorage(forAddress, duration, space) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('StorageHandler', 'buyStorage'));
        const pH = this.walletRef.getProtoHandler();
        const msg = pH.storageTx.msgBuyStorage({
            creator: this.walletRef.getJackalAddress(),
            forAddress,
            duration: `${duration * 720 || 720}h`,
            bytes: numTo3xTB(space),
            paymentDenom: 'ujkl'
        });
        return await pH.debugBroadcaster([msg], {});
    }
    /**
     * Purchase storage for specified address that currently has storage. For new see buyStorage().
     * @param {string} forAddress - Jkl address to receive the purchased storage.
     * @param {number} duration - How long in months to purchase the storage.
     * @param {number} space - Amount of effective storage to purchase in TB.
     * @returns {Promise<DeliverTxResponse>} - Result of purchase broadcast.
     */
    async upgradeStorage(forAddress, duration, space) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('StorageHandler', 'upgradeStorage'));
        const pH = this.walletRef.getProtoHandler();
        const msg = pH.storageTx.msgUpgradeStorage({
            creator: this.walletRef.getJackalAddress(),
            forAddress,
            duration: `${duration * 720 || 720}h`,
            bytes: numTo3xTB(space),
            paymentDenom: 'ujkl'
        });
        return await pH.debugBroadcaster([msg], {});
    }
    /**
     * Initialize address' storage system. Replaces WalletHandler.initAccount().
     * @returns {EncodeObject} - Postkey msg ready for broadcast.
     */
    makeStorageInitMsg() {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('StorageHandler', 'makeStorageInitMsg'));
        const pH = this.walletRef.getProtoHandler();
        return pH.fileTreeTx.msgPostkey({
            creator: this.walletRef.getJackalAddress(),
            key: this.walletRef.getPubkey()
        });
    }
    /**
     * Find all strays in the storage deals system.
     * @returns {Promise<IStray[]>}
     */
    async getAllStrays() {
        return (await handlePagination(this.qH.storageQuery, 'queryStraysAll', {})).reduce((acc, curr) => {
            acc.push(...curr.strays);
            return acc;
        }, []);
    }
    /**
     * Determine how much space jkl address has remaining.
     * @param {string} address - Jkl address to check.
     * @returns {Promise<number>} - Remaining space in bytes.
     */
    async getClientFreeSpace(address) {
        return (await this.qH.storageQuery.queryGetClientFreeSpace({ address }))
            .value.bytesfree;
    }
    /**
     * Determine current price in $JKL of specified size and duration of storage.
     * @param {number} space - Amount of effective space to use for price check.
     * @param {number} duration - Amount of time to use for price check.
     * @returns {Promise<number>} - Estimated price of specified storage in ujkl.
     */
    async getStorageJklPrice(space, duration) {
        const request = {
            bytes: Number(numTo3xTB(space)),
            duration: `${duration * 720 || 720}h`
        };
        return (await this.qH.storageQuery.queryPriceCheck(request)).value.price;
    }
    /**
     * Determine what storage plan (if any) has been purchased for the provided jkl address.
     * @param {string} address - Jkl address to check.
     * @returns {Promise<IPayData>} - Storage plan details.
     */
    async getPayData(address) {
        return (await this.qH.storageQuery.queryGetPayData({ address })).value;
    }
    /**
     * Determine space used and available for provided jkl address.
     * @param {string} address - Jkl address to check.
     * @returns {Promise<IStoragePaymentInfo>} - Space used and available. Defaults to zeros when nothing is found.
     */
    async getStoragePaymentInfo(address) {
        const result = (await this.qH.storageQuery.queryStoragePaymentInfo({ address })).value.storagePaymentInfo;
        return result ? result : { spaceAvailable: 0, spaceUsed: 0, address: '' };
    }
    /** Manage FT Noti */
    sharingRoot = 's/Sharing';
    /**
     * Save data to file sharing address. Overwrites existing data. Savable only by owner.
     * @param {string} receiverAddress - Jkl address receiving sharing data.
     * @param {ISharedTracker} shared - Bundle of all records shared with receiverAddress.
     * @returns {Promise<EncodeObject>} - PostFile msg ready for broadcast.
     */
    async saveSharing(receiverAddress, shared) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('StorageHandler', 'saveSharing'));
        return await saveFileTreeEntry(receiverAddress, this.sharingRoot, receiverAddress, shared, this.walletRef);
    }
    /**
     * Read data saved with saveSharing(). accessible by owner and sharing receiver.
     * @param {string} owner - data owner's jkl address.
     * @param {string} receiverAddress - Jkl address receiving sharing data.
     * @returns {Promise<ISharedTracker>} - Bundle of all records shared with receiver.
     */
    async readSharing(owner, receiverAddress) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('StorageHandler', 'readSharing'));
        const shared = await readFileTreeEntry(owner, `${this.sharingRoot}/${receiverAddress}`, this.walletRef).catch((err) => {
            throw new Error(`Storage.Handler - readSharing() JSON Parse Failed: ${err.message}`);
        });
        return shared;
    }
    /**
     * Remove all sharing data for specified receiver.
     * @param {string} receiverAddress - Jkl address receiving sharing data.
     * @returns {Promise<EncodeObject>} - DeleteFile msg ready for broadcast.
     */
    async stopSharing(receiverAddress) {
        if (!this.walletRef.traits)
            throw new Error(signerNotEnabled('StorageHandler', 'stopSharing'));
        return await removeFileTreeEntry(`${this.sharingRoot}/${receiverAddress}`, this.walletRef);
    }
}

const hashMap = {
    /** Filetree */
    '/canine_chain.filetree.MsgPostFile': 110,
    '/canine_chain.filetree.MsgAddViewers': 142,
    '/canine_chain.filetree.MsgPostkey': 12,
    '/canine_chain.filetree.MsgDeleteFile': 9,
    '/canine_chain.filetree.MsgRemoveViewers': 142,
    '/canine_chain.filetree.MsgMakeRoot': 46,
    '/canine_chain.filetree.MsgMakeRootV2': 48,
    '/canine_chain.filetree.MsgAddEditors': 142,
    '/canine_chain.filetree.MsgRemoveEditors': 142,
    '/canine_chain.filetree.MsgResetEditors': 142,
    '/canine_chain.filetree.MsgResetViewers': 142,
    '/canine_chain.filetree.MsgChangeOwner': 142,
    /** Notifications */
    '/canine_chain.notifications.MsgCreateNotifications': 142,
    '/canine_chain.notifications.MsgUpdateNotifications': 142,
    '/canine_chain.notifications.MsgDeleteNotifications': 142,
    '/canine_chain.notifications.MsgSetCounter': 142,
    '/canine_chain.notifications.MsgBlockSenders': 142,
    /** Oracle */
    '/canine_chain.oracle.MsgCreateFeed': 142,
    '/canine_chain.oracle.MsgUpdateFeed': 142,
    /** RNS */
    '/canine_chain.rns.MsgAcceptBid': 142,
    '/canine_chain.rns.MsgAddRecord': 142,
    '/canine_chain.rns.MsgBid': 23,
    '/canine_chain.rns.MsgBuy': 35,
    '/canine_chain.rns.MsgCancelBid': 142,
    '/canine_chain.rns.MsgDelist': 142,
    '/canine_chain.rns.MsgDelRecord': 142,
    '/canine_chain.rns.MsgInit': 15,
    '/canine_chain.rns.MsgList': 14,
    '/canine_chain.rns.MsgRegister': 37,
    '/canine_chain.rns.MsgTransfer': 142,
    '/canine_chain.rns.MsgUpdate': 142,
    /** Storage */
    '/canine_chain.storage.MsgPostContract': 126,
    '/canine_chain.storage.MsgPostproof': 142,
    '/canine_chain.storage.MsgSignContract': 82,
    '/canine_chain.storage.MsgSetProviderIP': 142,
    '/canine_chain.storage.MsgSetProviderKeybase': 142,
    '/canine_chain.storage.MsgSetProviderTotalspace': 142,
    '/canine_chain.storage.MsgInitProvider': 142,
    '/canine_chain.storage.MsgCancelContract': 29,
    '/canine_chain.storage.MsgBuyStorage': 142,
    '/canine_chain.storage.MsgClaimStray': 142,
    '/canine_chain.storage.MsgUpgradeStorage': 142,
    /** Bank */
    '/cosmos.bank.v1beta1.MsgMultiSend': 142,
    '/cosmos.bank.v1beta1.MsgSend': 142,
    /** Distribution */
    '/cosmos.distribution.v1beta1.MsgFundCommunityPool': 142,
    '/cosmos.distribution.v1beta1.MsgSetWithdrawAddress': 142,
    '/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward': 142,
    '/cosmos.distribution.v1beta1.MsgWithdrawValidatorCommission': 142,
    /** Gov */
    '/cosmos.gov.v1beta1.MsgDeposit': 142,
    '/cosmos.gov.v1beta1.MsgSubmitProposal': 142,
    '/cosmos.gov.v1beta1.MsgVote': 142,
    '/cosmos.gov.v1beta1.MsgVoteWeighted': 142,
    /** Slashing */
    '/cosmos.slashing.v1beta1.MsgUnjail': 142,
    /** Staking */
    '/cosmos.staking.v1beta1.MsgBeginRedelegate': 142,
    '/cosmos.staking.v1beta1.MsgCreateValidator': 142,
    '/cosmos.staking.v1beta1.MsgDelegate': 142,
    '/cosmos.staking.v1beta1.MsgEditValidator': 142,
    '/cosmos.staking.v1beta1.MsgUndelegate': 142
};
const baseRate = 56;
/**
 * Generates gas total estimate from list of Tx instances.
 * @param {(EncodeObject | IWrappedEncodeObject)[]} msgArray - Collection of Tx instances to calculate gas from.
 * @returns {number} - Adjusted number of gas units collection is expected to require.
 */
function estimateGas(msgArray) {
    const gas = msgArray.reduce((acc, curr) => {
        if (isIWrappedEncodeObject(curr)) {
            switch (true) {
                case curr.encodedObject.typeUrl.includes('MsgMakeRoot'):
                    const baseValue = 15;
                    const modified = 0.04 * Number(curr.modifier) || 0;
                    return acc + (baseValue + modified);
                default:
                    return acc + (hashMap[curr.encodedObject.typeUrl] || 142);
            }
        }
        else {
            return acc + (hashMap[curr.typeUrl] || 142);
        }
    }, 0);
    return (gas + baseRate) * 1100;
}
/**
 * Return a Gas object for use in a masterBroadcaster()-like call.
 * @param {(EncodeObject | IWrappedEncodeObject)[]} msgArray - Collection of Tx instances to calculate gas from.
 * @param {number | string} gasOverride - Number or number-like string to replace calculated gas value.
 * @returns {IGasRate} - Gas object with best estimate based on input.
 * @private
 */
function finalizeGas(msgArray, gasOverride) {
    const totalGas = Number(gasOverride) || estimateGas(msgArray);
    return {
        amount: [{ denom: 'ujkl', amount: Math.ceil(totalGas * .002).toString() }],
        gas: totalGas.toString()
    };
}
/**
 * Check if an input is a wrapped or raw EncodeObject.
 * @param {EncodeObject | IWrappedEncodeObject} toCheck - Source value.
 * @returns {toCheck is IWrappedEncodeObject} - Boolean indicating if source is a IWrappedEncodeObject.
 */
function isIWrappedEncodeObject(toCheck) {
    return Object.keys(toCheck).includes('encodedObject');
}

class QueryHandler {
    allQueryClients;
    /**
     * Receives properties from trackQuery() to instantiate QueryHandler. May be linked to WalletHandler instance.
     * @param {IAllQuery} allQueryClients
     * @protected
     */
    constructor(allQueryClients) {
        this.allQueryClients = allQueryClients;
    }
    /**
     * Async wrapper to create a QueryHandler instance.
     * @param {string} queryUrl - URL to API query node to use for requests.
     * @returns {Promise<QueryHandler>} - Instance of QueryHandler.
     */
    static async trackQuery(queryUrl) {
        const builder = new QueryBuilder(queryUrl);
        const allQueries = builder.makeAllQuery();
        return new QueryHandler(allQueries);
    }
    /** Custom */
    /**
     * Expose FileTree query client instance.
     * @returns {IQueryFileTree}
     */
    get fileTreeQuery() {
        return this.allQueryClients.fileTree;
    }
    /**
     * Expose JklMint query client instance.
     * @returns {IQueryJklMint}
     */
    get jklMintQuery() {
        return this.allQueryClients.jklMint;
    }
    /**
     * Expose Notifications query client instance.
     * @returns {IQueryNotifications}
     */
    get notificationsQuery() {
        return this.allQueryClients.notifications;
    }
    /**
     * Expose Oracle query client instance.
     * @returns {IQueryOracle}
     */
    get oracleQuery() {
        return this.allQueryClients.oracle;
    }
    /**
     * Expose Rns query client instance.
     * @returns {IQueryRns}
     */
    get rnsQuery() {
        return this.allQueryClients.rns;
    }
    /**
     * Expose Storage query client instance.
     * @returns {IQueryStorage}
     */
    get storageQuery() {
        return this.allQueryClients.storage;
    }
    /** Static */
    /**
     * Expose ABCI query client instance.
     * @returns {IQueryABCI}
     * @constructor
     */
    get ABCIQuery() {
        return this.allQueryClients.abci;
    }
    /**
     * Expose Bank query client instance.
     * @returns {IQueryBank}
     */
    get bankQuery() {
        return this.allQueryClients.bank;
    }
    /**
     * Expose Distribution query client instance.
     * @returns {IQueryDistribution}
     */
    get distributionQuery() {
        return this.allQueryClients.distribution;
    }
    /**
     * Expose Gov query client instance.
     * @returns {IQueryGov}
     */
    get govQuery() {
        return this.allQueryClients.gov;
    }
    /**
     * Expose Staking query client instance.
     * @returns {IQueryStaking}
     */
    get stakingQuery() {
        return this.allQueryClients.staking;
    }
}

class ProtoHandler extends QueryHandler {
    masterBroadcaster;
    allTxClients;
    /**
     * Receives properties from trackProto() to instantiate ProtoHandler. Linked to WalletHandler instance.
     * @param {TMasterBroadcaster} mb - Master broadcaster to use for all SignAndBroadcast sessions.
     * @param {IAllTx} allTxClients
     * @param {IAllQuery} allQueryClients
     * @private
     */
    constructor(mb, allTxClients, allQueryClients) {
        super(allQueryClients);
        this.masterBroadcaster = mb;
        this.allTxClients = allTxClients;
    }
    /**
     * Async wrapper to create a ProtoHandler instance.
     * @param {IProtoConfig} cfg - All settings needed to generate the ProtoHandler instance.
     * @returns {Promise<ProtoHandler>} - Instance of ProtoHandler.
     */
    static async trackProto(cfg) {
        const builder = new ProtoBuilder(cfg.signer, cfg.rpcUrl, cfg.queryUrl);
        const mb = await builder.makeMasterBroadcaster();
        const allTxs = builder.makeAllTx();
        const allQueries = builder.makeAllQuery();
        return new ProtoHandler(mb.masterBroadcaster, allTxs, allQueries);
    }
    /** General */
    /**
     * SignAndBroadcast group of 1 or more msgs to chain. Generally debugBroadcaster() is preferred.
     * @param {EncodeObject[]} msgs - Msgs to broadcast.
     * @param {string} memo - Optional memo to include in broadcast.
     * @param {number | string} gasOverride - Optional fixed gas amount to override calculated gas.
     * @returns {Promise<DeliverTxResponse>} - Result of broadcast.
     */
    async broadcaster(msgs, memo = '', gasOverride) {
        return this.masterBroadcaster(msgs, {
            fee: finalizeGas(msgs, gasOverride),
            memo
        }).catch((err) => {
            throw err;
        });
    }
    /**
     * SignAndBroadcast group of 1 or more msgs to chain. Generally debugBroadcaster() is preferred.
     * @param {EncodeObject[]} msgs - Msgs to broadcast.
     * @param {{gas?: number | string, memo?: string, step?: boolean}} extra
     * - Optional fixed gas amount to override calculated gas.
     * - Optional memo to include in broadcast.
     * - Optional flag to process msgs one at a time if true.
     * @returns {Promise<DeliverTxResponse>} - Result of broadcast.
     */
    async debugBroadcaster(msgs, extra = {
        memo: '',
        step: false
    }) {
        if (msgs.length < 1)
            throw new Error('Empty EncodeObject[] passed to debugBroadcaster()');
        if (extra.step) {
            let resp;
            for (let i = 0; i < msgs.length; i++) {
                console.log(msgs[i].typeUrl);
                resp = await this.broadcaster([msgs[i]], extra.memo, extra.gas).catch((err) => {
                    throw err;
                });
                console.dir(resp);
            }
            return resp;
        }
        else {
            const resp = await this.broadcaster(msgs, extra.memo, extra.gas).catch((err) => {
                throw err;
            });
            console.dir(resp);
            return resp;
        }
    }
    /**
     * Advanced use only. Expose base broadcaster for creating custom SignAndBroadcast process.
     * @returns {TMasterBroadcaster}
     */
    get rawBroadcaster() {
        return this.masterBroadcaster;
    }
    /** Custom */
    /**
     * Expose FileTree Tx client instance.
     * @returns {ITxFileTree}
     */
    get fileTreeTx() {
        return this.allTxClients.fileTree;
    }
    /**
     * Expose FileTree Tx client instance.
     * @returns {ITxNotifications}
     */
    get notificationsTx() {
        return this.allTxClients.notifications;
    }
    /**
     * Expose FileTree Tx client instance.
     * @returns {ITxOracle}
     */
    get oracleTx() {
        return this.allTxClients.oracle;
    }
    /**
     * Expose FileTree Tx client instance.
     * @returns {ITxRns}
     */
    get rnsTx() {
        return this.allTxClients.rns;
    }
    /**
     * Expose FileTree Tx client instance.
     * @returns {ITxStorage}
     */
    get storageTx() {
        return this.allTxClients.storage;
    }
    /** Static */
    /**
     * Expose FileTree Tx client instance.
     * @returns {ITxBank}
     */
    get bankTx() {
        return this.allTxClients.bank;
    }
    /**
     * Expose FileTree Tx client instance.
     * @returns {ITxDistribution}
     */
    get distributionTx() {
        return this.allTxClients.distribution;
    }
    /**
     * Expose FileTree Tx client instance.
     * @returns {ITxGov}
     */
    get govTx() {
        return this.allTxClients.gov;
    }
    /**
     * Expose FileTree Tx client instance.
     * @returns {ITxStaking}
     */
    get stakingTx() {
        return this.allTxClients.staking;
    }
}

class WalletHandler {
    qH;
    properties;
    traits;
    /**
     * Receives properties from trackWallet() or trackQueryWallet() to instantiate WalletHandler.
     * @param {IQueryHandler} qH - QueryHandler: Always present.
     * @param {IWalletHandlerPrivateProperties | null} properties - Properties that have getters and setters.
     * @param {IWalletHandlerPublicProperties | null} traits - Read-only properties. Can be reset with voidFullWallet().
     * @private
     */
    constructor(qH, properties, traits) {
        this.qH = qH;
        this.properties = properties;
        this.traits = traits;
    }
    /**
     * Creates full WalletHandler vs query-only from trackQueryWallet().
     * @param {IWalletConfig} config - Config items needed to create a signing WalletHandler.
     * @param {IMnemonicWallet} session - IMnemonicWallet instance.
     * @returns {Promise<IWalletHandler>} - Signing WalletHandler.
     */
    static async trackWallet(config, session) {
        const qH = await QueryHandler.trackQuery(config.queryAddr);
        const { properties, traits } = await processWallet(config, session).catch((err) => {
            throw err;
        });
        return new WalletHandler(qH, properties, traits);
    }
    /**
     * Creates query WalletHandler vs signing wallet from trackWallet().
     * @param {string} queryUrl - URL to query api node.
     * @returns {Promise<IWalletHandler>} - Query-only WalletHandler.
     */
    static async trackQueryWallet(queryUrl) {
        const qH = await QueryHandler.trackQuery(queryUrl);
        return new WalletHandler(qH, null, null);
    }
    /**
     * Merkle items together, intended for arbitrary paths.
     * @param {string} path - Path to merkle.
     * @param {string} item - Target to merkle.
     * @returns {Promise<string>} - Merkled result.
     */
    static async getAbitraryMerkle(path, item) {
        return await hexFullPath(await merkleMeBro(path), item);
    }
    /**
     * Converts query-only WalletHandler instance to signing instance.
     * @param {IWalletConfig} config - Requires same object as trackWallet().
     * @param {IMnemonicWallet} session - IMnemonicWallet instance.
     * @returns {Promise<void>}
     */
    async convertToFullWallet(config, session) {
        const { properties, traits } = await processWallet(config, session).catch((err) => {
            throw err;
        });
        this.properties = properties;
        this.traits = traits;
    }
    /**
     * Converts signing WalletHandler instance to query-only instance.
     * @returns {void}
     */
    voidFullWallet() {
        this.properties = null;
        this.traits = null;
    }
    /**
     * Check user's RNS initialization status.
     * @returns {boolean} - Indicates if user's RNS has been initialized.
     */
    getRnsInitStatus() {
        if (!this.properties)
            throw new Error(signerNotEnabled('WalletHandler', 'getRnsInitStatus'));
        return this.properties.rnsInitComplete;
    }
    /**
     * Save a RNS initialization status to the signing WalletHandler instance.
     * @param {boolean} status - RNS initialization status.
     * @returns {Promise<void>}
     */
    setRnsInitStatus(status) {
        if (!this.properties)
            throw new Error(signerNotEnabled('WalletHandler', 'setRnsInitStatus'));
        this.properties.rnsInitComplete = status;
    }
    /**
     * Check user's Storage initialization status.
     * @returns {boolean} - Indicates if user's Storage has been initialized.
     */
    getStorageInitStatus() {
        if (!this.properties)
            throw new Error(signerNotEnabled('WalletHandler', 'getStorageInitStatus'));
        return this.properties.fileTreeInitComplete;
    }
    /**
     * Save a Storage initialization status to the signing WalletHandler instance.
     * @param {boolean} status - Storage initialization status.
     * @returns {Promise<void>}
     */
    setStorageInitStatus(status) {
        if (!this.properties)
            throw new Error(signerNotEnabled('WalletHandler', 'setStorageInitStatus'));
        this.properties.fileTreeInitComplete = status;
    }
    /**
     * Expose signing WalletHandler instance ProtoHandler instance.
     * @returns {IProtoHandler}
     */
    getProtoHandler() {
        if (!this.properties)
            throw new Error(signerNotEnabled('WalletHandler', 'getProtoHandler'));
        return this.properties.pH;
    }
    /**
     * Expose query or signing WalletHandler instance QueryHandler instance.
     * @returns {IQueryHandler}
     */
    getQueryHandler() {
        return this.qH;
    }
    /**
     * Expose signing WalletHandler instance Signer accounts.
     * @returns {Promise<readonly AccountData[]>}
     */
    getAccounts() {
        if (!this.properties)
            throw new Error(signerNotEnabled('WalletHandler', 'getAccounts'));
        return this.properties.signer.getAccounts();
    }
    /**
     * Expose signing WalletHandler instance Signer.
     * @returns {OfflineSigner}
     */
    getSigner() {
        if (!this.properties)
            throw new Error(signerNotEnabled('WalletHandler', 'getSigner'));
        return this.properties.signer;
    }
    /**
     * Expose signing WalletHandler instance jkl address.
     * @returns {string} - Jkl address.
     */
    getJackalAddress() {
        if (!this.properties)
            throw new Error(signerNotEnabled('WalletHandler', 'getJackalAddress'));
        return this.properties.jackalAccount.address;
    }
    /**
     * Expose signing WalletHandler instance jkl address' hex value.
     * @returns {Promise<string>} - Hashed and hexed jkl address.
     */
    async getHexJackalAddress() {
        if (!this.properties)
            throw new Error(signerNotEnabled('WalletHandler', 'getHexJackalAddress'));
        return await hashAndHex(this.properties.jackalAccount.address);
    }
    /**
     * Retrieve all signing WalletHandler instance tokens and balances for all supported chains.
     * @returns {Promise<ICoin[]>} - All tokens and balances held by Signer.
     */
    async getAllBalances() {
        if (!this.properties)
            throw new Error(signerNotEnabled('WalletHandler', 'getAllBalances'));
        const res = await this.qH.bankQuery.queryAllBalances({
            address: this.properties.jackalAccount.address
        });
        return res.value.balances;
    }
    /**
     * Retrieve balance of $JKL in ujkl for signing WalletHandler instance.
     * @returns {Promise<ICoin>} - Balance in ujkl.
     */
    async getJackalBalance() {
        if (!this.properties)
            throw new Error(signerNotEnabled('WalletHandler', 'getJackalBalance'));
        const res = await this.qH.bankQuery.queryBalance({
            address: this.properties.jackalAccount.address,
            denom: 'ujkl'
        });
        return res.value.balance;
    }
    /**
     * Expose signing WalletHandler instance public key as hex value.
     * @returns {string} - Public key as hex value.
     */
    getPubkey() {
        if (!this.properties)
            throw new Error(signerNotEnabled('WalletHandler', 'getPubkey'));
        return this.properties.keyPair.publicKey.toHex();
    }
    /**
     * Encrypt value using public key from either findPubKey() or getPubkey(). Half of an asymmetric keypair.
     * @param {Buffer} toEncrypt - Value to encrypt.
     * @param {string} pubKey - Public key as hex value.
     * @returns {string} - Encrypted value.
     */
    asymmetricEncrypt(toEncrypt, pubKey) {
        return encrypt(pubKey, toEncrypt).toString('hex');
    }
    /**
     * Decrypt value using signing WalletHandler instance private key. Half of an asymmetric keypair.
     * @param {string} toDecrypt - Value to decrypt.
     * @returns {ArrayBuffer} - Decrypted value.
     */
    asymmetricDecrypt(toDecrypt) {
        if (!this.properties)
            throw new Error(signerNotEnabled('WalletHandler', 'asymmetricDecrypt'));
        return decrypt(this.properties.keyPair.toHex(), Buffer$1.from(toDecrypt, 'hex'));
    }
    /**
     * Retrieve asymmetric keypair public key from chain for specified jkl address.
     * @param {string} address - Jkl address to check.
     * @returns {Promise<string>} - Target address' public key as hex value.
     */
    async findPubKey(address) {
        const result = await this.qH.fileTreeQuery.queryPubkey({ address });
        if (!result.success) {
            throw new Error(`${address} does not have a pubkey registered`);
        }
        else {
            return result.value.pubkey.key;
        }
    }
    /**
     * Handler Factories
     */
    /**
     * Create AbciHandler instance and link to query or signing WalletHandler instance.
     * @returns {Promise<IAbciHandler>}
     */
    async makeAbciHandler() {
        return await AbciHandler.trackAbci(this);
    }
    /**
     * Create FileIo instance and link to signing WalletHandler instance.
     * @returns {Promise<IFileIo | null>} - Query WalletHandler instance returns null instead.
     */
    async makeFileIoHandler(versionFilter) {
        return this.traits ? await FileIo.trackIo(this, versionFilter) : null;
    }
    /**
     * Create GovHandler instance and link to query or signing WalletHandler instance.
     * @returns {Promise<IGovHandler>}
     */
    async makeGovHandler() {
        return await GovHandler.trackGov(this);
    }
    /**
     * Create NotificationHandler instance and link to query or signing WalletHandler instance.
     * @returns {Promise<INotificationHandler>}
     */
    async makeNotificationHandler() {
        return await NotificationHandler.trackNotification(this);
    }
    /**
     * Create OracleHandler instance and link to query or signing WalletHandler instance.
     * @returns {Promise<IOracleHandler>}
     */
    async makeOracleHandler() {
        return await OracleHandler.trackOracle(this);
    }
    /**
     * Create RnsHandler instance and link to query or signing WalletHandler instance.
     * @returns {Promise<IRnsHandler>}
     */
    async makeRnsHandler() {
        return await RnsHandler.trackRns(this);
    }
    /**
     * Create StorageHandler instance and link to query or signing WalletHandler instance.
     * @returns {Promise<IStorageHandler>}
     */
    async makeStorageHandler() {
        return await StorageHandler.trackStorage(this);
    }
}
/**
 * Generate a mnemonic-specific signature to use as a seed for creating an asymmetric keypair.
 * @param {string} acct - The wallet address matching the chainId.
 * @param {IMnemonicWallet} walletExtension - Custom wallet session to use for signArbitrary() call.
 * @returns {Promise<string>} - Generated signature.
 * @private
 */
async function makeSecret(acct, walletExtension) {
    const memo = 'Initiate Jackal Session';
    const signed = await walletExtension
        .signArbitrary(acct, memo)
        .catch((err) => {
        throw err;
    });
    return signed.signature;
}
/**
 * Create the traits and properties used by a signing WalletHandler.
 * @param {IWalletConfig} config - Config items needed to create a signing WalletHandler.
 * @param {IMnemonicWallet} session - CustomWallet instance.
 * @returns {Promise<{traits: IWalletHandlerPublicProperties, properties: IWalletHandlerPrivateProperties}>}
 * @private
 */
async function processWallet(config, session) {
    const { signerChain, queryAddr, txAddr } = config;
    const chainId = signerChain || jackalMainnetChainId;
    const signer = await session.getOfflineSignerAuto();
    const queryUrl = (queryAddr || defaultQueryAddr9091).replace(/\/+$/, '');
    const rpcUrl = (txAddr || defaultTxAddr26657).replace(/\/+$/, '');
    const jackalAccount = (await signer.getAccounts())[0];
    const pH = await ProtoHandler.trackProto({ signer, queryUrl, rpcUrl });
    const rnsInitComplete = (await pH.rnsQuery.queryInit({ address: jackalAccount.address })).value.init;
    const { value: { pubkey }, success } = await pH.fileTreeQuery.queryPubkey({ address: jackalAccount.address });
    const secret = await makeSecret(jackalAccount.address, session).catch((err) => {
        throw err;
    });
    const fileTreeInitComplete = success && !!pubkey?.key;
    const secretAsHex = bufferToHex(Buffer$1.from(secret, 'base64').subarray(0, 32));
    const keyPair = PrivateKey.fromHex(secretAsHex);
    const isDirect = isOfflineDirectSigner(signer);
    const properties = {
        signer,
        keyPair,
        rnsInitComplete,
        fileTreeInitComplete,
        jackalAccount,
        pH
    };
    const traits = {
        chainId,
        isDirect
    };
    return { properties, traits };
}

/** Classes */

export { AbciHandler, FileDownloadHandler, FileIo, FileUploadHandler, FolderHandler, GovHandler, MnemonicWallet, NotificationHandler, OracleHandler, RnsHandler, StorageHandler, WalletHandler, aesCrypt, aesToString, blockToDate, blockToDateFixed, bruteForceString, checkResults, convertFromEncryptedFile, convertFromPublicFile, convertToEncryptedFile, convertToPublicFile, cryptString, deprecated, exportJackalKey, genIv, genKey, getAverageBlockTime, getFileTreeData, getRandomIndex, handlePagination, importJackalKey, numTo3xTB, numToWholeTB, orderStrings, setDelay, signerNotEnabled, standardizeBlob, standardizeFileSource, stringToAes, stringToUint16, stringToUint8, stripper, uint16ToString, uint8ToString };
