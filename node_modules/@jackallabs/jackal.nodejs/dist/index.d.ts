/// <reference types="node" />
import { RequestInfo, ResponseInfo, ResponseSetOption, RequestInitChain, ResponseInitChain, RequestQuery, ResponseQuery, RequestBeginBlock, ResponseBeginBlock, ResponseCheckTx, ResponseDeliverTx, ResponseEndBlock, ResponseCommit, ResponseListSnapshots, RequestOfferSnapshot, ResponseOfferSnapshot, ResponseApplySnapshotChunk, ProposalStatus, QueryGetNotificationsResponse, QueryAllNotificationsResponse, Notifications, QueryGetNotiCounterResponse, QueryAllNotiCounterResponse, TMasterBroadcaster, ITxFileTree, ITxNotifications, ITxOracle, ITxRns, ITxStorage, ITxBank, ITxDistribution, ITxGov, ITxStaking, IQueryFileTree, IQueryJklMint, IQueryNotifications, IQueryOracle, IQueryRns, IQueryStorage, IQueryABCI, IQueryBank, IQueryDistribution, IQueryGov, IQueryStaking, QueryFileResponse } from '@jackallabs/jackal.nodejs-protos';
import { Buffer, Blob } from 'node:buffer';
import { OfflineDirectSigner, OfflineSigner, AccountData, EncodeObject } from '@cosmjs/proto-signing';
export { OfflineSigner } from '@cosmjs/proto-signing';
import { StdSignature } from '@cosmjs/amino';
import { DeliverTxResponse } from '@cosmjs/stargate';
import { Coin } from '@cosmjs/amino/build/coins';
import { PrivateKey } from 'eciesjs';

interface IAbciHandler {
    getEcho(message: string): Promise<string>;
    getBlockInfo(versions: RequestInfo): Promise<ResponseInfo>;
    setOptionByKeyValue(key: string, value: string): Promise<ResponseSetOption>;
    initializeChain(object: RequestInitChain): Promise<ResponseInitChain>;
    getQuery(object: RequestQuery): Promise<ResponseQuery>;
    getBeginBlock(object: RequestBeginBlock): Promise<ResponseBeginBlock>;
    getCheckTx(tx: Uint8Array, type: number): Promise<ResponseCheckTx>;
    getDeliverTx(tx: Uint8Array): Promise<ResponseDeliverTx>;
    getEndBlock(height: number): Promise<ResponseEndBlock>;
    getCommit(): Promise<ResponseCommit>;
    getListSnapshots(): Promise<ResponseListSnapshots>;
    getOfferSnapshot(object: RequestOfferSnapshot): Promise<ResponseOfferSnapshot>;
    getSnapshotChunk(height: number, format: number, chunk: number): Promise<Uint8Array>;
    putSnapshotChunk(index: number, chunk: Uint8Array, sender: string): Promise<ResponseApplySnapshotChunk>;
}

interface IMnemonicWallet {
    getOfflineSignerAuto(): Promise<OfflineDirectSigner>;
    signArbitrary(address: string, message: string): Promise<StdSignature>;
}

interface IFileDownloadHandler {
    receiveBacon(): File;
}

interface IFileBuffer {
    content: ArrayBuffer;
    details: IFileDetails;
}

interface IAdditionalWalletOptions {
    customWallet: IMnemonicWallet;
}

interface IAesBundle {
    iv: Uint8Array;
    key: CryptoKey;
}

interface IChainConfig {
    chainId: string;
    chainName: string;
    rpc: string;
    rest: string;
    bip44: {
        coinType: number;
    };
    coinType: number;
    stakeCurrency: {
        coinDenom: string;
        coinMinimalDenom: string;
        coinDecimals: number;
    };
    bech32Config: {
        bech32PrefixAccAddr: string;
        bech32PrefixAccPub: string;
        bech32PrefixValAddr: string;
        bech32PrefixValPub: string;
        bech32PrefixConsAddr: string;
        bech32PrefixConsPub: string;
    };
    currencies: ICurrency[];
    feeCurrencies: ICurrency[];
    features: string[];
}

interface IChildDirInfo {
    myName: string;
    myParent: string;
    myOwner: string;
}

interface ICoin {
    denom: string;
    amount: string;
}

interface ICurrency {
    coinDenom: string;
    coinMinimalDenom: string;
    coinDecimals: number;
    gasPriceStep?: {
        low: number;
        average: number;
        high: number;
    };
}

interface IDeleteItem {
    location: string;
    name: string;
}

interface IDownloadDetails {
    rawPath: string;
    owner: string;
}

interface IEditorsViewers {
    [key: string]: string;
}

interface IEnabledSecrets {
    custom: boolean;
    sharing: boolean;
}

interface IFiletreeParsedContents {
    fids: string[];
}

interface IFolderAdd {
    newDir: IFolderHandler;
    parentDir: IFolderHandler;
}

interface IFolderChildFiles {
    [name: string]: IFileMeta;
}

interface IFolderDownload {
    data: ArrayBuffer;
    config: IFileConfigRelevant;
    key: ArrayBuffer;
    iv: ArrayBuffer;
}

interface IFolderFrame {
    whoAmI: string;
    whereAmI: string;
    whoOwnsMe: string;
    dirChildren: string[];
    fileChildren: IFolderChildFiles;
}

interface IGasHashMap {
    [key: string]: number;
}

interface IGasRate {
    amount: Coin[];
    gas: string;
}

interface IMiner {
    address: string;
    ip: string;
    totalspace: string;
    burnedContracts: string;
    creator: string;
    keybaseIdentity: string;
    authClaimers: string[];
}

interface IMsgFinalPostFileBundle {
    creator: string;
    account: string;
    hashParent: string;
    hashChild: string;
    contents: string;
    viewers: string;
    editors: string;
    trackingNumber: string;
    viewersToNotify: string;
    editorsToNotify: string;
    notiForViewers: string;
    notiForEditors: string;
}

interface IMsgPartialPostFileBundle {
    creator: string;
    account: string;
    hashParent: string;
    hashChild: string;
    contents: string;
    viewers: string;
    editors: string;
    trackingNumber: string;
}

interface IOracleFeed {
    owner: string;
    data: string;
    lastUpdate?: Date;
    name: string;
}

interface IPaginatedMap<T> {
    data: T;
    nextPage?: Uint8Array;
}

interface IPagination {
    limit?: number;
    nextPage?: Uint8Array;
}

interface IPayData {
    timeRemaining: number;
    bytes: number;
}

type TPermsBlockBases = 'o' | 'e' | 'v';

interface IPermsParts {
    aes: IAesBundle;
    base: TPermsBlockBases;
    num: string;
    pubKey: string;
    usr: string;
}

interface IProtoConfig {
    signer: OfflineSigner;
    queryUrl?: string;
    rpcUrl?: string;
}

interface IProviderChecks {
    filtered: IMiner[];
    raw: IMiner[];
    verified: IMiner[];
}

interface IProviderModifiedResponse {
    cid: string;
    fid: string[];
}

interface IProviderResponse {
    cid: string;
    fid: string;
}

interface IProviderVersionResponse {
    'chain-id': string;
    version: string;
}

interface IQueueItemPostUpload {
    handler: IFileUploadHandler;
    data: IFileConfigRaw | null;
}

interface IReadableNoti {
    from: string;
    to: string;
    contents: string;
}

interface ISharedTracker {
    files: string[];
    folders: {
        [name: string]: ISharedTracker;
    };
}

interface IStaggeredTracker {
    complete: number;
    timer: number;
}

interface IStorageClientFree {
    bytesfree: string;
}

interface IStoragePaymentInfo {
    start?: Date;
    end?: Date;
    spaceAvailable: number;
    spaceUsed: number;
    address: string;
}

interface ISupportedWallets {
    keplr: boolean;
    leap: boolean;
}

interface IStray {
    cid: string;
    fid: string;
    signee: string;
    filesize: string;
    merkle: string;
    end: number;
}

interface IValidatorDescription {
    moniker: string;
    identity: string;
    website: string;
    securityContact: string;
    details: string;
}

interface IWalletConfig {
    signerChain?: string;
    queryAddr?: string;
    txAddr?: string;
}

interface IWalletHandlerPrivateProperties {
    readonly signer: OfflineSigner;
    readonly keyPair: PrivateKey;
    rnsInitComplete: boolean;
    fileTreeInitComplete: boolean;
    readonly jackalAccount: AccountData;
    readonly pH: IProtoHandler;
}

interface IWalletHandlerPublicProperties {
    readonly chainId: string;
    readonly isDirect: boolean;
}

interface IWrappedEncodeObject {
    encodedObject: EncodeObject;
    modifier?: number;
}

interface IFileConfigFull {
    address: string;
    contents: IFiletreeParsedContents;
    owner: string;
    editAccess: IEditorsViewers;
    viewingAccess: IEditorsViewers;
    trackingNumber: string;
}

interface IFileConfigRaw {
    address: string;
    contents: string;
    owner: string;
    editAccess: string;
    viewingAccess: string;
    trackingNumber: string;
}

interface IFileConfigRelevant {
    editAccess: IEditorsViewers;
    viewingAccess: IEditorsViewers;
    trackingNumber: string;
}

interface IFileDetails {
    lastModified: number;
    name: string;
    type: string;
}

interface IFileMeta {
    name: string;
    lastModified: number;
    size: number;
    type: string;
}

interface IFileMetaHashMap {
    [key: string]: IFileMeta;
}

interface IUploadList {
    [key: string]: IUploadListItem;
}

interface IUploadListItem {
    data: null | IFileConfigRaw;
    exists: boolean;
    handler: IFileUploadHandler;
    key: string;
    uploadable: File;
}

interface IFileIo {
    getCurrentProvider(): IMiner;
    getAvailableProviders(): IMiner[];
    forceProvider(toSet: IMiner): void;
    clearProblems(exclude: string): Promise<void>;
    shuffle(): Promise<void>;
    refresh(): Promise<void>;
    migrate(toCheck: string[]): Promise<void>;
    createFolders(parentDir: IFolderHandler, newDirs: string[]): Promise<void>;
    rawCreateFolders(parentDir: IFolderHandler, newDirs: string[]): Promise<EncodeObject[]>;
    verifyFoldersExist(toCheck: string[]): Promise<number>;
    staggeredUploadFiles(sourceHashMap: IUploadList, parent: IFolderHandler, tracker: IStaggeredTracker): Promise<void>;
    downloadFolder(rawPath: string): Promise<IFolderHandler>;
    downloadFile(downloadDetails: IDownloadDetails, completion: {
        track: number;
    }): Promise<IFileDownloadHandler>;
    downloadFileByFid(fid: string, completion: {
        track: number;
    }): Promise<IFileDownloadHandler>;
    deleteTargets(targets: string[], parent: IFolderHandler): Promise<void>;
    rawDeleteTargets(targets: string[], parent: IFolderHandler): Promise<EncodeObject[]>;
    generateInitialDirs(initMsg: EncodeObject | null, startingDirs?: string[]): Promise<void>;
    rawGenerateInitialDirs(initMsg: EncodeObject | null, startingDirs?: string[]): Promise<EncodeObject[]>;
    convertFolderType(rawPath: string): Promise<IFolderHandler>;
    rawConvertFolderType(rawPath: string): Promise<EncodeObject[]>;
    checkFolderIsFileTree(rawPath: string): Promise<IFolderHandler | null>;
}

interface IFileUploadHandler {
    isFolder: boolean;
    setIds(idObj: {
        cid: string;
        fid: string[];
    }): void;
    setUUID(uuid: string): void;
    getIds(): {
        fid: string[];
        cid: string;
    };
    getUUID(): string;
    getWhoAmI(): string;
    getWhereAmI(): string;
    getForUpload(aes?: IAesBundle): Promise<File>;
    getForPublicUpload(): File;
    getEnc(): Promise<IAesBundle>;
    getMerklePath(): Promise<string>;
    getMeta(): IFileMeta;
    getFullMerkle(): Promise<string>;
}

interface IFolderHandler {
    isFolder: boolean;
    getWhoAmI(): string;
    getWhereAmI(): string;
    getWhoOwnsMe(): string;
    getMyPath(): string;
    getMyChildPath(child: string): string;
    getFolderDetails(): IFolderFrame;
    getChildDirs(): string[];
    getChildFiles(): {
        [name: string]: IFileMeta;
    };
    getForFiletree(walletRef: IWalletHandler): Promise<EncodeObject>;
    getChildMerkle(child: string): Promise<string>;
    addChildDirs(childNames: string[], walletRef: IWalletHandler): Promise<{
        encoded: EncodeObject[];
        existing: string[];
    }>;
    addChildFileReferences(newFiles: IFileMetaHashMap, walletRef: IWalletHandler): Promise<EncodeObject>;
    removeChildDirReferences(toRemove: string[], walletRef: IWalletHandler): Promise<EncodeObject>;
    removeChildFileReferences(toRemove: string[], walletRef: IWalletHandler): Promise<EncodeObject>;
    removeChildDirAndFileReferences(dirs: string[], files: string[], walletRef: IWalletHandler): Promise<EncodeObject>;
    makeChildDirInfo(childName: string): IChildDirInfo;
}

interface IDelegationDetails {
    delegatorAddress: string;
    validatorAddress: string;
    shares: string;
}

interface IDelegationRewards {
    rewards: {
        validatorAddress: string;
        reward: ICoin[];
    }[];
    total: ICoin[];
}

interface IDelegationSummary {
    delegation: IDelegationDetails;
    balance: ICoin;
}

interface IDelegationSummaryMap {
    [key: string]: IDelegationSummary;
}

interface IPropDetails {
    proposalId: number;
    content: {
        typeUrl: string;
        value: Uint8Array;
    } | undefined;
    status: ProposalStatus;
    finalTallyResult: {
        yes: string;
        abstain: string;
        no: string;
        noWithVeto: string;
    } | undefined;
    submitTime: Date | undefined;
    depositEndTime: Date | undefined;
    totalDeposit: ICoin[];
    votingStartTime: Date | undefined;
    votingEndTime: Date | undefined;
}

interface IPropDetailsMap {
    [key: string]: IPropDetails;
}

interface IStakingValidator {
    operatorAddress: string;
    consensusPubkey: any;
    jailed: boolean;
    status: number;
    tokens: string;
    delegatorShares: string;
    description: IValidatorDescription;
    unbondingHeight: number;
    unbondingTime: Date;
    commission: {
        commissionRates: {
            rate: string;
            maxRate: string;
            maxChangeRate: string;
        };
        updateTime: Date;
    };
    minSelfDelegation: string;
}

interface IStakingValidatorExtended extends IStakingValidator {
    stakedWith: boolean;
}

interface IStakingValidatorExtendedMap {
    [key: string]: IStakingValidatorExtended;
}

interface IStakingValidatorMap {
    [key: string]: IStakingValidator;
}

interface IStakingValidatorStaked extends IStakingValidatorExtended {
    stakedDetails?: IDelegationSummary;
}

interface IStakingValidatorStakedMap {
    [key: string]: IStakingValidatorStaked;
}

type TValidatorStatus = 'UNSPECIFIED' | 'UNBONDED' | 'UNBONDING' | 'BONDED';

type TPropStatus = 'UNSPECIFIED' | 'DEPOSIT' | 'VOTING' | 'PASSED' | 'VETO' | 'FAILED' | 'UNRECOGNIZED';

interface IGovHandler {
    /** Staking Queries */
    getTotalRewards(): Promise<IDelegationRewards>;
    getCondensedTotalRewards(): Promise<number>;
    getRewards(validatorAddress: string): Promise<ICoin[]>;
    getCondensedRewards(validatorAddress: string): Promise<number>;
    getTotalStaked(): Promise<number>;
    getStakedMap(): Promise<IDelegationSummaryMap>;
    getStakedValidatorDetailsMap(): Promise<IStakingValidatorStakedMap>;
    getDelegatorValidatorDetails(validatorAddress: string): Promise<IStakingValidator>;
    getAllDelegatorValidatorDetails(): Promise<IStakingValidator[]>;
    getAllDelegatorValidatorDetailsMap(): Promise<IStakingValidatorMap>;
    getValidatorDetails(validatorAddress: string): Promise<IStakingValidator>;
    getAllValidatorDetails(status: string): Promise<IStakingValidator[]>;
    getAllValidatorDetailsMap(status: TValidatorStatus): Promise<IStakingValidatorMap>;
    getMergedValidatorDetailsMap(status: TValidatorStatus): Promise<IStakingValidatorExtendedMap>;
    getMergedValidatorDetailsStakedMap(status: TValidatorStatus): Promise<IStakingValidatorStakedMap>;
    getInactiveMergedValidatorDetailsStakedMap(): Promise<IStakingValidatorExtendedMap>;
    getInactiveMergedValidatorDetailsMap(): Promise<IStakingValidatorExtendedMap>;
    getCompleteMergedValidatorDetailsMap(): Promise<IStakingValidatorExtendedMap>;
    getPublicMergedValidatorDetailsMap(status: TValidatorStatus): Promise<IStakingValidatorStakedMap>;
    getPublicInactiveMergedValidatorDetailsStakedMap(): Promise<IStakingValidatorExtendedMap>;
    /** End Staking Queries */
    /** Voting Queries */
    getPropDetails(proposalId: number): Promise<IPropDetails>;
    getAllPropDetailsInStatus(status: TPropStatus): Promise<IPropDetails[]>;
    getAllPropDetailsInStatusMap(status: TPropStatus): Promise<IPropDetailsMap>;
    getAllCompletedPropDetailsMap(): Promise<IPropDetailsMap>;
    /** End Voting Queries */
    /** Staking Msgs */
    claimDelegatorRewards(validatorAddresses: string[]): Promise<void>;
    rawDelegateTokens(validatorAddress: string, amount: number): EncodeObject;
    delegateTokens(validatorAddress: string, amount: number): Promise<void>;
    rawUndelegateTokens(validatorAddress: string, amount: number | string): EncodeObject;
    undelegateTokens(validatorAddress: string, amount: number | string): Promise<void>;
    rawRedelegateTokens(fromAddress: string, toAddress: string, amount: number | string): EncodeObject;
    redelegateTokens(fromAddress: string, toAddress: string, amount: number | string): Promise<void>;
}

interface INotificationHandler {
    makeNotification(notification: string, address: string): EncodeObject;
    makeNotificationUpdate(count: number, notification: string, address: string): EncodeObject;
    makeNotificationDeletion(): EncodeObject;
    makeCounter(): EncodeObject;
    makeBlockedSender(sender: string): EncodeObject;
    broadcastMakeCounter(): Promise<void>;
    getNotification(forAddress: string, index: number): Promise<QueryGetNotificationsResponse>;
    getAllNotifications(): Promise<QueryAllNotificationsResponse>;
    getSingleAddressNotifications(forAddress: string): Promise<Notifications[]>;
    checkNotificationInit(forAddress: string): Promise<boolean>;
    getNotificationCounter(forAddress: string): Promise<QueryGetNotiCounterResponse>;
    getAllNotificationCounters(): Promise<QueryAllNotiCounterResponse>;
    /** Standardized Messages */
    makeStandardizedShareNotification(type: string, address: string): Promise<EncodeObject>;
    makeAddShareNoti(address: string): Promise<EncodeObject>;
    makeUpdateShareNoti(address: string): Promise<EncodeObject>;
    makeRemoveShareNoti(address: string): Promise<EncodeObject>;
    readMyShareNoti(index: number): Promise<IReadableNoti>;
    readAllMyShareNotis(): Promise<IReadableNoti[]>;
}

interface IOracleHandler {
    getFeed(name: string): Promise<IOracleFeed>;
    getAllFeeds(): Promise<IOracleFeed[]>;
}

interface IProtoHandler extends IQueryHandler {
    /** General */
    broadcaster(msgs: EncodeObject[], memo?: string, gasOverride?: number | string): Promise<DeliverTxResponse>;
    debugBroadcaster(msgs: EncodeObject[], extra: {
        gas?: number | string;
        memo?: string;
        step?: boolean;
    }): Promise<DeliverTxResponse>;
    rawBroadcaster: TMasterBroadcaster;
    /** Custom */
    fileTreeTx: ITxFileTree;
    notificationsTx: ITxNotifications;
    oracleTx: ITxOracle;
    rnsTx: ITxRns;
    storageTx: ITxStorage;
    /** Static */
    bankTx: ITxBank;
    distributionTx: ITxDistribution;
    govTx: ITxGov;
    stakingTx: ITxStaking;
}

interface IQueryHandler {
    /** Custom */
    fileTreeQuery: IQueryFileTree;
    jklMintQuery: IQueryJklMint;
    notificationsQuery: IQueryNotifications;
    oracleQuery: IQueryOracle;
    rnsQuery: IQueryRns;
    storageQuery: IQueryStorage;
    /** Static */
    ABCIQuery: IQueryABCI;
    bankQuery: IQueryBank;
    distributionQuery: IQueryDistribution;
    govQuery: IQueryGov;
    stakingQuery: IQueryStaking;
}

interface IRnsBidHashMap {
    [key: string]: IRnsBidItem[];
}

interface IRnsBidItem {
    index: string;
    name: string;
    bidder: string;
    price: string;
}

interface IRnsExistsHashMap {
    [key: string]: IRnsItem;
}

interface IRnsExpandedForSaleHashMap {
    [key: string]: IRnsExpandedForSaleItem;
}

interface IRnsExpandedForSaleItem {
    name: string;
    price: string;
    owner: string;
    expires: number;
    expireDate: string;
    mine: boolean;
}

interface IRnsForSaleHashMap {
    [key: string]: IRnsForSaleItem;
}

interface IRnsForSaleItem {
    name: string;
    price: string;
    owner: string;
}

interface IRnsOwnedHashMap {
    [key: string]: IRnsExpandedItem;
}

interface IRnsItem {
    name: string;
    expires: number;
    value: string;
    data: string;
    subdomains: IRnsItem[];
    tld: string;
    locked: number;
}

interface IRnsExpandedItem extends IRnsItem {
    expireDate: string;
}

interface IRnsRecordItem {
    name: string;
    value: string;
    data: string;
    record: string;
}

interface IRnsRegistrationItem {
    nameToRegister: string;
    yearsToRegister: number;
    data: string;
}

interface IRnsHandler {
    makeAcceptBidMsg(rns: string, from: string): EncodeObject;
    makeAddRecordMsg(recordValues: IRnsRecordItem): EncodeObject;
    makeBidMsg(rns: string, bid: string): EncodeObject;
    makeBuyMsg(rns: string): EncodeObject;
    makeCancelBidMsg(rns: string): EncodeObject;
    makeDelistMsg(rns: string): EncodeObject;
    makeDelRecordMsg(rns: string): EncodeObject;
    makeRnsInitMsg(): EncodeObject;
    makeListMsg(rns: string, price: string): EncodeObject;
    makeNewRegistrationMsg(registrationValues: IRnsRegistrationItem): EncodeObject;
    makeTransferMsg(rns: string, receiver: string): EncodeObject;
    makeUpdateMsg(rns: string, data: string): EncodeObject;
    findSingleBid(index: string): Promise<IRnsBidItem>;
    findAllBids(): Promise<IRnsBidHashMap>;
    findSingleForSaleName(rnsName: string): Promise<IRnsForSaleItem>;
    findSomeForSaleNames(options?: IPagination): Promise<IPaginatedMap<IRnsForSaleHashMap>>;
    findAllForSaleNames(blockTime?: number): Promise<IRnsExpandedForSaleHashMap>;
    findExpandedForSaleNames(blockTime?: number): Promise<IRnsExpandedForSaleHashMap>;
    findMyExistingNames(blockTime?: number): Promise<IRnsOwnedHashMap>;
    findYourExistingNames(address: string, blockTime?: number): Promise<IRnsOwnedHashMap>;
    findSingleRns(rns: string): Promise<IRnsItem>;
    findMatchingAddress(rns: string): Promise<string>;
}

interface IStorageHandler {
    buyStorage(forAddress: string, duration: number, space: number): Promise<DeliverTxResponse>;
    upgradeStorage(forAddress: string, duration: number, space: number): Promise<DeliverTxResponse>;
    makeStorageInitMsg(): EncodeObject;
    getAllStrays(): Promise<IStray[]>;
    getClientFreeSpace(address: string): Promise<number>;
    getStorageJklPrice(space: number, duration: number): Promise<number>;
    getPayData(address: string): Promise<IPayData>;
    getStoragePaymentInfo(address: string): Promise<IStoragePaymentInfo>;
    saveSharing(toAddress: string, shared: ISharedTracker): Promise<EncodeObject>;
    readSharing(owner: string, rawPath: string): Promise<ISharedTracker>;
    stopSharing(rawPath: string): Promise<EncodeObject>;
}

interface IWalletHandler {
    traits: IWalletHandlerPublicProperties | null;
    convertToFullWallet(config: IWalletConfig, session: IMnemonicWallet): Promise<void>;
    voidFullWallet(): void;
    getRnsInitStatus(): boolean;
    setRnsInitStatus(status: boolean): void;
    getStorageInitStatus(): boolean;
    setStorageInitStatus(status: boolean): void;
    getProtoHandler(): IProtoHandler;
    getQueryHandler(): IQueryHandler;
    getAccounts(): Promise<readonly AccountData[]>;
    getSigner(): OfflineSigner;
    getJackalAddress(): string;
    getHexJackalAddress(): Promise<string>;
    getAllBalances(): Promise<ICoin[]>;
    getJackalBalance(): Promise<ICoin>;
    getPubkey(): string;
    asymmetricEncrypt(toEncrypt: Buffer, pubKey: string): string;
    asymmetricDecrypt(toDecrypt: string): Buffer;
    findPubKey(address: string): Promise<string>;
    /**
     * Handler Factories
     */
    makeAbciHandler(): Promise<IAbciHandler>;
    makeFileIoHandler(versionFilter?: string | string[]): Promise<IFileIo | null>;
    makeGovHandler(): Promise<IGovHandler>;
    makeNotificationHandler(): Promise<INotificationHandler>;
    makeOracleHandler(): Promise<IOracleHandler>;
    makeRnsHandler(): Promise<IRnsHandler>;
    makeStorageHandler(): Promise<IStorageHandler>;
}

declare class AbciHandler implements IAbciHandler {
    private readonly qH;
    private constructor();
    static trackAbci(wallet: IWalletHandler): Promise<IAbciHandler>;
    getEcho(message: string): Promise<string>;
    getBlockInfo(versions: RequestInfo): Promise<ResponseInfo>;
    setOptionByKeyValue(key: string, value: string): Promise<ResponseSetOption>;
    initializeChain(object: RequestInitChain): Promise<ResponseInitChain>;
    getQuery(object: RequestQuery): Promise<ResponseQuery>;
    getBeginBlock(object: RequestBeginBlock): Promise<ResponseBeginBlock>;
    getCheckTx(tx: Uint8Array, type: number): Promise<ResponseCheckTx>;
    getDeliverTx(tx: Uint8Array): Promise<ResponseDeliverTx>;
    getEndBlock(height: number): Promise<ResponseEndBlock>;
    getCommit(): Promise<ResponseCommit>;
    getListSnapshots(): Promise<ResponseListSnapshots>;
    getOfferSnapshot(object: RequestOfferSnapshot): Promise<ResponseOfferSnapshot>;
    getSnapshotChunk(height: number, format: number, chunk: number): Promise<Uint8Array>;
    putSnapshotChunk(index: number, chunk: Uint8Array, sender: string): Promise<ResponseApplySnapshotChunk>;
}

declare class MnemonicWallet implements IMnemonicWallet {
    private directWallet;
    private aminoWallet;
    /**
     * Receives properties from create() to instantiate CustomWallet for us in creating WalletHandler instance.
     * @param {OfflineDirectSigner} directWallet
     * @param {OfflineAminoSigner} aminoWallet
     * @private
     */
    private constructor();
    /**
     * Async wrapper to create a CustomWallet instance.
     * @param {string} mnemonic - Seed phrase to use to generate the wallet sessions.
     * @returns {Promise<MnemonicWallet>} - Instance of CustomWallet.
     */
    static create(mnemonic: string): Promise<MnemonicWallet>;
    /**
     * Expose DirectSigner for use in WalletHandler.
     * @returns {Promise<OfflineDirectSigner>}
     */
    getOfflineSignerAuto(): Promise<OfflineDirectSigner>;
    /**
     * Generate signature used by WalletHandler to create session secret.
     * @param {string} address - Jkl address to use for signature.
     * @param {string} message - Value to use as signature base.
     * @returns {Promise<StdSignature>} - Resulting AminoSignResponse.signature.
     */
    signArbitrary(address: string, message: string): Promise<StdSignature>;
}

declare class PrivateFileDownloadHandler implements IFileDownloadHandler {
    protected readonly file: File;
    /**
     * Receives properties from trackFile() to instantiate PrivateFileDownloadHandler.
     * @param {File} file - Downloaded File post-processing
     * @protected
     */
    protected constructor(file: File);
    /**
     * Creates PrivateFileDownloadHandler instance.
     * @param {NodeJS Buffer} file - Raw file data direct from download source.
     * @param {CryptoKey} key - AES-256 CryptoKey.
     * @param {Uint8Array} iv - AES-256 iv.
     * @returns {Promise<IFileDownloadHandler>} - FileDownloadHandler instance.
     */
    static trackFile(file: Buffer, key: CryptoKey, iv: Uint8Array): Promise<IFileDownloadHandler>;
    /**
     * Returns downloaded file in decrypted state.
     * @returns {File}
     */
    receiveBacon(): File;
}

declare class FileDownloadHandler extends PrivateFileDownloadHandler implements IFileDownloadHandler {
    protected constructor(file: File);
    /**
     * Creates FileDownloadHandler instance.
     * @param {NodeJS Buffer} file - Raw file data direct from download source.
     * @param {CryptoKey} key - AES-256 CryptoKey.
     * @param {Uint8Array} iv - AES-256 iv.
     * @returns {Promise<IFileDownloadHandler>} - FileDownloadHandler instance.
     */
    static trackFile(file: Buffer, key: CryptoKey, iv: Uint8Array): Promise<IFileDownloadHandler>;
}

declare class FileUploadHandler implements IFileUploadHandler {
    private readonly file;
    private key;
    private iv;
    private readonly parentPath;
    private uuid;
    private cid;
    private fid;
    readonly isFolder: boolean;
    /**
     * Create a FileUploadHandler instance.
     * @param {File} file - File to stage for upload.
     * @param {string} parentPath - Path of folder File will be stored in.
     * @param {string} uuid - Instance UUID.
     * @param {CryptoKey} key - Instance AES key.
     * @param {Uint8Array} iv - Instance AES iv.
     * @private
     */
    private constructor();
    /**
     * Async wrapper to create a FileUploadHandler instance from a File.
     * @param {File} file - File to stage for uploading.
     * @param {string} parentPath - Path of folder File will be stored in.
     * @returns {Promise<IFileUploadHandler>}
     */
    static trackFile(file: File, parentPath: string): Promise<IFileUploadHandler>;
    /**
     * Update instance CID(s) and FID(s).
     * @param {{cid: string, fid: string[]}} idObj - New CID(s) and FID(s).
     */
    setIds(idObj: {
        cid: string;
        fid: string[];
    }): void;
    /**
     * Update instance UUID.
     * @param {string} uuid - New UUID.
     */
    setUUID(uuid: string): void;
    /**
     * Get instance CID(s) and FID(s).
     * @returns {{fid: string[], cid: string}}
     */
    getIds(): {
        fid: string[];
        cid: string;
    };
    /**
     * Get instance UUID.
     * @returns {string}
     */
    getUUID(): string;
    /**
     * Get name of the File.
     * @returns {string}
     */
    getWhoAmI(): string;
    /**
     * Get path of parent folder.
     * @returns {string}
     */
    getWhereAmI(): string;
    /**
     * Convert staged File to encrypted File for upload.
     * @param {IAesBundle} aes - Bundle of encryption details. (Optional)
     * @returns {Promise<File>}
     */
    getForUpload(aes?: IAesBundle): Promise<File>;
    /**
     * Provide staged File for upload without encryption.
     * @returns {File}
     */
    getForPublicUpload(): File;
    /**
     * Get instance encryption details.
     * @returns {Promise<IAesBundle>}
     */
    getEnc(): Promise<IAesBundle>;
    /**
     * Get full merkle string of path to File.
     * @returns {Promise<string>}
     */
    getFullMerkle(): Promise<string>;
    /**
     * Get full merkle string of path to parent folder.
     * @returns {Promise<string>}
     */
    getMerklePath(): Promise<string>;
    /**
     * Get File metadata.
     * @returns {IFileMeta}
     */
    getMeta(): IFileMeta;
}

declare class FileIo implements IFileIo {
    private readonly walletRef;
    private readonly qH;
    private availableProviders;
    private currentProvider;
    /**
     * Receives properties from trackIo() to instantiate FileIo.
     * @param {IWalletHandler} wallet - WalletHandler instance for QueryHandler and ProtoHandler management.
     * @param {IMiner[]} providers - Array of filtered Provider details to cycle through for uploads.
     * @param {IMiner} currentProvider - Starting active upload Provider.
     * @private
     */
    private constructor();
    /**
     * Creates FileIo instance.
     * @param {IWalletHandler} wallet - WalletHandler instance.
     * @param {string | string[]} versionFilter - Optional minimum chain version flag. Blocks all Providers if undefined. (Optional)
     * @returns {Promise<FileIo>}
     */
    static trackIo(wallet: IWalletHandler, versionFilter?: string | string[]): Promise<FileIo>;
    /**
     * Fetches and categorizes all providers registered to network.
     * @param {IWalletHandler} wallet - WalletHandler instance.
     * @param {string | string[]} versionFilter - Optional minimum chain version flag. Blocks all Providers if undefined. (Optional)
     * @returns {Promise<IProviderChecks>}
     */
    static checkProviders(wallet: IWalletHandler, versionFilter?: string | string[]): Promise<IProviderChecks>;
    /**
     * Expose active Provider for uploads.
     * @returns {IMiner}
     */
    getCurrentProvider(): IMiner;
    /**
     * Expose all active Providers available for uploads.
     * @returns {IMiner[]}
     */
    getAvailableProviders(): IMiner[];
    /**
     * Set active Provider for uploads.
     * @param {IMiner} toSet
     */
    forceProvider(toSet: IMiner): void;
    /**
     * Remove problem Provider from list and select new active Provider.
     * @param {string} exclude - Provider address to exclude.
     * @returns {Promise<void>}
     */
    clearProblems(exclude: string): Promise<void>;
    /**
     * Randomly selects new active Provider from list of active Providers available for uploads.
     * @returns {Promise<void>}
     */
    shuffle(): Promise<void>;
    /**
     * Re-queries network for Providers and randomly selects new active Provider.
     * @returns {Promise<void>}
     */
    refresh(): Promise<void>;
    /**
     * Converts File-based folder(s) to FileTree-based folder(s).
     * @param {string[]} toCheck - Folder paths (without s/) to check and convert.
     * @returns {Promise<void>}
     */
    migrate(toCheck: string[]): Promise<void>;
    /**
     * Create new Subfolder(s) with single shared parent Folder. Wrapper for rawCreateFolders().
     * @param {IFolderHandler} parentDir - Parent Folder instance.
     * @param {string[]} newDirs - Name(s) of Subfolder(s) to create.
     * @returns {Promise<void>}
     */
    createFolders(parentDir: IFolderHandler, newDirs: string[]): Promise<void>;
    /**
     * Creates and returns FileTree EncodeObject instances for external consumption by a signAndBroadcast.
     * @param {IFolderHandler} parentDir - Parent Folder instance.
     * @param {string[]} newDirs - Name(s) of Subfolder(s) to create.
     * @returns {Promise<EncodeObject[]>}
     */
    rawCreateFolders(parentDir: IFolderHandler, newDirs: string[]): Promise<EncodeObject[]>;
    /**
     * Check if base Folders exist and create if not found.
     * @param {string[]} toCheck - Name(s) of base Folder(s) to check.
     * @returns {Promise<number>}
     */
    verifyFoldersExist(toCheck: string[]): Promise<number>;
    /**
     * Uploads file(s) and queues successes into batches for wallet prompts.
     * @param {IUploadList} sourceHashMap - Map of all files, key is file name.
     * @param {IFolderHandler} parent - Folder the files are being uploaded to.
     * @param {IStaggeredTracker} tracker - External access to completion progress. Not yet implemented.
     * @returns {Promise<void>}
     */
    staggeredUploadFiles(sourceHashMap: IUploadList, parent: IFolderHandler, tracker: IStaggeredTracker): Promise<void>;
    /**
     * Saves completed uploads to FileTree.
     * @param {IQueueItemPostUpload[]} ids - Bundle(s) of details on uploaded file(s).
     * @returns {Promise<EncodeObject[]>}
     * @private
     */
    private rawAfterUpload;
    /**
     * Fetches FileTree data for target Folder and creates Handler instance.
     * @param {string} rawPath - Full path to Folder. Example: s/Node/Pictures.
     * @returns {Promise<IFolderHandler>}
     */
    downloadFolder(rawPath: string): Promise<IFolderHandler>;
    /**
     * Download File.
     * @param {IDownloadDetails} downloadDetails - Details needed to find file.
     * @param {{track: number}} completion - External access to download progress.
     * @returns {Promise<IFileDownloadHandler>}
     */
    downloadFile(downloadDetails: IDownloadDetails, completion: {
        track: number;
    }): Promise<IFileDownloadHandler>;
    /**
     * Locate and download file using unique FID.
     * @param {string} fid - FID for target File.
     * @param {{track: number}} completion - External access to download progress.
     * @returns {Promise<IFileDownloadHandler>}
     */
    downloadFileByFid(fid: string, completion: {
        track: number;
    }): Promise<IFileDownloadHandler>;
    /**
     * Deletes target Folder(s) and sub folders/files. Wraps rawDeleteTargets().
     * @param {string[]} targets - Target Folder(s) and/or files and children.
     * @param {IFolderHandler} parent - Parent Folder that is NOT being deleted.
     * @returns {Promise<void>}
     */
    deleteTargets(targets: string[], parent: IFolderHandler): Promise<void>;
    /**
     * Creates and returns FileTree and Storage EncodeObject instances for external consumption by a signAndBroadcast.
     * @param {string[]} targets - Target Folder(s) and/or files and children.
     * @param {IFolderHandler} parent - Parent Folder that is NOT being deleted.
     * @returns {Promise<EncodeObject[]>}
     */
    rawDeleteTargets(targets: string[], parent: IFolderHandler): Promise<EncodeObject[]>;
    /**
     * Creates target base Folders and inits storage if provided. Wraps rawGenerateInitialDirs().
     * @param {EncodeObject | null} initMsg - Msg to init storage if needed.
     * @param {string[]} startingDirs - Base Folders to create. (Optional)
     * @returns {Promise<void>}
     */
    generateInitialDirs(initMsg: EncodeObject | null, startingDirs?: string[]): Promise<void>;
    /**
     * Creates and returns FileTree EncodeObject instances for external consumption by a signAndBroadcast.
     * @param {EncodeObject | null} initMsg - Msg to init storage if needed.
     * @param {string[]} startingDirs - Base Folders to create. (Optional)
     * @returns {Promise<EncodeObject[]>}
     */
    rawGenerateInitialDirs(initMsg: EncodeObject | null, startingDirs?: string[]): Promise<EncodeObject[]>;
    /**
     * Converts File-based Folders to FileTree-based Folders. Wraps rawConvertFolderType().
     * @param {string} rawPath - Full path to the target Folder.
     * @returns {Promise<IFolderHandler>}
     */
    convertFolderType(rawPath: string): Promise<IFolderHandler>;
    /**
     * Creates and returns FileTree and Storage EncodeObject instances for external consumption by a signAndBroadcast.
     * @param {string} rawPath - Full path to the target Folder.
     * @returns {Promise<EncodeObject[]>}
     */
    rawConvertFolderType(rawPath: string): Promise<EncodeObject[]>;
    /**
     * Determine if a Folder is File or FileTree based.
     * @param {string} rawPath - Full path to the target Folder.
     * @returns {Promise<IFolderHandler | null>} - Returns FolderHandler instance if Folder is FileTree-based.
     */
    checkFolderIsFileTree(rawPath: string): Promise<IFolderHandler | null>;
    /**
     * Generate FolderHandler for target new folder. Used by rawGenerateInitialDirs().
     * @param {string} pathName - Name of Folder.
     * @param {string} parentPath - Full path to parent Folder.
     * @param {string} creator - Bech32 address of owner.
     * @returns {Promise<EncodeObject>}
     * @private
     */
    private createFileTreeFolderMsg;
    /**
     * Creates and returns FileTree and Storage EncodeObject instances for external consumption by a signAndBroadcast.
     * @param {string} creator - Bech32 address of owner.
     * @param {string[]} targets - Full path to deletion target.
     * @returns {Promise<EncodeObject[]>}
     * @private
     */
    private makeDelete;
    /**
     * Upload Files via Fetch and gracefully rollover to next provider if upload fails.
     * @param {string} sender - Bech32 address of owner.
     * @param {File} file - File to upload.
     * @returns {Promise<IProviderModifiedResponse>}
     * @private
     */
    private tumbleUpload;
    /**
     * Create s/.
     * @returns {Promise<EncodeObject>}
     * @private
     */
    private createRoot;
}

declare class FolderHandler implements IFolderHandler {
    private readonly folderDetails;
    readonly isFolder: boolean;
    /**
     * Create a FolderHandler instance.
     * @param {IFolderFrame} folderDetails - Folder metadata.
     * @private
     */
    private constructor();
    /**
     * Async wrapper to create a FolderHandler instance from a FileTree source.
     * @param {IFolderFrame} dirInfo - Folder metadata.
     * @returns {Promise<IFolderHandler>}
     */
    static trackFolder(dirInfo: IFolderFrame): Promise<IFolderHandler>;
    /**
     * Async wrapper to create a FolderHandler instance for a new folder.
     * @param {IChildDirInfo} dirInfo - Initial Folder details.
     * @returns {Promise<IFolderHandler>}
     */
    static trackNewFolder(dirInfo: IChildDirInfo): Promise<IFolderHandler>;
    /**
     * Get name of Folder.
     * @returns {string}
     */
    getWhoAmI(): string;
    /**
     * Get parent path of Folder.
     * @returns {string}
     */
    getWhereAmI(): string;
    /**
     * Get Bech32 address of Folder owner.
     * @returns {string}
     */
    getWhoOwnsMe(): string;
    /**
     * Get full Folder path (parent path + Folder name)
     * @returns {string}
     */
    getMyPath(): string;
    /**
     * Get full path for target child.
     * @param {string} child
     * @returns {string}
     */
    getMyChildPath(child: string): string;
    /**
     * Get full Folder metadata.
     * @returns {IFolderFileFrame}
     */
    getFolderDetails(): IFolderFrame;
    /**
     * Get all direct child folders.
     * @returns {string[]}
     */
    getChildDirs(): string[];
    /**
     * Get all direct child files.
     * @returns {{[p: string]: IFileMeta}}
     */
    getChildFiles(): {
        [name: string]: IFileMeta;
    };
    /**
     * Creates and returns FileTree EncodeObject for saving Folder to network.
     * @param {IWalletHandler} walletRef - WalletHandler instance.
     * @returns {Promise<EncodeObject>}
     */
    getForFiletree(walletRef: IWalletHandler): Promise<EncodeObject>;
    /**
     * Get full merkle string of path to target child.
     * @param {string} child - Name of child Folder or file.
     * @returns {Promise<string>}
     */
    getChildMerkle(child: string): Promise<string>;
    /**
     * Add direct child Folder(s) to this Folder's metadata.
     * @param {string[]} childNames - Array of names to add as direct child Folders.
     * @param {IWalletHandler} walletRef - WalletHandler instance.
     * @returns {Promise<{encoded: EncodeObject[], existing: string[]}>}
     */
    addChildDirs(childNames: string[], walletRef: IWalletHandler): Promise<{
        encoded: EncodeObject[];
        existing: string[];
    }>;
    /**
     * Add direct child file(s) to this Folder's metadata.
     * @param {IFileMetaHashMap} newFiles - Map of file metadata using file name as key.
     * @param {IWalletHandler} walletRef - WalletHandler instance.
     * @returns {Promise<EncodeObject>}
     */
    addChildFileReferences(newFiles: IFileMetaHashMap, walletRef: IWalletHandler): Promise<EncodeObject>;
    /**
     * Remove direct child Folder(s) from this Folder's metadata.
     * @param {string[]} toRemove - Array of names to remove as direct child Folders.
     * @param {IWalletHandler} walletRef - WalletHandler instance.
     * @returns {Promise<EncodeObject>}
     */
    removeChildDirReferences(toRemove: string[], walletRef: IWalletHandler): Promise<EncodeObject>;
    /**
     * Remove direct child file(s) from this Folder's metadata.
     * @param {string[]} toRemove - Array of names to remove as direct child files.
     * @param {IWalletHandler} walletRef - WalletHandler instance.
     * @returns {Promise<EncodeObject>}
     */
    removeChildFileReferences(toRemove: string[], walletRef: IWalletHandler): Promise<EncodeObject>;
    /**
     * Remove direct child Folder(s) and/or file(s) from this Folder's metadata.
     * @param {string[]} dirs - Array of names to remove as direct child Folders.
     * @param {string[]} files - Array of names to remove as direct child files.
     * @param {IWalletHandler} walletRef - WalletHandler instance.
     * @returns {Promise<EncodeObject>}
     */
    removeChildDirAndFileReferences(dirs: string[], files: string[], walletRef: IWalletHandler): Promise<EncodeObject>;
    /**
     * Generate metadata bundle to create new direct child Folder. For use with FolderHandler.trackNewFolder().
     * @param {string} childName - Name of Folder to create.
     * @returns {IChildDirInfo}
     */
    makeChildDirInfo(childName: string): IChildDirInfo;
}

declare class GovHandler implements IGovHandler {
    private readonly walletRef;
    private readonly qH;
    /**
     * Create a GovHandler instance.
     * @param {IWalletHandler} wallet - Instance of WalletHandler.
     * @private
     */
    private constructor();
    /**
     * Async wrapper to create a GovHandler instance.
     * @param {IWalletHandler} wallet - Instance of WalletHandler.
     * @returns {Promise<IGovHandler>} - Instance of GovHandler.
     */
    static trackGov(wallet: IWalletHandler): Promise<IGovHandler>;
    /** Staking Queries */
    /**
     * Query all individual rewards for all delegators on all validators.
     * @returns {Promise<IDelegationRewards>}
     */
    getTotalRewards(): Promise<IDelegationRewards>;
    /**
     * Query total rewards for all delegators on all validators.
     * @returns {Promise<number>}
     */
    getCondensedTotalRewards(): Promise<number>;
    /**
     * Query all individual rewards for all delegators on target validator.
     * @param {string} validatorAddress - Bech32 address of validator.
     * @returns {Promise<ICoin[]>}
     */
    getRewards(validatorAddress: string): Promise<ICoin[]>;
    /**
     * Query total rewards for all delegators on target validator.
     * @param {string} validatorAddress - Bech32 address of validator.
     * @returns {Promise<number>}
     */
    getCondensedRewards(validatorAddress: string): Promise<number>;
    /**
     * Query total $JKL staked for target delegator on all validators.
     * @returns {Promise<number>}
     */
    getTotalStaked(): Promise<number>;
    /**
     * Query $JKL staked for target delegator on all validators as map of validator Bech32 addresses.
     * @returns {Promise<IDelegationSummaryMap>}
     */
    getStakedMap(): Promise<IDelegationSummaryMap>;
    /**
     * Query details for only validators user delegates to and amount delegated.
     * @returns {Promise<IStakingValidatorStakedMap>}
     */
    getStakedValidatorDetailsMap(): Promise<IStakingValidatorStakedMap>;
    /**
     * Query details of target validator user is delegated to.
     * @param {string} validatorAddress - Bech32 address of validator.
     * @returns {Promise<IStakingValidator>}
     */
    getDelegatorValidatorDetails(validatorAddress: string): Promise<IStakingValidator>;
    /**
     * Query details for all validator details user is delegated to.
     * @returns {Promise<IStakingValidator[]>}
     */
    getAllDelegatorValidatorDetails(): Promise<IStakingValidator[]>;
    /**
     * Query details for all validator details user is delegated to as a Map. Wraps getAllDelegatorValidatorDetails().
     * @returns {Promise<IStakingValidatorMap>}
     */
    getAllDelegatorValidatorDetailsMap(): Promise<IStakingValidatorMap>;
    /**
     * Query details of target validator.
     * @param {string} validatorAddress - Bech32 address of validator.
     * @returns {Promise<IStakingValidator>}
     */
    getValidatorDetails(validatorAddress: string): Promise<IStakingValidator>;
    /**
     * Query details for all validators with target status.
     * @param {TValidatorStatus} status - String matching 1 of the 4 TValidatorStatus statuses.
     * @returns {Promise<IStakingValidator[]>}
     */
    getAllValidatorDetails(status: TValidatorStatus): Promise<IStakingValidator[]>;
    /**
     * Query details for all validators with target status as Map. Wraps getAllValidatorDetails().
     * @param {TValidatorStatus} status - String matching 1 of the 4 TValidatorStatus statuses.
     * @returns {Promise<IStakingValidatorMap>}
     */
    getAllValidatorDetailsMap(status: TValidatorStatus): Promise<IStakingValidatorMap>;
    /**
     * Query details for all validators with user delegation and all validators with target status as Map.
     * Wraps getAllDelegatorValidatorDetailsMap() and getAllValidatorDetailsMap().
     * @param {TValidatorStatus} status - String matching 1 of the 4 TValidatorStatus statuses.
     * @returns {Promise<IStakingValidatorExtendedMap>}
     */
    getMergedValidatorDetailsMap(status: TValidatorStatus): Promise<IStakingValidatorExtendedMap>;
    /**
     * Query details including staking details for all validators with user delegation and all validators with target status as Map.
     * Wraps getAllDelegatorValidatorDetailsMap() and getAllValidatorDetailsMap().
     * @param {TValidatorStatus} status - String matching 1 of the 4 TValidatorStatus statuses.
     * @returns {Promise<IStakingValidatorStakedMap>}
     */
    getMergedValidatorDetailsStakedMap(status: TValidatorStatus): Promise<IStakingValidatorStakedMap>;
    /**
     * Query details including staking details for all validators with user delegation and all validators with an inactive status as Map.
     * Wraps getAllDelegatorValidatorDetailsMap() and getInactiveMergedValidatorDetailsMap().
     * @returns {Promise<IStakingValidatorExtendedMap>}
     */
    getInactiveMergedValidatorDetailsStakedMap(): Promise<IStakingValidatorExtendedMap>;
    /**
     * Query details for all validators with user delegation and all validators with an inactive status as Map.
     * Wraps getAllDelegatorValidatorDetailsMap() and getAllValidatorDetailsMap().
     * @returns {Promise<IStakingValidatorExtendedMap>}
     */
    getInactiveMergedValidatorDetailsMap(): Promise<IStakingValidatorExtendedMap>;
    /**
     * Query details including staking details for all validators as Map.
     * Wraps getAllDelegatorValidatorDetailsMap() and getAllValidatorDetailsMap().
     * @returns {Promise<IStakingValidatorExtendedMap>}
     */
    getCompleteMergedValidatorDetailsMap(): Promise<IStakingValidatorExtendedMap>;
    /**
     * Query details including public staking details for all validators as Map. Wraps getAllValidatorDetailsMap().
     * @param {TValidatorStatus} status - String matching 1 of the 4 TValidatorStatus statuses.
     * @returns {Promise<IStakingValidatorStakedMap>}
     */
    getPublicMergedValidatorDetailsMap(status: TValidatorStatus): Promise<IStakingValidatorStakedMap>;
    /**
     * Query details including public staking details for all inactive status validators as Map. Wraps getAllValidatorDetailsMap().
     * @returns {Promise<IStakingValidatorExtendedMap>}
     */
    getPublicInactiveMergedValidatorDetailsStakedMap(): Promise<IStakingValidatorExtendedMap>;
    /** End Staking Queries */
    /** Voting Queries */
    /**
     * Query details of target governance proposal.
     * @param {number} proposalId - Index of proposal.
     * @returns {Promise<IPropDetails>}
     */
    getPropDetails(proposalId: number): Promise<IPropDetails>;
    /**
     * Query details of all governance proposals with target status.
     * @param {TPropStatus} status - String matching 1 of the 7 TPropStatus statuses.
     * @returns {Promise<IPropDetails[]>}
     */
    getAllPropDetailsInStatus(status: TPropStatus): Promise<IPropDetails[]>;
    /**
     * Query details of all governance proposals with target status as Map. Wraps getAllPropDetailsInStatus().
     * @param {TPropStatus} status - String matching 1 of the 7 TPropStatus statuses.
     * @returns {Promise<IPropDetailsMap>}
     */
    getAllPropDetailsInStatusMap(status: TPropStatus): Promise<IPropDetailsMap>;
    /**
     * Query details of all governance proposals with a completed status as Map. Wraps getAllPropDetailsInStatus().
     * @returns {Promise<IPropDetailsMap>}
     */
    getAllCompletedPropDetailsMap(): Promise<IPropDetailsMap>;
    /** End Voting Queries */
    /** Staking Msgs */
    /**
     * Claim user's staking rewards for target validator.
     * @param {string[]} validatorAddresses - Bech32 address of validator.
     * @returns {Promise<void>}
     */
    claimDelegatorRewards(validatorAddresses: string[]): Promise<void>;
    /**
     * Creates and returns Staking EncodeObject instances for external consumption by a signAndBroadcast.
     * @param {string} validatorAddress - Bech32 address of validator.
     * @param {number | string} amount - Amount to delegate in ujkl.
     * @returns {EncodeObject}
     */
    rawDelegateTokens(validatorAddress: string, amount: number | string): EncodeObject;
    /**
     * Delegates specified amount of tokens to target validator. Wraps rawDelegateTokens().
     * @param {string} validatorAddress - Bech32 address of validator.
     * @param {number | string} amount - Amount to delegate in ujkl.
     * @returns {Promise<void>}
     */
    delegateTokens(validatorAddress: string, amount: number | string): Promise<void>;
    /**
     * Creates and returns Staking EncodeObject instances for external consumption by a signAndBroadcast.
     * @param {string} validatorAddress - Bech32 address of validator.
     * @param {number | string} amount - Amount to undelegate in ujkl.
     * @returns {EncodeObject}
     */
    rawUndelegateTokens(validatorAddress: string, amount: number | string): EncodeObject;
    /**
     * Undelegates specified amount of tokens from target validator. Wraps rawUndelegateTokens().
     * @param {string} validatorAddress - Bech32 address of validator.
     * @param {number | string} amount - Amount to undelegate in ujkl.
     * @returns {Promise<void>}
     */
    undelegateTokens(validatorAddress: string, amount: number | string): Promise<void>;
    /**
     * Creates and returns Staking EncodeObject instances for external consumption by a signAndBroadcast.
     * @param {string} fromAddress - Bech32 address of source validator.
     * @param {string} toAddress - Bech32 address of receiving validator.
     * @param {number | string} amount - Amount to undelegate in ujkl.
     * @returns {EncodeObject}
     */
    rawRedelegateTokens(fromAddress: string, toAddress: string, amount: number | string): EncodeObject;
    /**
     * Redelegates specified amount of tokens between target validators. Wraps rawRedelegateTokens().
     * @param {string} fromAddress - Bech32 address of source validator.
     * @param {string} toAddress - Bech32 address of receiving validator.
     * @param {number | string} amount - Amount to undelegate in ujkl.
     * @returns {Promise<void>}
     */
    redelegateTokens(fromAddress: string, toAddress: string, amount: number | string): Promise<void>;
}

declare class NotificationHandler implements INotificationHandler {
    private readonly walletRef;
    private readonly qH;
    /**
     * Create a NotificationHandler instance.
     * @param {IWalletHandler} wallet - Instance of WalletHandler.
     * @private
     */
    private constructor();
    /**
     * Async wrapper to create a NotificationHandler instance.
     * @param {IWalletHandler} wallet - Instance of WalletHandler.
     * @returns {Promise<INotificationHandler>} - Instance of NotificationHandler.
     */
    static trackNotification(wallet: IWalletHandler): Promise<INotificationHandler>;
    /**
     * Create and send Notification to target user.
     * @param {string} notification - Notification content.
     * @param {string} address - Bech32 address of recipient.
     * @returns {EncodeObject}
     */
    makeNotification(notification: string, address: string): EncodeObject;
    /**
     * Modify previously sent Notification. Does not re-notify receiver.
     * @param {number} count - Index of Notification to update.
     * @param {string} notification - New Notification content.
     * @param {string} address - Bech32 address of recipient.
     * @returns {EncodeObject}
     */
    makeNotificationUpdate(count: number, notification: string, address: string): EncodeObject;
    /**
     * Deletes all Notifications created by user.
     * @returns {EncodeObject}
     */
    makeNotificationDeletion(): EncodeObject;
    /**
     * Initializes Notification system for user.
     * @returns {EncodeObject}
     */
    makeCounter(): EncodeObject;
    /**
     * Blocks target address from sending Notifications to user.
     * @param {string} sender - Bech32 address to block.
     * @returns {EncodeObject}
     */
    makeBlockedSender(sender: string): EncodeObject;
    /**
     * Initializes Notification system for user. Wraps makeCounter().
     * @returns {Promise<void>}
     */
    broadcastMakeCounter(): Promise<void>;
    /**
     * Get target Notification for target receiver.
     * @param {string} forAddress - Bech32 address of receiver of Notification.
     * @param {number} index - Index of Notification to retrieve.
     * @returns {Promise<QueryGetNotificationsResponse>}
     */
    getNotification(forAddress: string, index: number): Promise<QueryGetNotificationsResponse>;
    /**
     * Get all Notifications.
     * @returns {Promise<QueryAllNotificationsResponse>}
     */
    getAllNotifications(): Promise<QueryAllNotificationsResponse>;
    /**
     * Get all Notifications for target receiver.
     * @param {string} forAddress - Bech32 address of receiver of Notification.
     * @returns {Promise<Notifications[]>}
     */
    getSingleAddressNotifications(forAddress: string): Promise<Notifications[]>;
    /**
     * Check if makeCounter() or broadcastMakeCounter() has been run for target address.
     * @param {string} forAddress - Bech32 address to check.
     * @returns {Promise<boolean>}
     */
    checkNotificationInit(forAddress: string): Promise<boolean>;
    /**
     * Check Notification count for target address. Wrapper for getBaseNotiCounter().
     * @param {string} forAddress - Bech32 address to check.
     * @returns {Promise<QueryGetNotiCounterResponse>}
     */
    getNotificationCounter(forAddress: string): Promise<QueryGetNotiCounterResponse>;
    /**
     * Check Notification count for all addresses.
     * @returns {Promise<QueryAllNotiCounterResponse>}
     */
    getAllNotificationCounters(): Promise<QueryAllNotiCounterResponse>;
    /** Standardized Messages */
    /**
     * Standardized general-purpose Notification Msg creator.
     * @param {string} type - Notification identification code.
     * @param {string} address - Bech32 address of Notification target.
     * @returns {Promise<EncodeObject>}
     */
    makeStandardizedShareNotification(type: string, address: string): Promise<EncodeObject>;
    /**
     * Create sharing added Notification entry. Wraps makeStandardizedShareNotification().
     * @param {string} address - Bech32 address of Notification target.
     * @returns {Promise<EncodeObject>}
     */
    makeAddShareNoti(address: string): Promise<EncodeObject>;
    /**
     * Create sharing updated Notification entry. Wraps makeStandardizedShareNotification().
     * @param {string} address - Bech32 address of Notification target.
     * @returns {Promise<EncodeObject>}
     */
    makeUpdateShareNoti(address: string): Promise<EncodeObject>;
    /**
     * Create sharing cancelled Notification entry. Wraps makeStandardizedShareNotification().
     * @param {string} address - Bech32 address of Notification target.
     * @returns {Promise<EncodeObject>}
     */
    makeRemoveShareNoti(address: string): Promise<EncodeObject>;
    /** Read Encrypted Notifications */
    /**
     * Query user's Notification by index
     * @param {number} index - Index of Notification to retrieve.
     * @returns {Promise<IReadableNoti>}
     */
    readMyShareNoti(index: number): Promise<IReadableNoti>;
    /**
     * Query all of user's Notifications.
     * @returns {Promise<IReadableNoti[]>}
     */
    readAllMyShareNotis(): Promise<IReadableNoti[]>;
    /** Private Methods */
    /**
     * Check Notification count for target address.
     * @param {string} forAddress - Bech32 address for target.
     * @returns {Promise<IBaseNotiResponse>}
     * @private
     */
    private getBaseNotiCounter;
}

declare class OracleHandler implements IOracleHandler {
    private readonly qH;
    /**
     * Receives properties from trackOracle() to instantiate OracleHandler.
     * @param {IWalletHandler} wallet - Query or signing WalletHandler instance.
     * @private
     */
    private constructor();
    /**
     * Creates OracleHandler instance.
     * @param {IWalletHandler} wallet - Query or signing WalletHandler instance.
     * @returns {Promise<IOracleHandler>} - OracleHandler instance linked to provided WalletHandler instance.
     */
    static trackOracle(wallet: IWalletHandler): Promise<IOracleHandler>;
    /**
     * Retrieve data of specified on-chain oracle.
     * @param {string} name - Name of oracle.
     * @returns {Promise<IOracleFeed>}
     */
    getFeed(name: string): Promise<IOracleFeed>;
    /**
     * Retrieve data of all on-chain oracles.
     * @returns {Promise<IOracleFeed[]>}
     */
    getAllFeeds(): Promise<IOracleFeed[]>;
}

/**
 * Class encompassing basic and advanced methods needed for interaction with RNS addresses on the chain.
 */
declare class RnsHandler implements IRnsHandler {
    private readonly walletRef;
    private readonly qH;
    /**
     * Create an RNS instance.
     * @param {IWalletHandler} wallet - Instance of WalletHandler from WalletHandler.trackWallet().
     * @private
     */
    private constructor();
    /**
     * Async wrapper to create an RNS instance.
     * @param {IWalletHandler} wallet - Instance of WalletHandler from WalletHandler.trackWallet().
     * @returns {Promise<IRnsHandler>} - Instance of RnsHandler.
     */
    static trackRns(wallet: IWalletHandler): Promise<IRnsHandler>;
    /**
     * Create Msg for accepting a bid on the user's RNS.
     * @param {string} rns -  The RNS to accept the bid for.
     * @param {string} from - The Jackal address to accept the bid from.
     * @returns {EncodeObject} - The Msg for processing by the chain.
     */
    makeAcceptBidMsg(rns: string, from: string): EncodeObject;
    /**
     * Create Msg for adding a subdomain entry on the user's RNS.
     * @param {IRnsRecordItem} recordValues - New subdomain's values.
     * @returns {EncodeObject} - The Msg for processing by the chain.
     */
    makeAddRecordMsg(recordValues: IRnsRecordItem): EncodeObject;
    /**
     * Create Msg for submitting an offer on another user's RNS.
     * @param {string} rns - RNS to submit offer on.
     * @param {string} bid - Value of offer in ujkl. Example: "1000000ujkl" (1 $JKL).
     * @returns {EncodeObject} - The Msg for processing by the chain.
     */
    makeBidMsg(rns: string, bid: string): EncodeObject;
    /**
     * Create Msg for purchasing RNS listed on market.
     * @param {string} rns - RNS to purchase.
     * @returns {EncodeObject} - The Msg for processing by the chain.
     */
    makeBuyMsg(rns: string): EncodeObject;
    /**
     * Create Msg to retract offer on another user's RNS.
     * @param {string} rns - RNS to retract offer from.
     * @returns {EncodeObject} - The Msg for processing by the chain.
     */
    makeCancelBidMsg(rns: string): EncodeObject;
    /**
     * Create Msg to remove user's RNS from the market.
     * @param {string} rns - RNS to remove.
     * @returns {EncodeObject} - The Msg for processing by the chain.
     */
    makeDelistMsg(rns: string): EncodeObject;
    /**
     * Create Msg to delete user's RNS.
     * @param {string} rns - RNS to delete.
     * @returns {EncodeObject} - The Msg for processing by the chain.
     */
    makeDelRecordMsg(rns: string): EncodeObject;
    /**
     * Create Msg to activate user in the RNS system and to generate free account RNS.
     * @returns {EncodeObject} - The Msg for processing by the chain.
     */
    makeRnsInitMsg(): EncodeObject;
    /**
     * Create Msg to add user's RNS to the market.
     * @param {string} rns - RNS to list on market.
     * @param {string} price - Price of offer in ujkl. Example: "1000000ujkl" (1 $JKL).
     * @returns {EncodeObject} - The Msg for processing by the chain.
     */
    makeListMsg(rns: string, price: string): EncodeObject;
    /**
     * Create Msg to register new RNS.
     * @param {IRnsRegistrationItem} registrationValues - Bundle containing RNS name, duration in years, and JSON.stringified metadata.
     * @returns {EncodeObject} - The Msg for processing by the chain.
     */
    makeNewRegistrationMsg(registrationValues: IRnsRegistrationItem): EncodeObject;
    /**
     * Create Msg to transfer user's RNS to another user.
     * @param {string} rns - RNS to transfer.
     * @param {string} receiver - Jackal address to transfer to.
     * @returns {EncodeObject} - The Msg for processing by the chain.
     */
    makeTransferMsg(rns: string, receiver: string): EncodeObject;
    /**
     * Create Msg to update RNS metadata.
     * @param {string} rns - User's RNS to update.
     * @param {string} data - JSON.stringified new metadata to replace existing data.
     * @returns {EncodeObject} - The Msg for processing by the chain.
     */
    makeUpdateMsg(rns: string, data: string): EncodeObject;
    /**
     * Find a specific RNS bid by global index.
     * @param {string} index - Index to find.
     * @returns {Promise<IRnsBidItem>} - Bid if found, defaults to bid item with empty values if no match found.
     */
    findSingleBid(index: string): Promise<IRnsBidItem>;
    /**
     * List all outstanding bids for all users.
     * @returns {Promise<IRnsBidHashMap>} - Object map of bid arrays by RNS name.
     */
    findAllBids(): Promise<IRnsBidHashMap>;
    /**
     * Get RNS market details for a single listed RNS.
     * @param {string} rns - RNS address to find.
     * @returns {Promise<IRnsForSaleItem>} - Listing if found, defaults to list item with empty values if no match found.
     */
    findSingleForSaleName(rns: string): Promise<IRnsForSaleItem>;
    /**
     * Finds paginated RNS listed on market
     * @returns {Promise<IPaginatedMap<IRnsForSaleHashMap>>}
     */
    findSomeForSaleNames(options?: IPagination): Promise<IPaginatedMap<IRnsForSaleHashMap>>;
    /**
     * Finds all RNS listed on market.
     * @param {number} blockTime - Block length in milliseconds.
     * @returns {Promise<IRnsExpandedForSaleHashMap>} - Object map of list items by RNS name.
     */
    findAllForSaleNames(blockTime?: number): Promise<IRnsExpandedForSaleHashMap>;
    findAllNames(): Promise<IRnsExistsHashMap>;
    /**
     * Finds all RNS listed on market and flags "mine" boolean if the user owns the RNS.
     * @param {number} blockTime - Block length in milliseconds.
     * @returns {Promise<IRnsExpandedForSaleHashMap>} - Object map of list items by RNS name.
     */
    findExpandedForSaleNames(blockTime?: number): Promise<IRnsExpandedForSaleHashMap>;
    /**
     * Finds all RNS the current user owns.
     * @param {number} blockTime - Block length in milliseconds.
     * @returns {Promise<IRnsOwnedHashMap>} - Object map of entries by RNS name, locked RNS is stored as "free" instead.
     */
    findMyExistingNames(blockTime?: number): Promise<IRnsOwnedHashMap>;
    /**
     * Finds all RNS the target user owns.
     * @param {string} address - JKL address to check for RNS names.
     * @param {number} blockTime - Block length in milliseconds.
     * @returns {Promise<IRnsOwnedHashMap>} - Object map of entries by RNS name, locked RNS is stored as "free" instead.
     */
    findYourExistingNames(address: string, blockTime?: number): Promise<IRnsOwnedHashMap>;
    /**
     * Find RNS details using RNS address.
     * @param {string} rns - RNS address to search.
     * @returns {Promise<IRnsItem>} - Data if found, defaults to item with empty values if no match found.
     */
    findSingleRns(rns: string): Promise<IRnsItem>;
    /**
     * Find owner's address using RNS address.
     * @param {string} rns - RNS address to search.
     * @returns {Promise<string>} - Owner's address if found, defaults to empty string if no match found.
     */
    findMatchingAddress(rns: string): Promise<string>;
}

declare class StorageHandler implements IStorageHandler {
    private readonly walletRef;
    private readonly qH;
    /**
     * Receives properties from trackStorage() instantiate StorageHandler.
     * @param {IWalletHandler} wallet - Query or signing WalletHandler instance.
     * @private
     */
    private constructor();
    /**
     * Creates StorageHandler instance.
     * @param {IWalletHandler} wallet - Query or signing WalletHandler instance.
     * @returns {Promise<IStorageHandler>} - StorageHandler instance linked to provided WalletHandler instance.
     */
    static trackStorage(wallet: IWalletHandler): Promise<IStorageHandler>;
    /**
     * Purchase storage for specified address that does not currently have storage. For existing see upgradeStorage().
     * @param {string} forAddress - Jkl address to receive the purchased storage.
     * @param {number} duration - How long in months to purchase the storage.
     * @param {number} space - Amount of effective storage to purchase in TB.
     * @returns {Promise<DeliverTxResponse>} - Result of purchase broadcast.
     */
    buyStorage(forAddress: string, duration: number, space: number): Promise<DeliverTxResponse>;
    /**
     * Purchase storage for specified address that currently has storage. For new see buyStorage().
     * @param {string} forAddress - Jkl address to receive the purchased storage.
     * @param {number} duration - How long in months to purchase the storage.
     * @param {number} space - Amount of effective storage to purchase in TB.
     * @returns {Promise<DeliverTxResponse>} - Result of purchase broadcast.
     */
    upgradeStorage(forAddress: string, duration: number, space: number): Promise<DeliverTxResponse>;
    /**
     * Initialize address' storage system. Replaces WalletHandler.initAccount().
     * @returns {EncodeObject} - Postkey msg ready for broadcast.
     */
    makeStorageInitMsg(): EncodeObject;
    /**
     * Find all strays in the storage deals system.
     * @returns {Promise<IStray[]>}
     */
    getAllStrays(): Promise<IStray[]>;
    /**
     * Determine how much space jkl address has remaining.
     * @param {string} address - Jkl address to check.
     * @returns {Promise<number>} - Remaining space in bytes.
     */
    getClientFreeSpace(address: string): Promise<number>;
    /**
     * Determine current price in $JKL of specified size and duration of storage.
     * @param {number} space - Amount of effective space to use for price check.
     * @param {number} duration - Amount of time to use for price check.
     * @returns {Promise<number>} - Estimated price of specified storage in ujkl.
     */
    getStorageJklPrice(space: number, duration: number): Promise<number>;
    /**
     * Determine what storage plan (if any) has been purchased for the provided jkl address.
     * @param {string} address - Jkl address to check.
     * @returns {Promise<IPayData>} - Storage plan details.
     */
    getPayData(address: string): Promise<IPayData>;
    /**
     * Determine space used and available for provided jkl address.
     * @param {string} address - Jkl address to check.
     * @returns {Promise<IStoragePaymentInfo>} - Space used and available. Defaults to zeros when nothing is found.
     */
    getStoragePaymentInfo(address: string): Promise<IStoragePaymentInfo>;
    /** Manage FT Noti */
    private readonly sharingRoot;
    /**
     * Save data to file sharing address. Overwrites existing data. Savable only by owner.
     * @param {string} receiverAddress - Jkl address receiving sharing data.
     * @param {ISharedTracker} shared - Bundle of all records shared with receiverAddress.
     * @returns {Promise<EncodeObject>} - PostFile msg ready for broadcast.
     */
    saveSharing(receiverAddress: string, shared: ISharedTracker): Promise<EncodeObject>;
    /**
     * Read data saved with saveSharing(). accessible by owner and sharing receiver.
     * @param {string} owner - data owner's jkl address.
     * @param {string} receiverAddress - Jkl address receiving sharing data.
     * @returns {Promise<ISharedTracker>} - Bundle of all records shared with receiver.
     */
    readSharing(owner: string, receiverAddress: string): Promise<ISharedTracker>;
    /**
     * Remove all sharing data for specified receiver.
     * @param {string} receiverAddress - Jkl address receiving sharing data.
     * @returns {Promise<EncodeObject>} - DeleteFile msg ready for broadcast.
     */
    stopSharing(receiverAddress: string): Promise<EncodeObject>;
}

declare class WalletHandler implements IWalletHandler {
    private readonly qH;
    private properties;
    traits: IWalletHandlerPublicProperties | null;
    /**
     * Receives properties from trackWallet() or trackQueryWallet() to instantiate WalletHandler.
     * @param {IQueryHandler} qH - QueryHandler: Always present.
     * @param {IWalletHandlerPrivateProperties | null} properties - Properties that have getters and setters.
     * @param {IWalletHandlerPublicProperties | null} traits - Read-only properties. Can be reset with voidFullWallet().
     * @private
     */
    private constructor();
    /**
     * Creates full WalletHandler vs query-only from trackQueryWallet().
     * @param {IWalletConfig} config - Config items needed to create a signing WalletHandler.
     * @param {IMnemonicWallet} session - IMnemonicWallet instance.
     * @returns {Promise<IWalletHandler>} - Signing WalletHandler.
     */
    static trackWallet(config: IWalletConfig, session: IMnemonicWallet): Promise<IWalletHandler>;
    /**
     * Creates query WalletHandler vs signing wallet from trackWallet().
     * @param {string} queryUrl - URL to query api node.
     * @returns {Promise<IWalletHandler>} - Query-only WalletHandler.
     */
    static trackQueryWallet(queryUrl?: string): Promise<IWalletHandler>;
    /**
     * Merkle items together, intended for arbitrary paths.
     * @param {string} path - Path to merkle.
     * @param {string} item - Target to merkle.
     * @returns {Promise<string>} - Merkled result.
     */
    static getAbitraryMerkle(path: string, item: string): Promise<string>;
    /**
     * Converts query-only WalletHandler instance to signing instance.
     * @param {IWalletConfig} config - Requires same object as trackWallet().
     * @param {IMnemonicWallet} session - IMnemonicWallet instance.
     * @returns {Promise<void>}
     */
    convertToFullWallet(config: IWalletConfig, session: IMnemonicWallet): Promise<void>;
    /**
     * Converts signing WalletHandler instance to query-only instance.
     * @returns {void}
     */
    voidFullWallet(): void;
    /**
     * Check user's RNS initialization status.
     * @returns {boolean} - Indicates if user's RNS has been initialized.
     */
    getRnsInitStatus(): boolean;
    /**
     * Save a RNS initialization status to the signing WalletHandler instance.
     * @param {boolean} status - RNS initialization status.
     * @returns {Promise<void>}
     */
    setRnsInitStatus(status: boolean): void;
    /**
     * Check user's Storage initialization status.
     * @returns {boolean} - Indicates if user's Storage has been initialized.
     */
    getStorageInitStatus(): boolean;
    /**
     * Save a Storage initialization status to the signing WalletHandler instance.
     * @param {boolean} status - Storage initialization status.
     * @returns {Promise<void>}
     */
    setStorageInitStatus(status: boolean): void;
    /**
     * Expose signing WalletHandler instance ProtoHandler instance.
     * @returns {IProtoHandler}
     */
    getProtoHandler(): IProtoHandler;
    /**
     * Expose query or signing WalletHandler instance QueryHandler instance.
     * @returns {IQueryHandler}
     */
    getQueryHandler(): IQueryHandler;
    /**
     * Expose signing WalletHandler instance Signer accounts.
     * @returns {Promise<readonly AccountData[]>}
     */
    getAccounts(): Promise<readonly AccountData[]>;
    /**
     * Expose signing WalletHandler instance Signer.
     * @returns {OfflineSigner}
     */
    getSigner(): OfflineSigner;
    /**
     * Expose signing WalletHandler instance jkl address.
     * @returns {string} - Jkl address.
     */
    getJackalAddress(): string;
    /**
     * Expose signing WalletHandler instance jkl address' hex value.
     * @returns {Promise<string>} - Hashed and hexed jkl address.
     */
    getHexJackalAddress(): Promise<string>;
    /**
     * Retrieve all signing WalletHandler instance tokens and balances for all supported chains.
     * @returns {Promise<ICoin[]>} - All tokens and balances held by Signer.
     */
    getAllBalances(): Promise<ICoin[]>;
    /**
     * Retrieve balance of $JKL in ujkl for signing WalletHandler instance.
     * @returns {Promise<ICoin>} - Balance in ujkl.
     */
    getJackalBalance(): Promise<ICoin>;
    /**
     * Expose signing WalletHandler instance public key as hex value.
     * @returns {string} - Public key as hex value.
     */
    getPubkey(): string;
    /**
     * Encrypt value using public key from either findPubKey() or getPubkey(). Half of an asymmetric keypair.
     * @param {Buffer} toEncrypt - Value to encrypt.
     * @param {string} pubKey - Public key as hex value.
     * @returns {string} - Encrypted value.
     */
    asymmetricEncrypt(toEncrypt: Buffer, pubKey: string): string;
    /**
     * Decrypt value using signing WalletHandler instance private key. Half of an asymmetric keypair.
     * @param {string} toDecrypt - Value to decrypt.
     * @returns {ArrayBuffer} - Decrypted value.
     */
    asymmetricDecrypt(toDecrypt: string): Buffer;
    /**
     * Retrieve asymmetric keypair public key from chain for specified jkl address.
     * @param {string} address - Jkl address to check.
     * @returns {Promise<string>} - Target address' public key as hex value.
     */
    findPubKey(address: string): Promise<string>;
    /**
     * Handler Factories
     */
    /**
     * Create AbciHandler instance and link to query or signing WalletHandler instance.
     * @returns {Promise<IAbciHandler>}
     */
    makeAbciHandler(): Promise<IAbciHandler>;
    /**
     * Create FileIo instance and link to signing WalletHandler instance.
     * @returns {Promise<IFileIo | null>} - Query WalletHandler instance returns null instead.
     */
    makeFileIoHandler(versionFilter?: string | string[]): Promise<IFileIo | null>;
    /**
     * Create GovHandler instance and link to query or signing WalletHandler instance.
     * @returns {Promise<IGovHandler>}
     */
    makeGovHandler(): Promise<IGovHandler>;
    /**
     * Create NotificationHandler instance and link to query or signing WalletHandler instance.
     * @returns {Promise<INotificationHandler>}
     */
    makeNotificationHandler(): Promise<INotificationHandler>;
    /**
     * Create OracleHandler instance and link to query or signing WalletHandler instance.
     * @returns {Promise<IOracleHandler>}
     */
    makeOracleHandler(): Promise<IOracleHandler>;
    /**
     * Create RnsHandler instance and link to query or signing WalletHandler instance.
     * @returns {Promise<IRnsHandler>}
     */
    makeRnsHandler(): Promise<IRnsHandler>;
    /**
     * Create StorageHandler instance and link to query or signing WalletHandler instance.
     * @returns {Promise<IStorageHandler>}
     */
    makeStorageHandler(): Promise<IStorageHandler>;
}

type TFileOrFFile = IFileUploadHandler | IFolderHandler;

/**
 * Notify that function is deprecated and should no longer be used.
 * @param {string} thing - Name of deprecated item. Example: "[ParentContext] functionName()".
 * @param {string} version - First version with deprecated item. Example: "v1.1.1".
 * @param {{aggressive?: boolean, replacement?: string}} opts -
 * Aggressive: TRUE to trigger alert.
 * Replacement: the function name that should be used instead. Example: "replacementFunction()".
 */
declare function deprecated(thing: string, version: string, opts?: {
    aggressive?: boolean;
    replacement?: string;
}): void;
declare function getRandomIndex(limit: number): number;
/**
 * Notify that Signer has not been enabled.
 * @param {string} module - Name of parent Module.
 * @param {string} func - Name of function error occured in.
 * @returns {string} - String containing error message.
 */
declare function signerNotEnabled(module: string, func: string): string;
/**
 * Sort array of strings in A-Z order.
 * @param {string[]} sortable - Array of string to organize.
 * @returns {string[]} - Array of sorted strings.
 */
declare function orderStrings(sortable: string[]): string[];
/**
 * Remove all slashes "/".
 * @param {string} value - Starting string.
 * @returns {string} - String without slashes.
 */
declare function stripper(value: string): string;
/**
 * Check chain response for insufficient gas.
 * @param response - @cosmjs/stargate DeliverTxResponse.
 */
declare function checkResults(response: any): void;
/**
 * Round number to whole TB (See numTo3xTB().
 * @param {number | string} base - Accepts number or number-like string.
 * @returns {string} - Whole TB as string for Msg compatibility.
 */
declare function numToWholeTB(base: number | string): string;
/**
 * Round any number to TB.
 * @param {number | string} base - Accepts number or number-like string.
 * @returns {string} - Total TB as string for Msg compatibility.
 */
declare function numTo3xTB(base: number | string): string;
/**
 * Forces string "null" or "undefined" to their proper types. Needed for handling some responses.
 * @param {string} value - String to check.
 * @returns {string | undefined | null} - Returns null or undefined if string matches, otherwise returns original string.
 */
declare function bruteForceString(value: string): string | undefined | null;
/**
 * Cycle through pagination results and merge into single result.
 * @param handler - QueryHandler to use for function source.
 * @param {string} queryTag - Query function to use.
 * @param additionalParams - Non-pagination parameters required by queryTag function.
 * @returns {Promise<any[]>} - Merged pagination results.
 */
declare function handlePagination(handler: any, queryTag: string, additionalParams?: any): Promise<any[]>;
/**
 * Set a timer.
 * @param {number} duration - Duration of timer in ms.
 * @returns {Promise<void>}
 */
declare function setDelay(duration: number): Promise<void>;
/**
 * Converts chain block height to UTC Date using getAverageBlockTime().
 * @param {IBlockTimeOptions} options - Values to use for calculating UTC date.
 * @returns {Promise<Date>} - Date object for future date matching input future chain height.
 */
declare function blockToDate(options: IBlockTimeOptions): Promise<Date>;
/**
 * Converts chain block height to UTC Date using provided block time value.
 * @param {IBlockTimeOptions} options - Values to use for calculating UTC date.
 * @returns {Date} - Date object for future date matching input future chain height.
 */
declare function blockToDateFixed(options: IBlockTimeOptions): Date;
/**
 * Fine average block time of recent blocks.
 * @param {string} rpc - RPC node address to query.
 * @param {number} blocks - Number of blocks to use for average.
 * @returns {Promise<number>} - Time in ms per block of submitted window.
 */
declare function getAverageBlockTime(rpc: string, blocks: number): Promise<number>;
/**
 * Converts Uint8Array to string.
 * @param {Uint8Array} buf - Uint8Array to convert.
 * @returns {string} - Converted result.
 */
declare function uint8ToString(buf: Uint8Array): string;
/**
 * Converts string to Uint8Array.
 * @param {string} str - String to convert.
 * @returns {Uint8Array} - Converted result.
 */
declare function stringToUint8(str: string): Uint8Array;
/**
 * Converts Uint16Array to string.
 * @param {Uint16Array} buf - Uint16Array to convert.
 * @returns {string} - Converted result.
 */
declare function uint16ToString(buf: Uint16Array): string;
/**
 * Converts string to Uint16Array.
 * @param {string} str - String to convert.
 * @returns {Uint16Array} - Converted result.
 */
declare function stringToUint16(str: string): Uint16Array;
/**
 * Retrieve data from FileTree path.
 * @param {string} rawPath - FileTree path to retrieve from.
 * @param {string} owner - Jkl address of path owner.
 * @param {IQueryHandler} qH - QueryHandler instance.
 * @returns {Promise<IFileResponse>} - Raw query response.
 */
declare function getFileTreeData(rawPath: string, owner: string, qH: IQueryHandler): Promise<IFileResponse>;
/**
 * Forces Blob-likes to proper Blob.
 * @param {Blob} source - Blob-likes to sanitize.
 * @returns {Promise<Blob>} - Sanitized Blob.
 */
declare function standardizeBlob(source: Blob): Promise<Blob>;
/**
 * Forces array of Blob-likes and ArrayBufferViews to array of Uint8Arrays.
 * @param {any[]} source - Mixed array of Blob-likes and ArrayBufferViews.
 * @returns {Promise<Uint8Array[]>} - Sanitized array of Uint8Arrays.
 */
declare function standardizeFileSource(source: any[]): Promise<Uint8Array[]>;
interface IFileResponse {
    message: string;
    success: boolean;
    value: QueryFileResponse;
}
interface IBlockTimeOptions {
    blockTime?: number;
    rpcUrl?: string;
    currentBlockHeight: number;
    targetBlockHeight: number | string;
}

/**
 * Convert CryptoKey to storable format (see importJackalKey()).
 * @param {CryptoKey} key - CryptoKey to convert.
 * @returns {Promise<Uint8Array>} - CryptoKey as Uint8Array.
 */
declare function exportJackalKey(key: CryptoKey): Promise<Uint8Array>;
/**
 * Convert stored format to CryptoKey (see exportJackalKey()).
 * @param {Uint8Array} rawExport - Uint8Array to recover to CryptoKey.
 * @returns {Promise<CryptoKey>} - Recovered CryptoKey.
 */
declare function importJackalKey(rawExport: Uint8Array): Promise<CryptoKey>;
/**
 * Generate a new CryptoKey from scratch. Compatible with AES-256 and exportJackalKey(). Supports encrypt and decrypt.
 * @returns {Promise<CryptoKey>} - Fresh random CryptoKey.
 */
declare function genKey(): Promise<CryptoKey>;
/**
 * Generate a new iv from scratch. Compatible with AES-256.
 * @returns {Uint8Array} - Fresh random iv.
 */
declare function genIv(): Uint8Array;
/**
 * Encrypt or decrypt a NodeJs Buffer using AES-256 (AES-GCM).
 * @param {Buffer} data - Source to encrypt or decrypt.
 * @param {CryptoKey} key - Key to use. Decryption key must match encryption key that was used.
 * @param {Uint8Array} iv - Iv to use. Decryption iv must match encryption iv that was used.
 * @param {"encrypt" | "decrypt"} mode - Toggle between encryption and decryption.
 * @returns {Promise<Buffer>} - Processed result.
 */
declare function aesCrypt(data: Buffer, key: CryptoKey, iv: Uint8Array, mode: 'encrypt' | 'decrypt'): Promise<Buffer>;
/**
 * Encrypts AES iv/CryptoKey set to string using receiver's ECIES public key.
 * @param {IWalletHandler} wallet - Wallet instance for accessing functions.
 * @param {string} pubKey - Receiver's ECIES public key.
 * @param {IAesBundle} aes - AES iv/CryptoKey set to encrypt.
 * @returns {Promise<string>} - Encrypted string with pipe "|" delimiter.
 */
declare function aesToString(wallet: IWalletHandler, pubKey: string, aes: IAesBundle): Promise<string>;
/**
 * Decrypts AES iv/CryptoKey set from string using owner's ECIES private key.
 * @param {IWalletHandler} wallet - Wallet instance for accessing functions and owner's private key.
 * @param {string} source - String containing encrypted AES iv/CryptoKey set with pipe "|" delimiter.
 * @returns {Promise<IAesBundle>} - Decrypted AES iv/CryptoKey set.
 */
declare function stringToAes(wallet: IWalletHandler, source: string): Promise<IAesBundle>;
/**
 * Converts raw File to Public-mode File.
 * @param {File} workingFile - Source File.
 * @returns {Promise<File>} - Public-mode File.
 */
declare function convertToPublicFile(workingFile: File): Promise<File>;
/**
 * Converts raw Public-mode NodeJS Buffer to File.
 * @param {Buffer} source - Source raw NodeJS Buffer.
 * @returns {Promise<File>} - Decrypted File.
 */
declare function convertFromPublicFile(source: Buffer): Promise<File>;
/**
 * Converts raw File to encrypted File.
 * @param {File} workingFile - Source File.
 * @param {CryptoKey} key - AES-256 CryptoKey.
 * @param {Uint8Array} iv - AES-256 iv.
 * @returns {Promise<File>} - Encrypted File.
 */
declare function convertToEncryptedFile(workingFile: File, key: CryptoKey, iv: Uint8Array): Promise<File>;
/**
 * Converts raw NodeJS Buffer to decrypted File.
 * @param {Buffer} source - Source raw Buffer.
 * @param {CryptoKey} key - AES-256 CryptoKey.
 * @param {Buffer} iv - AES-256 iv.
 * @returns {Promise<File>} - Decrypted File.
 */
declare function convertFromEncryptedFile(source: Buffer, key: CryptoKey, iv: Uint8Array): Promise<File>;
/**
 * Encrypt or decrypt a string using AES-256 (AES-GCM).
 * @param {string} input - Source string to encrypt or decrypt.
 * @param {CryptoKey} key - CryptoKey to use. Decryption CryptoKey must match encryption CryptoKey that was used.
 * @param {Uint8Array} iv - Iv to use. Decryption iv must match encryption iv that was used.
 * @param {"encrypt" | "decrypt"} mode - Toggle between encryption and decryption.
 * @returns {Promise<string>} - Processed result.
 */
declare function cryptString(input: string, key: CryptoKey, iv: Uint8Array, mode: 'encrypt' | 'decrypt'): Promise<string>;

export { AbciHandler, FileDownloadHandler, FileIo, FileUploadHandler, FolderHandler, GovHandler, IAbciHandler, IAdditionalWalletOptions, IAesBundle, IChainConfig, IChildDirInfo, ICoin, ICurrency, IDelegationDetails, IDelegationRewards, IDelegationSummary, IDelegationSummaryMap, IDeleteItem, IDownloadDetails, IEditorsViewers, IEnabledSecrets, IFileBuffer, IFileConfigFull, IFileConfigRaw, IFileConfigRelevant, IFileDetails, IFileDownloadHandler, IFileIo, IFileMeta, IFileMetaHashMap, IFileUploadHandler, IFiletreeParsedContents, IFolderAdd, IFolderChildFiles, IFolderDownload, IFolderFrame, IFolderHandler, IGasHashMap, IGasRate, IGovHandler, IMiner, IMnemonicWallet, IMsgFinalPostFileBundle, IMsgPartialPostFileBundle, INotificationHandler, IOracleFeed, IOracleHandler, IPaginatedMap, IPagination, IPayData, IPermsParts, IPropDetails, IPropDetailsMap, IProtoConfig, IProtoHandler, IProviderChecks, IProviderModifiedResponse, IProviderResponse, IProviderVersionResponse, IQueryHandler, IQueueItemPostUpload, IReadableNoti, IRnsBidHashMap, IRnsBidItem, IRnsExistsHashMap, IRnsExpandedForSaleHashMap, IRnsExpandedForSaleItem, IRnsExpandedItem, IRnsForSaleHashMap, IRnsForSaleItem, IRnsHandler, IRnsItem, IRnsOwnedHashMap, IRnsRecordItem, IRnsRegistrationItem, ISharedTracker, IStaggeredTracker, IStakingValidator, IStakingValidatorExtended, IStakingValidatorExtendedMap, IStakingValidatorMap, IStakingValidatorStaked, IStakingValidatorStakedMap, IStorageClientFree, IStorageHandler, IStoragePaymentInfo, IStray, ISupportedWallets, IUploadList, IUploadListItem, IValidatorDescription, IWalletConfig, IWalletHandler, IWalletHandlerPrivateProperties, IWalletHandlerPublicProperties, IWrappedEncodeObject, MnemonicWallet, NotificationHandler, OracleHandler, RnsHandler, StorageHandler, TFileOrFFile, WalletHandler, aesCrypt, aesToString, blockToDate, blockToDateFixed, bruteForceString, checkResults, convertFromEncryptedFile, convertFromPublicFile, convertToEncryptedFile, convertToPublicFile, cryptString, deprecated, exportJackalKey, genIv, genKey, getAverageBlockTime, getFileTreeData, getRandomIndex, handlePagination, importJackalKey, numTo3xTB, numToWholeTB, orderStrings, setDelay, signerNotEnabled, standardizeBlob, standardizeFileSource, stringToAes, stringToUint16, stringToUint8, stripper, uint16ToString, uint8ToString };
